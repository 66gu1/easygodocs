// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/user.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_user "github.com/66gu1/easygodocs/internal/app/user"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// RepositoryMock implements mm_user.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangePassword          func(ctx context.Context, id uuid.UUID, newPasswordHash string) (err error)
	funcChangePasswordOrigin    string
	inspectFuncChangePassword   func(ctx context.Context, id uuid.UUID, newPasswordHash string)
	afterChangePasswordCounter  uint64
	beforeChangePasswordCounter uint64
	ChangePasswordMock          mRepositoryMockChangePassword

	funcCreateUser          func(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id uuid.UUID)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mRepositoryMockDeleteUser

	funcGetAllUsers          func(ctx context.Context) (ua1 []mm_user.User, err error)
	funcGetAllUsersOrigin    string
	inspectFuncGetAllUsers   func(ctx context.Context)
	afterGetAllUsersCounter  uint64
	beforeGetAllUsersCounter uint64
	GetAllUsersMock          mRepositoryMockGetAllUsers

	funcGetUser          func(ctx context.Context, id uuid.UUID) (u1 mm_user.User, s1 string, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id uuid.UUID)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mRepositoryMockGetUser

	funcGetUserByEmail          func(ctx context.Context, email string) (u1 mm_user.User, s1 string, err error)
	funcGetUserByEmailOrigin    string
	inspectFuncGetUserByEmail   func(ctx context.Context, email string)
	afterGetUserByEmailCounter  uint64
	beforeGetUserByEmailCounter uint64
	GetUserByEmailMock          mRepositoryMockGetUserByEmail

	funcUpdateUser          func(ctx context.Context, req mm_user.UpdateUserReq) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, req mm_user.UpdateUserReq)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mRepositoryMockUpdateUser
}

// NewRepositoryMock returns a mock for mm_user.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangePasswordMock = mRepositoryMockChangePassword{mock: m}
	m.ChangePasswordMock.callArgs = []*RepositoryMockChangePasswordParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.DeleteUserMock = mRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*RepositoryMockDeleteUserParams{}

	m.GetAllUsersMock = mRepositoryMockGetAllUsers{mock: m}
	m.GetAllUsersMock.callArgs = []*RepositoryMockGetAllUsersParams{}

	m.GetUserMock = mRepositoryMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*RepositoryMockGetUserParams{}

	m.GetUserByEmailMock = mRepositoryMockGetUserByEmail{mock: m}
	m.GetUserByEmailMock.callArgs = []*RepositoryMockGetUserByEmailParams{}

	m.UpdateUserMock = mRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*RepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockChangePassword struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockChangePasswordExpectation
	expectations       []*RepositoryMockChangePasswordExpectation

	callArgs []*RepositoryMockChangePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockChangePasswordExpectation specifies expectation struct of the Repository.ChangePassword
type RepositoryMockChangePasswordExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockChangePasswordParams
	paramPtrs          *RepositoryMockChangePasswordParamPtrs
	expectationOrigins RepositoryMockChangePasswordExpectationOrigins
	results            *RepositoryMockChangePasswordResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockChangePasswordParams contains parameters of the Repository.ChangePassword
type RepositoryMockChangePasswordParams struct {
	ctx             context.Context
	id              uuid.UUID
	newPasswordHash string
}

// RepositoryMockChangePasswordParamPtrs contains pointers to parameters of the Repository.ChangePassword
type RepositoryMockChangePasswordParamPtrs struct {
	ctx             *context.Context
	id              *uuid.UUID
	newPasswordHash *string
}

// RepositoryMockChangePasswordResults contains results of the Repository.ChangePassword
type RepositoryMockChangePasswordResults struct {
	err error
}

// RepositoryMockChangePasswordOrigins contains origins of expectations of the Repository.ChangePassword
type RepositoryMockChangePasswordExpectationOrigins struct {
	origin                string
	originCtx             string
	originId              string
	originNewPasswordHash string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangePassword *mRepositoryMockChangePassword) Optional() *mRepositoryMockChangePassword {
	mmChangePassword.optional = true
	return mmChangePassword
}

// Expect sets up expected params for Repository.ChangePassword
func (mmChangePassword *mRepositoryMockChangePassword) Expect(ctx context.Context, id uuid.UUID, newPasswordHash string) *mRepositoryMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &RepositoryMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.paramPtrs != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by ExpectParams functions")
	}

	mmChangePassword.defaultExpectation.params = &RepositoryMockChangePasswordParams{ctx, id, newPasswordHash}
	mmChangePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChangePassword.expectations {
		if minimock.Equal(e.params, mmChangePassword.defaultExpectation.params) {
			mmChangePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangePassword.defaultExpectation.params)
		}
	}

	return mmChangePassword
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ChangePassword
func (mmChangePassword *mRepositoryMockChangePassword) ExpectCtxParam1(ctx context.Context) *mRepositoryMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &RepositoryMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &RepositoryMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.ctx = &ctx
	mmChangePassword.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChangePassword
}

// ExpectIdParam2 sets up expected param id for Repository.ChangePassword
func (mmChangePassword *mRepositoryMockChangePassword) ExpectIdParam2(id uuid.UUID) *mRepositoryMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &RepositoryMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &RepositoryMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.id = &id
	mmChangePassword.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmChangePassword
}

// ExpectNewPasswordHashParam3 sets up expected param newPasswordHash for Repository.ChangePassword
func (mmChangePassword *mRepositoryMockChangePassword) ExpectNewPasswordHashParam3(newPasswordHash string) *mRepositoryMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &RepositoryMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &RepositoryMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.newPasswordHash = &newPasswordHash
	mmChangePassword.defaultExpectation.expectationOrigins.originNewPasswordHash = minimock.CallerInfo(1)

	return mmChangePassword
}

// Inspect accepts an inspector function that has same arguments as the Repository.ChangePassword
func (mmChangePassword *mRepositoryMockChangePassword) Inspect(f func(ctx context.Context, id uuid.UUID, newPasswordHash string)) *mRepositoryMockChangePassword {
	if mmChangePassword.mock.inspectFuncChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ChangePassword")
	}

	mmChangePassword.mock.inspectFuncChangePassword = f

	return mmChangePassword
}

// Return sets up results that will be returned by Repository.ChangePassword
func (mmChangePassword *mRepositoryMockChangePassword) Return(err error) *RepositoryMock {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &RepositoryMockChangePasswordExpectation{mock: mmChangePassword.mock}
	}
	mmChangePassword.defaultExpectation.results = &RepositoryMockChangePasswordResults{err}
	mmChangePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChangePassword.mock
}

// Set uses given function f to mock the Repository.ChangePassword method
func (mmChangePassword *mRepositoryMockChangePassword) Set(f func(ctx context.Context, id uuid.UUID, newPasswordHash string) (err error)) *RepositoryMock {
	if mmChangePassword.defaultExpectation != nil {
		mmChangePassword.mock.t.Fatalf("Default expectation is already set for the Repository.ChangePassword method")
	}

	if len(mmChangePassword.expectations) > 0 {
		mmChangePassword.mock.t.Fatalf("Some expectations are already set for the Repository.ChangePassword method")
	}

	mmChangePassword.mock.funcChangePassword = f
	mmChangePassword.mock.funcChangePasswordOrigin = minimock.CallerInfo(1)
	return mmChangePassword.mock
}

// When sets expectation for the Repository.ChangePassword which will trigger the result defined by the following
// Then helper
func (mmChangePassword *mRepositoryMockChangePassword) When(ctx context.Context, id uuid.UUID, newPasswordHash string) *RepositoryMockChangePasswordExpectation {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("RepositoryMock.ChangePassword mock is already set by Set")
	}

	expectation := &RepositoryMockChangePasswordExpectation{
		mock:               mmChangePassword.mock,
		params:             &RepositoryMockChangePasswordParams{ctx, id, newPasswordHash},
		expectationOrigins: RepositoryMockChangePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChangePassword.expectations = append(mmChangePassword.expectations, expectation)
	return expectation
}

// Then sets up Repository.ChangePassword return parameters for the expectation previously defined by the When method
func (e *RepositoryMockChangePasswordExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockChangePasswordResults{err}
	return e.mock
}

// Times sets number of times Repository.ChangePassword should be invoked
func (mmChangePassword *mRepositoryMockChangePassword) Times(n uint64) *mRepositoryMockChangePassword {
	if n == 0 {
		mmChangePassword.mock.t.Fatalf("Times of RepositoryMock.ChangePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangePassword.expectedInvocations, n)
	mmChangePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChangePassword
}

func (mmChangePassword *mRepositoryMockChangePassword) invocationsDone() bool {
	if len(mmChangePassword.expectations) == 0 && mmChangePassword.defaultExpectation == nil && mmChangePassword.mock.funcChangePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangePassword.mock.afterChangePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangePassword implements mm_user.Repository
func (mmChangePassword *RepositoryMock) ChangePassword(ctx context.Context, id uuid.UUID, newPasswordHash string) (err error) {
	mm_atomic.AddUint64(&mmChangePassword.beforeChangePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmChangePassword.afterChangePasswordCounter, 1)

	mmChangePassword.t.Helper()

	if mmChangePassword.inspectFuncChangePassword != nil {
		mmChangePassword.inspectFuncChangePassword(ctx, id, newPasswordHash)
	}

	mm_params := RepositoryMockChangePasswordParams{ctx, id, newPasswordHash}

	// Record call args
	mmChangePassword.ChangePasswordMock.mutex.Lock()
	mmChangePassword.ChangePasswordMock.callArgs = append(mmChangePassword.ChangePasswordMock.callArgs, &mm_params)
	mmChangePassword.ChangePasswordMock.mutex.Unlock()

	for _, e := range mmChangePassword.ChangePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangePassword.ChangePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangePassword.ChangePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmChangePassword.ChangePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmChangePassword.ChangePasswordMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockChangePasswordParams{ctx, id, newPasswordHash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangePassword.t.Errorf("RepositoryMock.ChangePassword got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmChangePassword.t.Errorf("RepositoryMock.ChangePassword got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newPasswordHash != nil && !minimock.Equal(*mm_want_ptrs.newPasswordHash, mm_got.newPasswordHash) {
				mmChangePassword.t.Errorf("RepositoryMock.ChangePassword got unexpected parameter newPasswordHash, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originNewPasswordHash, *mm_want_ptrs.newPasswordHash, mm_got.newPasswordHash, minimock.Diff(*mm_want_ptrs.newPasswordHash, mm_got.newPasswordHash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangePassword.t.Errorf("RepositoryMock.ChangePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangePassword.ChangePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmChangePassword.t.Fatal("No results are set for the RepositoryMock.ChangePassword")
		}
		return (*mm_results).err
	}
	if mmChangePassword.funcChangePassword != nil {
		return mmChangePassword.funcChangePassword(ctx, id, newPasswordHash)
	}
	mmChangePassword.t.Fatalf("Unexpected call to RepositoryMock.ChangePassword. %v %v %v", ctx, id, newPasswordHash)
	return
}

// ChangePasswordAfterCounter returns a count of finished RepositoryMock.ChangePassword invocations
func (mmChangePassword *RepositoryMock) ChangePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePassword.afterChangePasswordCounter)
}

// ChangePasswordBeforeCounter returns a count of RepositoryMock.ChangePassword invocations
func (mmChangePassword *RepositoryMock) ChangePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePassword.beforeChangePasswordCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ChangePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangePassword *mRepositoryMockChangePassword) Calls() []*RepositoryMockChangePasswordParams {
	mmChangePassword.mutex.RLock()

	argCopy := make([]*RepositoryMockChangePasswordParams, len(mmChangePassword.callArgs))
	copy(argCopy, mmChangePassword.callArgs)

	mmChangePassword.mutex.RUnlock()

	return argCopy
}

// MinimockChangePasswordDone returns true if the count of the ChangePassword invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockChangePasswordDone() bool {
	if m.ChangePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangePasswordMock.invocationsDone()
}

// MinimockChangePasswordInspect logs each unmet expectation
func (m *RepositoryMock) MinimockChangePasswordInspect() {
	for _, e := range m.ChangePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ChangePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChangePasswordCounter := mm_atomic.LoadUint64(&m.afterChangePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangePasswordMock.defaultExpectation != nil && afterChangePasswordCounter < 1 {
		if m.ChangePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ChangePassword at\n%s", m.ChangePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ChangePassword at\n%s with params: %#v", m.ChangePasswordMock.defaultExpectation.expectationOrigins.origin, *m.ChangePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangePassword != nil && afterChangePasswordCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ChangePassword at\n%s", m.funcChangePasswordOrigin)
	}

	if !m.ChangePasswordMock.invocationsDone() && afterChangePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ChangePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChangePasswordMock.expectedInvocations), m.ChangePasswordMock.expectedInvocationsOrigin, afterChangePasswordCounter)
	}
}

type mRepositoryMockCreateUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateUserParams
	paramPtrs          *RepositoryMockCreateUserParamPtrs
	expectationOrigins RepositoryMockCreateUserExpectationOrigins
	results            *RepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx          context.Context
	req          mm_user.CreateUserReq
	id           uuid.UUID
	passwordHash string
}

// RepositoryMockCreateUserParamPtrs contains pointers to parameters of the Repository.CreateUser
type RepositoryMockCreateUserParamPtrs struct {
	ctx          *context.Context
	req          *mm_user.CreateUserReq
	id           *uuid.UUID
	passwordHash *string
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	err error
}

// RepositoryMockCreateUserOrigins contains origins of expectations of the Repository.CreateUser
type RepositoryMockCreateUserExpectationOrigins struct {
	origin             string
	originCtx          string
	originReq          string
	originId           string
	originPasswordHash string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mRepositoryMockCreateUser) Optional() *mRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx, req, id, passwordHash}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &RepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectReqParam2 sets up expected param req for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) ExpectReqParam2(req mm_user.CreateUserReq) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &RepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.req = &req
	mmCreateUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectIdParam3 sets up expected param id for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) ExpectIdParam3(id uuid.UUID) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &RepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.id = &id
	mmCreateUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectPasswordHashParam4 sets up expected param passwordHash for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) ExpectPasswordHashParam4(passwordHash string) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &RepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.passwordHash = &passwordHash
	mmCreateUser.defaultExpectation.expectationOrigins.originPasswordHash = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string) (err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &RepositoryMockCreateUserParams{ctx, req, id, passwordHash},
		expectationOrigins: RepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateUser should be invoked
func (mmCreateUser *mRepositoryMockCreateUser) Times(n uint64) *mRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of RepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_user.Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context, req mm_user.CreateUserReq, id uuid.UUID, passwordHash string) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, req, id, passwordHash)
	}

	mm_params := RepositoryMockCreateUserParams{ctx, req, id, passwordHash}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateUserParams{ctx, req, id, passwordHash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.passwordHash != nil && !minimock.Equal(*mm_want_ptrs.passwordHash, mm_got.passwordHash) {
				mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameter passwordHash, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originPasswordHash, *mm_want_ptrs.passwordHash, mm_got.passwordHash, minimock.Diff(*mm_want_ptrs.passwordHash, mm_got.passwordHash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, req, id, passwordHash)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v %v %v %v", ctx, req, id, passwordHash)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mRepositoryMockDeleteUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteUserExpectation
	expectations       []*RepositoryMockDeleteUserExpectation

	callArgs []*RepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteUserExpectation specifies expectation struct of the Repository.DeleteUser
type RepositoryMockDeleteUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteUserParams
	paramPtrs          *RepositoryMockDeleteUserParamPtrs
	expectationOrigins RepositoryMockDeleteUserExpectationOrigins
	results            *RepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteUserParams contains parameters of the Repository.DeleteUser
type RepositoryMockDeleteUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockDeleteUserParamPtrs contains pointers to parameters of the Repository.DeleteUser
type RepositoryMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockDeleteUserResults contains results of the Repository.DeleteUser
type RepositoryMockDeleteUserResults struct {
	err error
}

// RepositoryMockDeleteUserOrigins contains origins of expectations of the Repository.DeleteUser
type RepositoryMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mRepositoryMockDeleteUser) Optional() *mRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &RepositoryMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) ExpectIdParam2(id uuid.UUID) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Return(err error) *RepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &RepositoryMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the Repository.DeleteUser method
func (mmDeleteUser *mRepositoryMockDeleteUser) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *RepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the Repository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mRepositoryMockDeleteUser) When(ctx context.Context, id uuid.UUID) *RepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &RepositoryMockDeleteUserParams{ctx, id},
		expectationOrigins: RepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteUser should be invoked
func (mmDeleteUser *mRepositoryMockDeleteUser) Times(n uint64) *mRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of RepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_user.Repository
func (mmDeleteUser *RepositoryMock) DeleteUser(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := RepositoryMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the RepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to RepositoryMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mRepositoryMockDeleteUser) Calls() []*RepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mRepositoryMockGetAllUsers struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllUsersExpectation
	expectations       []*RepositoryMockGetAllUsersExpectation

	callArgs []*RepositoryMockGetAllUsersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetAllUsersExpectation specifies expectation struct of the Repository.GetAllUsers
type RepositoryMockGetAllUsersExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetAllUsersParams
	paramPtrs          *RepositoryMockGetAllUsersParamPtrs
	expectationOrigins RepositoryMockGetAllUsersExpectationOrigins
	results            *RepositoryMockGetAllUsersResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetAllUsersParams contains parameters of the Repository.GetAllUsers
type RepositoryMockGetAllUsersParams struct {
	ctx context.Context
}

// RepositoryMockGetAllUsersParamPtrs contains pointers to parameters of the Repository.GetAllUsers
type RepositoryMockGetAllUsersParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockGetAllUsersResults contains results of the Repository.GetAllUsers
type RepositoryMockGetAllUsersResults struct {
	ua1 []mm_user.User
	err error
}

// RepositoryMockGetAllUsersOrigins contains origins of expectations of the Repository.GetAllUsers
type RepositoryMockGetAllUsersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Optional() *mRepositoryMockGetAllUsers {
	mmGetAllUsers.optional = true
	return mmGetAllUsers
}

// Expect sets up expected params for Repository.GetAllUsers
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Expect(ctx context.Context) *mRepositoryMockGetAllUsers {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("RepositoryMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &RepositoryMockGetAllUsersExpectation{}
	}

	if mmGetAllUsers.defaultExpectation.paramPtrs != nil {
		mmGetAllUsers.mock.t.Fatalf("RepositoryMock.GetAllUsers mock is already set by ExpectParams functions")
	}

	mmGetAllUsers.defaultExpectation.params = &RepositoryMockGetAllUsersParams{ctx}
	mmGetAllUsers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllUsers.expectations {
		if minimock.Equal(e.params, mmGetAllUsers.defaultExpectation.params) {
			mmGetAllUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllUsers.defaultExpectation.params)
		}
	}

	return mmGetAllUsers
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetAllUsers
func (mmGetAllUsers *mRepositoryMockGetAllUsers) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetAllUsers {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("RepositoryMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &RepositoryMockGetAllUsersExpectation{}
	}

	if mmGetAllUsers.defaultExpectation.params != nil {
		mmGetAllUsers.mock.t.Fatalf("RepositoryMock.GetAllUsers mock is already set by Expect")
	}

	if mmGetAllUsers.defaultExpectation.paramPtrs == nil {
		mmGetAllUsers.defaultExpectation.paramPtrs = &RepositoryMockGetAllUsersParamPtrs{}
	}
	mmGetAllUsers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllUsers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllUsers
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAllUsers
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Inspect(f func(ctx context.Context)) *mRepositoryMockGetAllUsers {
	if mmGetAllUsers.mock.inspectFuncGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAllUsers")
	}

	mmGetAllUsers.mock.inspectFuncGetAllUsers = f

	return mmGetAllUsers
}

// Return sets up results that will be returned by Repository.GetAllUsers
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Return(ua1 []mm_user.User, err error) *RepositoryMock {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("RepositoryMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &RepositoryMockGetAllUsersExpectation{mock: mmGetAllUsers.mock}
	}
	mmGetAllUsers.defaultExpectation.results = &RepositoryMockGetAllUsersResults{ua1, err}
	mmGetAllUsers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers.mock
}

// Set uses given function f to mock the Repository.GetAllUsers method
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Set(f func(ctx context.Context) (ua1 []mm_user.User, err error)) *RepositoryMock {
	if mmGetAllUsers.defaultExpectation != nil {
		mmGetAllUsers.mock.t.Fatalf("Default expectation is already set for the Repository.GetAllUsers method")
	}

	if len(mmGetAllUsers.expectations) > 0 {
		mmGetAllUsers.mock.t.Fatalf("Some expectations are already set for the Repository.GetAllUsers method")
	}

	mmGetAllUsers.mock.funcGetAllUsers = f
	mmGetAllUsers.mock.funcGetAllUsersOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers.mock
}

// When sets expectation for the Repository.GetAllUsers which will trigger the result defined by the following
// Then helper
func (mmGetAllUsers *mRepositoryMockGetAllUsers) When(ctx context.Context) *RepositoryMockGetAllUsersExpectation {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("RepositoryMock.GetAllUsers mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllUsersExpectation{
		mock:               mmGetAllUsers.mock,
		params:             &RepositoryMockGetAllUsersParams{ctx},
		expectationOrigins: RepositoryMockGetAllUsersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllUsers.expectations = append(mmGetAllUsers.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAllUsers return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllUsersExpectation) Then(ua1 []mm_user.User, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllUsersResults{ua1, err}
	return e.mock
}

// Times sets number of times Repository.GetAllUsers should be invoked
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Times(n uint64) *mRepositoryMockGetAllUsers {
	if n == 0 {
		mmGetAllUsers.mock.t.Fatalf("Times of RepositoryMock.GetAllUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllUsers.expectedInvocations, n)
	mmGetAllUsers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers
}

func (mmGetAllUsers *mRepositoryMockGetAllUsers) invocationsDone() bool {
	if len(mmGetAllUsers.expectations) == 0 && mmGetAllUsers.defaultExpectation == nil && mmGetAllUsers.mock.funcGetAllUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllUsers.mock.afterGetAllUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllUsers implements mm_user.Repository
func (mmGetAllUsers *RepositoryMock) GetAllUsers(ctx context.Context) (ua1 []mm_user.User, err error) {
	mm_atomic.AddUint64(&mmGetAllUsers.beforeGetAllUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllUsers.afterGetAllUsersCounter, 1)

	mmGetAllUsers.t.Helper()

	if mmGetAllUsers.inspectFuncGetAllUsers != nil {
		mmGetAllUsers.inspectFuncGetAllUsers(ctx)
	}

	mm_params := RepositoryMockGetAllUsersParams{ctx}

	// Record call args
	mmGetAllUsers.GetAllUsersMock.mutex.Lock()
	mmGetAllUsers.GetAllUsersMock.callArgs = append(mmGetAllUsers.GetAllUsersMock.callArgs, &mm_params)
	mmGetAllUsers.GetAllUsersMock.mutex.Unlock()

	for _, e := range mmGetAllUsers.GetAllUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetAllUsers.GetAllUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllUsers.GetAllUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllUsers.GetAllUsersMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllUsers.GetAllUsersMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetAllUsersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllUsers.t.Errorf("RepositoryMock.GetAllUsers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllUsers.GetAllUsersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllUsers.t.Errorf("RepositoryMock.GetAllUsers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllUsers.GetAllUsersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllUsers.GetAllUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllUsers.t.Fatal("No results are set for the RepositoryMock.GetAllUsers")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetAllUsers.funcGetAllUsers != nil {
		return mmGetAllUsers.funcGetAllUsers(ctx)
	}
	mmGetAllUsers.t.Fatalf("Unexpected call to RepositoryMock.GetAllUsers. %v", ctx)
	return
}

// GetAllUsersAfterCounter returns a count of finished RepositoryMock.GetAllUsers invocations
func (mmGetAllUsers *RepositoryMock) GetAllUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUsers.afterGetAllUsersCounter)
}

// GetAllUsersBeforeCounter returns a count of RepositoryMock.GetAllUsers invocations
func (mmGetAllUsers *RepositoryMock) GetAllUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUsers.beforeGetAllUsersCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAllUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllUsers *mRepositoryMockGetAllUsers) Calls() []*RepositoryMockGetAllUsersParams {
	mmGetAllUsers.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllUsersParams, len(mmGetAllUsers.callArgs))
	copy(argCopy, mmGetAllUsers.callArgs)

	mmGetAllUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllUsersDone returns true if the count of the GetAllUsers invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllUsersDone() bool {
	if m.GetAllUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllUsersMock.invocationsDone()
}

// MinimockGetAllUsersInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllUsersInspect() {
	for _, e := range m.GetAllUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAllUsers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllUsersCounter := mm_atomic.LoadUint64(&m.afterGetAllUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllUsersMock.defaultExpectation != nil && afterGetAllUsersCounter < 1 {
		if m.GetAllUsersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetAllUsers at\n%s", m.GetAllUsersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAllUsers at\n%s with params: %#v", m.GetAllUsersMock.defaultExpectation.expectationOrigins.origin, *m.GetAllUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllUsers != nil && afterGetAllUsersCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetAllUsers at\n%s", m.funcGetAllUsersOrigin)
	}

	if !m.GetAllUsersMock.invocationsDone() && afterGetAllUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetAllUsers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllUsersMock.expectedInvocations), m.GetAllUsersMock.expectedInvocationsOrigin, afterGetAllUsersCounter)
	}
}

type mRepositoryMockGetUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserExpectation
	expectations       []*RepositoryMockGetUserExpectation

	callArgs []*RepositoryMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetUserExpectation specifies expectation struct of the Repository.GetUser
type RepositoryMockGetUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetUserParams
	paramPtrs          *RepositoryMockGetUserParamPtrs
	expectationOrigins RepositoryMockGetUserExpectationOrigins
	results            *RepositoryMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetUserParams contains parameters of the Repository.GetUser
type RepositoryMockGetUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockGetUserParamPtrs contains pointers to parameters of the Repository.GetUser
type RepositoryMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockGetUserResults contains results of the Repository.GetUser
type RepositoryMockGetUserResults struct {
	u1  mm_user.User
	s1  string
	err error
}

// RepositoryMockGetUserOrigins contains origins of expectations of the Repository.GetUser
type RepositoryMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mRepositoryMockGetUser) Optional() *mRepositoryMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &RepositoryMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &RepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) ExpectIdParam2(id uuid.UUID) *mRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &RepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Return(u1 mm_user.User, s1 string, err error) *RepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &RepositoryMockGetUserResults{u1, s1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the Repository.GetUser method
func (mmGetUser *mRepositoryMockGetUser) Set(f func(ctx context.Context, id uuid.UUID) (u1 mm_user.User, s1 string, err error)) *RepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Repository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Repository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the Repository.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mRepositoryMockGetUser) When(ctx context.Context, id uuid.UUID) *RepositoryMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &RepositoryMockGetUserParams{ctx, id},
		expectationOrigins: RepositoryMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserExpectation) Then(u1 mm_user.User, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserResults{u1, s1, err}
	return e.mock
}

// Times sets number of times Repository.GetUser should be invoked
func (mmGetUser *mRepositoryMockGetUser) Times(n uint64) *mRepositoryMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of RepositoryMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mRepositoryMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_user.Repository
func (mmGetUser *RepositoryMock) GetUser(ctx context.Context, id uuid.UUID) (u1 mm_user.User, s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := RepositoryMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.s1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("RepositoryMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("RepositoryMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("RepositoryMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the RepositoryMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).s1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to RepositoryMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mRepositoryMockGetUser) Calls() []*RepositoryMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mRepositoryMockGetUserByEmail struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserByEmailExpectation
	expectations       []*RepositoryMockGetUserByEmailExpectation

	callArgs []*RepositoryMockGetUserByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetUserByEmailExpectation specifies expectation struct of the Repository.GetUserByEmail
type RepositoryMockGetUserByEmailExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetUserByEmailParams
	paramPtrs          *RepositoryMockGetUserByEmailParamPtrs
	expectationOrigins RepositoryMockGetUserByEmailExpectationOrigins
	results            *RepositoryMockGetUserByEmailResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetUserByEmailParams contains parameters of the Repository.GetUserByEmail
type RepositoryMockGetUserByEmailParams struct {
	ctx   context.Context
	email string
}

// RepositoryMockGetUserByEmailParamPtrs contains pointers to parameters of the Repository.GetUserByEmail
type RepositoryMockGetUserByEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// RepositoryMockGetUserByEmailResults contains results of the Repository.GetUserByEmail
type RepositoryMockGetUserByEmailResults struct {
	u1  mm_user.User
	s1  string
	err error
}

// RepositoryMockGetUserByEmailOrigins contains origins of expectations of the Repository.GetUserByEmail
type RepositoryMockGetUserByEmailExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Optional() *mRepositoryMockGetUserByEmail {
	mmGetUserByEmail.optional = true
	return mmGetUserByEmail
}

// Expect sets up expected params for Repository.GetUserByEmail
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Expect(ctx context.Context, email string) *mRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &RepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by ExpectParams functions")
	}

	mmGetUserByEmail.defaultExpectation.params = &RepositoryMockGetUserByEmailParams{ctx, email}
	mmGetUserByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByEmail.expectations {
		if minimock.Equal(e.params, mmGetUserByEmail.defaultExpectation.params) {
			mmGetUserByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByEmail.defaultExpectation.params)
		}
	}

	return mmGetUserByEmail
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetUserByEmail
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &RepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &RepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// ExpectEmailParam2 sets up expected param email for Repository.GetUserByEmail
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) ExpectEmailParam2(email string) *mRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &RepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &RepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.email = &email
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserByEmail
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Inspect(f func(ctx context.Context, email string)) *mRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserByEmail")
	}

	mmGetUserByEmail.mock.inspectFuncGetUserByEmail = f

	return mmGetUserByEmail
}

// Return sets up results that will be returned by Repository.GetUserByEmail
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Return(u1 mm_user.User, s1 string, err error) *RepositoryMock {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &RepositoryMockGetUserByEmailExpectation{mock: mmGetUserByEmail.mock}
	}
	mmGetUserByEmail.defaultExpectation.results = &RepositoryMockGetUserByEmailResults{u1, s1, err}
	mmGetUserByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// Set uses given function f to mock the Repository.GetUserByEmail method
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Set(f func(ctx context.Context, email string) (u1 mm_user.User, s1 string, err error)) *RepositoryMock {
	if mmGetUserByEmail.defaultExpectation != nil {
		mmGetUserByEmail.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserByEmail method")
	}

	if len(mmGetUserByEmail.expectations) > 0 {
		mmGetUserByEmail.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserByEmail method")
	}

	mmGetUserByEmail.mock.funcGetUserByEmail = f
	mmGetUserByEmail.mock.funcGetUserByEmailOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// When sets expectation for the Repository.GetUserByEmail which will trigger the result defined by the following
// Then helper
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) When(ctx context.Context, email string) *RepositoryMockGetUserByEmailExpectation {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("RepositoryMock.GetUserByEmail mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserByEmailExpectation{
		mock:               mmGetUserByEmail.mock,
		params:             &RepositoryMockGetUserByEmailParams{ctx, email},
		expectationOrigins: RepositoryMockGetUserByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByEmail.expectations = append(mmGetUserByEmail.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserByEmail return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserByEmailExpectation) Then(u1 mm_user.User, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserByEmailResults{u1, s1, err}
	return e.mock
}

// Times sets number of times Repository.GetUserByEmail should be invoked
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Times(n uint64) *mRepositoryMockGetUserByEmail {
	if n == 0 {
		mmGetUserByEmail.mock.t.Fatalf("Times of RepositoryMock.GetUserByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByEmail.expectedInvocations, n)
	mmGetUserByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail
}

func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) invocationsDone() bool {
	if len(mmGetUserByEmail.expectations) == 0 && mmGetUserByEmail.defaultExpectation == nil && mmGetUserByEmail.mock.funcGetUserByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.mock.afterGetUserByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByEmail implements mm_user.Repository
func (mmGetUserByEmail *RepositoryMock) GetUserByEmail(ctx context.Context, email string) (u1 mm_user.User, s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByEmail.afterGetUserByEmailCounter, 1)

	mmGetUserByEmail.t.Helper()

	if mmGetUserByEmail.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.inspectFuncGetUserByEmail(ctx, email)
	}

	mm_params := RepositoryMockGetUserByEmailParams{ctx, email}

	// Record call args
	mmGetUserByEmail.GetUserByEmailMock.mutex.Lock()
	mmGetUserByEmail.GetUserByEmailMock.callArgs = append(mmGetUserByEmail.GetUserByEmailMock.callArgs, &mm_params)
	mmGetUserByEmail.GetUserByEmailMock.mutex.Unlock()

	for _, e := range mmGetUserByEmail.GetUserByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.s1, e.results.err
		}
	}

	if mmGetUserByEmail.GetUserByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetUserByEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByEmail.t.Errorf("RepositoryMock.GetUserByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetUserByEmail.t.Errorf("RepositoryMock.GetUserByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByEmail.t.Errorf("RepositoryMock.GetUserByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByEmail.t.Fatal("No results are set for the RepositoryMock.GetUserByEmail")
		}
		return (*mm_results).u1, (*mm_results).s1, (*mm_results).err
	}
	if mmGetUserByEmail.funcGetUserByEmail != nil {
		return mmGetUserByEmail.funcGetUserByEmail(ctx, email)
	}
	mmGetUserByEmail.t.Fatalf("Unexpected call to RepositoryMock.GetUserByEmail. %v %v", ctx, email)
	return
}

// GetUserByEmailAfterCounter returns a count of finished RepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *RepositoryMock) GetUserByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.afterGetUserByEmailCounter)
}

// GetUserByEmailBeforeCounter returns a count of RepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *RepositoryMock) GetUserByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByEmail *mRepositoryMockGetUserByEmail) Calls() []*RepositoryMockGetUserByEmailParams {
	mmGetUserByEmail.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserByEmailParams, len(mmGetUserByEmail.callArgs))
	copy(argCopy, mmGetUserByEmail.callArgs)

	mmGetUserByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByEmailDone returns true if the count of the GetUserByEmail invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserByEmailDone() bool {
	if m.GetUserByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByEmailMock.invocationsDone()
}

// MinimockGetUserByEmailInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserByEmailInspect() {
	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByEmailCounter := mm_atomic.LoadUint64(&m.afterGetUserByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByEmailMock.defaultExpectation != nil && afterGetUserByEmailCounter < 1 {
		if m.GetUserByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByEmail at\n%s", m.GetUserByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByEmail at\n%s with params: %#v", m.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByEmail != nil && afterGetUserByEmailCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetUserByEmail at\n%s", m.funcGetUserByEmailOrigin)
	}

	if !m.GetUserByEmailMock.invocationsDone() && afterGetUserByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetUserByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByEmailMock.expectedInvocations), m.GetUserByEmailMock.expectedInvocationsOrigin, afterGetUserByEmailCounter)
	}
}

type mRepositoryMockUpdateUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateUserExpectation
	expectations       []*RepositoryMockUpdateUserExpectation

	callArgs []*RepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateUserExpectation specifies expectation struct of the Repository.UpdateUser
type RepositoryMockUpdateUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateUserParams
	paramPtrs          *RepositoryMockUpdateUserParamPtrs
	expectationOrigins RepositoryMockUpdateUserExpectationOrigins
	results            *RepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateUserParams contains parameters of the Repository.UpdateUser
type RepositoryMockUpdateUserParams struct {
	ctx context.Context
	req mm_user.UpdateUserReq
}

// RepositoryMockUpdateUserParamPtrs contains pointers to parameters of the Repository.UpdateUser
type RepositoryMockUpdateUserParamPtrs struct {
	ctx *context.Context
	req *mm_user.UpdateUserReq
}

// RepositoryMockUpdateUserResults contains results of the Repository.UpdateUser
type RepositoryMockUpdateUserResults struct {
	err error
}

// RepositoryMockUpdateUserOrigins contains origins of expectations of the Repository.UpdateUser
type RepositoryMockUpdateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mRepositoryMockUpdateUser) Optional() *mRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Expect(ctx context.Context, req mm_user.UpdateUserReq) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &RepositoryMockUpdateUserParams{ctx, req}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectReqParam2 sets up expected param req for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) ExpectReqParam2(req mm_user.UpdateUserReq) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &RepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.req = &req
	mmUpdateUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, req mm_user.UpdateUserReq)) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Return(err error) *RepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &RepositoryMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the Repository.UpdateUser method
func (mmUpdateUser *mRepositoryMockUpdateUser) Set(f func(ctx context.Context, req mm_user.UpdateUserReq) (err error)) *RepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the Repository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mRepositoryMockUpdateUser) When(ctx context.Context, req mm_user.UpdateUserReq) *RepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &RepositoryMockUpdateUserParams{ctx, req},
		expectationOrigins: RepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateUser should be invoked
func (mmUpdateUser *mRepositoryMockUpdateUser) Times(n uint64) *mRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of RepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_user.Repository
func (mmUpdateUser *RepositoryMock) UpdateUser(ctx context.Context, req mm_user.UpdateUserReq) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, req)
	}

	mm_params := RepositoryMockUpdateUserParams{ctx, req}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateUserParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the RepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, req)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to RepositoryMock.UpdateUser. %v %v", ctx, req)
	return
}

// UpdateUserAfterCounter returns a count of finished RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mRepositoryMockUpdateUser) Calls() []*RepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangePasswordInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetAllUsersInspect()

			m.MinimockGetUserInspect()

			m.MinimockGetUserByEmailInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangePasswordDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetAllUsersDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockGetUserByEmailDone() &&
		m.MinimockUpdateUserDone()
}
