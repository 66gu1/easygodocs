// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/user.Validator -o validator_mock.go -n ValidatorMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ValidatorMock implements mm_user.Validator
type ValidatorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcNormalizeEmail          func(address string) (s1 string)
	funcNormalizeEmailOrigin    string
	inspectFuncNormalizeEmail   func(address string)
	afterNormalizeEmailCounter  uint64
	beforeNormalizeEmailCounter uint64
	NormalizeEmailMock          mValidatorMockNormalizeEmail

	funcNormalizeName          func(name string) (s1 string)
	funcNormalizeNameOrigin    string
	inspectFuncNormalizeName   func(name string)
	afterNormalizeNameCounter  uint64
	beforeNormalizeNameCounter uint64
	NormalizeNameMock          mValidatorMockNormalizeName

	funcValidateEmail          func(address string, validateLength bool) (err error)
	funcValidateEmailOrigin    string
	inspectFuncValidateEmail   func(address string, validateLength bool)
	afterValidateEmailCounter  uint64
	beforeValidateEmailCounter uint64
	ValidateEmailMock          mValidatorMockValidateEmail

	funcValidateName          func(name string) (err error)
	funcValidateNameOrigin    string
	inspectFuncValidateName   func(name string)
	afterValidateNameCounter  uint64
	beforeValidateNameCounter uint64
	ValidateNameMock          mValidatorMockValidateName

	funcValidatePassword          func(password []byte) (err error)
	funcValidatePasswordOrigin    string
	inspectFuncValidatePassword   func(password []byte)
	afterValidatePasswordCounter  uint64
	beforeValidatePasswordCounter uint64
	ValidatePasswordMock          mValidatorMockValidatePassword
}

// NewValidatorMock returns a mock for mm_user.Validator
func NewValidatorMock(t minimock.Tester) *ValidatorMock {
	m := &ValidatorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.NormalizeEmailMock = mValidatorMockNormalizeEmail{mock: m}
	m.NormalizeEmailMock.callArgs = []*ValidatorMockNormalizeEmailParams{}

	m.NormalizeNameMock = mValidatorMockNormalizeName{mock: m}
	m.NormalizeNameMock.callArgs = []*ValidatorMockNormalizeNameParams{}

	m.ValidateEmailMock = mValidatorMockValidateEmail{mock: m}
	m.ValidateEmailMock.callArgs = []*ValidatorMockValidateEmailParams{}

	m.ValidateNameMock = mValidatorMockValidateName{mock: m}
	m.ValidateNameMock.callArgs = []*ValidatorMockValidateNameParams{}

	m.ValidatePasswordMock = mValidatorMockValidatePassword{mock: m}
	m.ValidatePasswordMock.callArgs = []*ValidatorMockValidatePasswordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mValidatorMockNormalizeEmail struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockNormalizeEmailExpectation
	expectations       []*ValidatorMockNormalizeEmailExpectation

	callArgs []*ValidatorMockNormalizeEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockNormalizeEmailExpectation specifies expectation struct of the Validator.NormalizeEmail
type ValidatorMockNormalizeEmailExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockNormalizeEmailParams
	paramPtrs          *ValidatorMockNormalizeEmailParamPtrs
	expectationOrigins ValidatorMockNormalizeEmailExpectationOrigins
	results            *ValidatorMockNormalizeEmailResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockNormalizeEmailParams contains parameters of the Validator.NormalizeEmail
type ValidatorMockNormalizeEmailParams struct {
	address string
}

// ValidatorMockNormalizeEmailParamPtrs contains pointers to parameters of the Validator.NormalizeEmail
type ValidatorMockNormalizeEmailParamPtrs struct {
	address *string
}

// ValidatorMockNormalizeEmailResults contains results of the Validator.NormalizeEmail
type ValidatorMockNormalizeEmailResults struct {
	s1 string
}

// ValidatorMockNormalizeEmailOrigins contains origins of expectations of the Validator.NormalizeEmail
type ValidatorMockNormalizeEmailExpectationOrigins struct {
	origin        string
	originAddress string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Optional() *mValidatorMockNormalizeEmail {
	mmNormalizeEmail.optional = true
	return mmNormalizeEmail
}

// Expect sets up expected params for Validator.NormalizeEmail
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Expect(address string) *mValidatorMockNormalizeEmail {
	if mmNormalizeEmail.mock.funcNormalizeEmail != nil {
		mmNormalizeEmail.mock.t.Fatalf("ValidatorMock.NormalizeEmail mock is already set by Set")
	}

	if mmNormalizeEmail.defaultExpectation == nil {
		mmNormalizeEmail.defaultExpectation = &ValidatorMockNormalizeEmailExpectation{}
	}

	if mmNormalizeEmail.defaultExpectation.paramPtrs != nil {
		mmNormalizeEmail.mock.t.Fatalf("ValidatorMock.NormalizeEmail mock is already set by ExpectParams functions")
	}

	mmNormalizeEmail.defaultExpectation.params = &ValidatorMockNormalizeEmailParams{address}
	mmNormalizeEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNormalizeEmail.expectations {
		if minimock.Equal(e.params, mmNormalizeEmail.defaultExpectation.params) {
			mmNormalizeEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNormalizeEmail.defaultExpectation.params)
		}
	}

	return mmNormalizeEmail
}

// ExpectAddressParam1 sets up expected param address for Validator.NormalizeEmail
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) ExpectAddressParam1(address string) *mValidatorMockNormalizeEmail {
	if mmNormalizeEmail.mock.funcNormalizeEmail != nil {
		mmNormalizeEmail.mock.t.Fatalf("ValidatorMock.NormalizeEmail mock is already set by Set")
	}

	if mmNormalizeEmail.defaultExpectation == nil {
		mmNormalizeEmail.defaultExpectation = &ValidatorMockNormalizeEmailExpectation{}
	}

	if mmNormalizeEmail.defaultExpectation.params != nil {
		mmNormalizeEmail.mock.t.Fatalf("ValidatorMock.NormalizeEmail mock is already set by Expect")
	}

	if mmNormalizeEmail.defaultExpectation.paramPtrs == nil {
		mmNormalizeEmail.defaultExpectation.paramPtrs = &ValidatorMockNormalizeEmailParamPtrs{}
	}
	mmNormalizeEmail.defaultExpectation.paramPtrs.address = &address
	mmNormalizeEmail.defaultExpectation.expectationOrigins.originAddress = minimock.CallerInfo(1)

	return mmNormalizeEmail
}

// Inspect accepts an inspector function that has same arguments as the Validator.NormalizeEmail
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Inspect(f func(address string)) *mValidatorMockNormalizeEmail {
	if mmNormalizeEmail.mock.inspectFuncNormalizeEmail != nil {
		mmNormalizeEmail.mock.t.Fatalf("Inspect function is already set for ValidatorMock.NormalizeEmail")
	}

	mmNormalizeEmail.mock.inspectFuncNormalizeEmail = f

	return mmNormalizeEmail
}

// Return sets up results that will be returned by Validator.NormalizeEmail
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Return(s1 string) *ValidatorMock {
	if mmNormalizeEmail.mock.funcNormalizeEmail != nil {
		mmNormalizeEmail.mock.t.Fatalf("ValidatorMock.NormalizeEmail mock is already set by Set")
	}

	if mmNormalizeEmail.defaultExpectation == nil {
		mmNormalizeEmail.defaultExpectation = &ValidatorMockNormalizeEmailExpectation{mock: mmNormalizeEmail.mock}
	}
	mmNormalizeEmail.defaultExpectation.results = &ValidatorMockNormalizeEmailResults{s1}
	mmNormalizeEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNormalizeEmail.mock
}

// Set uses given function f to mock the Validator.NormalizeEmail method
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Set(f func(address string) (s1 string)) *ValidatorMock {
	if mmNormalizeEmail.defaultExpectation != nil {
		mmNormalizeEmail.mock.t.Fatalf("Default expectation is already set for the Validator.NormalizeEmail method")
	}

	if len(mmNormalizeEmail.expectations) > 0 {
		mmNormalizeEmail.mock.t.Fatalf("Some expectations are already set for the Validator.NormalizeEmail method")
	}

	mmNormalizeEmail.mock.funcNormalizeEmail = f
	mmNormalizeEmail.mock.funcNormalizeEmailOrigin = minimock.CallerInfo(1)
	return mmNormalizeEmail.mock
}

// When sets expectation for the Validator.NormalizeEmail which will trigger the result defined by the following
// Then helper
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) When(address string) *ValidatorMockNormalizeEmailExpectation {
	if mmNormalizeEmail.mock.funcNormalizeEmail != nil {
		mmNormalizeEmail.mock.t.Fatalf("ValidatorMock.NormalizeEmail mock is already set by Set")
	}

	expectation := &ValidatorMockNormalizeEmailExpectation{
		mock:               mmNormalizeEmail.mock,
		params:             &ValidatorMockNormalizeEmailParams{address},
		expectationOrigins: ValidatorMockNormalizeEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNormalizeEmail.expectations = append(mmNormalizeEmail.expectations, expectation)
	return expectation
}

// Then sets up Validator.NormalizeEmail return parameters for the expectation previously defined by the When method
func (e *ValidatorMockNormalizeEmailExpectation) Then(s1 string) *ValidatorMock {
	e.results = &ValidatorMockNormalizeEmailResults{s1}
	return e.mock
}

// Times sets number of times Validator.NormalizeEmail should be invoked
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Times(n uint64) *mValidatorMockNormalizeEmail {
	if n == 0 {
		mmNormalizeEmail.mock.t.Fatalf("Times of ValidatorMock.NormalizeEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNormalizeEmail.expectedInvocations, n)
	mmNormalizeEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNormalizeEmail
}

func (mmNormalizeEmail *mValidatorMockNormalizeEmail) invocationsDone() bool {
	if len(mmNormalizeEmail.expectations) == 0 && mmNormalizeEmail.defaultExpectation == nil && mmNormalizeEmail.mock.funcNormalizeEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNormalizeEmail.mock.afterNormalizeEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNormalizeEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NormalizeEmail implements mm_user.Validator
func (mmNormalizeEmail *ValidatorMock) NormalizeEmail(address string) (s1 string) {
	mm_atomic.AddUint64(&mmNormalizeEmail.beforeNormalizeEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmNormalizeEmail.afterNormalizeEmailCounter, 1)

	mmNormalizeEmail.t.Helper()

	if mmNormalizeEmail.inspectFuncNormalizeEmail != nil {
		mmNormalizeEmail.inspectFuncNormalizeEmail(address)
	}

	mm_params := ValidatorMockNormalizeEmailParams{address}

	// Record call args
	mmNormalizeEmail.NormalizeEmailMock.mutex.Lock()
	mmNormalizeEmail.NormalizeEmailMock.callArgs = append(mmNormalizeEmail.NormalizeEmailMock.callArgs, &mm_params)
	mmNormalizeEmail.NormalizeEmailMock.mutex.Unlock()

	for _, e := range mmNormalizeEmail.NormalizeEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmNormalizeEmail.NormalizeEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNormalizeEmail.NormalizeEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmNormalizeEmail.NormalizeEmailMock.defaultExpectation.params
		mm_want_ptrs := mmNormalizeEmail.NormalizeEmailMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockNormalizeEmailParams{address}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.address != nil && !minimock.Equal(*mm_want_ptrs.address, mm_got.address) {
				mmNormalizeEmail.t.Errorf("ValidatorMock.NormalizeEmail got unexpected parameter address, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNormalizeEmail.NormalizeEmailMock.defaultExpectation.expectationOrigins.originAddress, *mm_want_ptrs.address, mm_got.address, minimock.Diff(*mm_want_ptrs.address, mm_got.address))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNormalizeEmail.t.Errorf("ValidatorMock.NormalizeEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNormalizeEmail.NormalizeEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNormalizeEmail.NormalizeEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmNormalizeEmail.t.Fatal("No results are set for the ValidatorMock.NormalizeEmail")
		}
		return (*mm_results).s1
	}
	if mmNormalizeEmail.funcNormalizeEmail != nil {
		return mmNormalizeEmail.funcNormalizeEmail(address)
	}
	mmNormalizeEmail.t.Fatalf("Unexpected call to ValidatorMock.NormalizeEmail. %v", address)
	return
}

// NormalizeEmailAfterCounter returns a count of finished ValidatorMock.NormalizeEmail invocations
func (mmNormalizeEmail *ValidatorMock) NormalizeEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNormalizeEmail.afterNormalizeEmailCounter)
}

// NormalizeEmailBeforeCounter returns a count of ValidatorMock.NormalizeEmail invocations
func (mmNormalizeEmail *ValidatorMock) NormalizeEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNormalizeEmail.beforeNormalizeEmailCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.NormalizeEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNormalizeEmail *mValidatorMockNormalizeEmail) Calls() []*ValidatorMockNormalizeEmailParams {
	mmNormalizeEmail.mutex.RLock()

	argCopy := make([]*ValidatorMockNormalizeEmailParams, len(mmNormalizeEmail.callArgs))
	copy(argCopy, mmNormalizeEmail.callArgs)

	mmNormalizeEmail.mutex.RUnlock()

	return argCopy
}

// MinimockNormalizeEmailDone returns true if the count of the NormalizeEmail invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockNormalizeEmailDone() bool {
	if m.NormalizeEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NormalizeEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NormalizeEmailMock.invocationsDone()
}

// MinimockNormalizeEmailInspect logs each unmet expectation
func (m *ValidatorMock) MinimockNormalizeEmailInspect() {
	for _, e := range m.NormalizeEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNormalizeEmailCounter := mm_atomic.LoadUint64(&m.afterNormalizeEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NormalizeEmailMock.defaultExpectation != nil && afterNormalizeEmailCounter < 1 {
		if m.NormalizeEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeEmail at\n%s", m.NormalizeEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeEmail at\n%s with params: %#v", m.NormalizeEmailMock.defaultExpectation.expectationOrigins.origin, *m.NormalizeEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNormalizeEmail != nil && afterNormalizeEmailCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.NormalizeEmail at\n%s", m.funcNormalizeEmailOrigin)
	}

	if !m.NormalizeEmailMock.invocationsDone() && afterNormalizeEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.NormalizeEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NormalizeEmailMock.expectedInvocations), m.NormalizeEmailMock.expectedInvocationsOrigin, afterNormalizeEmailCounter)
	}
}

type mValidatorMockNormalizeName struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockNormalizeNameExpectation
	expectations       []*ValidatorMockNormalizeNameExpectation

	callArgs []*ValidatorMockNormalizeNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockNormalizeNameExpectation specifies expectation struct of the Validator.NormalizeName
type ValidatorMockNormalizeNameExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockNormalizeNameParams
	paramPtrs          *ValidatorMockNormalizeNameParamPtrs
	expectationOrigins ValidatorMockNormalizeNameExpectationOrigins
	results            *ValidatorMockNormalizeNameResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockNormalizeNameParams contains parameters of the Validator.NormalizeName
type ValidatorMockNormalizeNameParams struct {
	name string
}

// ValidatorMockNormalizeNameParamPtrs contains pointers to parameters of the Validator.NormalizeName
type ValidatorMockNormalizeNameParamPtrs struct {
	name *string
}

// ValidatorMockNormalizeNameResults contains results of the Validator.NormalizeName
type ValidatorMockNormalizeNameResults struct {
	s1 string
}

// ValidatorMockNormalizeNameOrigins contains origins of expectations of the Validator.NormalizeName
type ValidatorMockNormalizeNameExpectationOrigins struct {
	origin     string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNormalizeName *mValidatorMockNormalizeName) Optional() *mValidatorMockNormalizeName {
	mmNormalizeName.optional = true
	return mmNormalizeName
}

// Expect sets up expected params for Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) Expect(name string) *mValidatorMockNormalizeName {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	if mmNormalizeName.defaultExpectation == nil {
		mmNormalizeName.defaultExpectation = &ValidatorMockNormalizeNameExpectation{}
	}

	if mmNormalizeName.defaultExpectation.paramPtrs != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by ExpectParams functions")
	}

	mmNormalizeName.defaultExpectation.params = &ValidatorMockNormalizeNameParams{name}
	mmNormalizeName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNormalizeName.expectations {
		if minimock.Equal(e.params, mmNormalizeName.defaultExpectation.params) {
			mmNormalizeName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNormalizeName.defaultExpectation.params)
		}
	}

	return mmNormalizeName
}

// ExpectNameParam1 sets up expected param name for Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) ExpectNameParam1(name string) *mValidatorMockNormalizeName {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	if mmNormalizeName.defaultExpectation == nil {
		mmNormalizeName.defaultExpectation = &ValidatorMockNormalizeNameExpectation{}
	}

	if mmNormalizeName.defaultExpectation.params != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Expect")
	}

	if mmNormalizeName.defaultExpectation.paramPtrs == nil {
		mmNormalizeName.defaultExpectation.paramPtrs = &ValidatorMockNormalizeNameParamPtrs{}
	}
	mmNormalizeName.defaultExpectation.paramPtrs.name = &name
	mmNormalizeName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmNormalizeName
}

// Inspect accepts an inspector function that has same arguments as the Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) Inspect(f func(name string)) *mValidatorMockNormalizeName {
	if mmNormalizeName.mock.inspectFuncNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("Inspect function is already set for ValidatorMock.NormalizeName")
	}

	mmNormalizeName.mock.inspectFuncNormalizeName = f

	return mmNormalizeName
}

// Return sets up results that will be returned by Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) Return(s1 string) *ValidatorMock {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	if mmNormalizeName.defaultExpectation == nil {
		mmNormalizeName.defaultExpectation = &ValidatorMockNormalizeNameExpectation{mock: mmNormalizeName.mock}
	}
	mmNormalizeName.defaultExpectation.results = &ValidatorMockNormalizeNameResults{s1}
	mmNormalizeName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNormalizeName.mock
}

// Set uses given function f to mock the Validator.NormalizeName method
func (mmNormalizeName *mValidatorMockNormalizeName) Set(f func(name string) (s1 string)) *ValidatorMock {
	if mmNormalizeName.defaultExpectation != nil {
		mmNormalizeName.mock.t.Fatalf("Default expectation is already set for the Validator.NormalizeName method")
	}

	if len(mmNormalizeName.expectations) > 0 {
		mmNormalizeName.mock.t.Fatalf("Some expectations are already set for the Validator.NormalizeName method")
	}

	mmNormalizeName.mock.funcNormalizeName = f
	mmNormalizeName.mock.funcNormalizeNameOrigin = minimock.CallerInfo(1)
	return mmNormalizeName.mock
}

// When sets expectation for the Validator.NormalizeName which will trigger the result defined by the following
// Then helper
func (mmNormalizeName *mValidatorMockNormalizeName) When(name string) *ValidatorMockNormalizeNameExpectation {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	expectation := &ValidatorMockNormalizeNameExpectation{
		mock:               mmNormalizeName.mock,
		params:             &ValidatorMockNormalizeNameParams{name},
		expectationOrigins: ValidatorMockNormalizeNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNormalizeName.expectations = append(mmNormalizeName.expectations, expectation)
	return expectation
}

// Then sets up Validator.NormalizeName return parameters for the expectation previously defined by the When method
func (e *ValidatorMockNormalizeNameExpectation) Then(s1 string) *ValidatorMock {
	e.results = &ValidatorMockNormalizeNameResults{s1}
	return e.mock
}

// Times sets number of times Validator.NormalizeName should be invoked
func (mmNormalizeName *mValidatorMockNormalizeName) Times(n uint64) *mValidatorMockNormalizeName {
	if n == 0 {
		mmNormalizeName.mock.t.Fatalf("Times of ValidatorMock.NormalizeName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNormalizeName.expectedInvocations, n)
	mmNormalizeName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNormalizeName
}

func (mmNormalizeName *mValidatorMockNormalizeName) invocationsDone() bool {
	if len(mmNormalizeName.expectations) == 0 && mmNormalizeName.defaultExpectation == nil && mmNormalizeName.mock.funcNormalizeName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNormalizeName.mock.afterNormalizeNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNormalizeName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NormalizeName implements mm_user.Validator
func (mmNormalizeName *ValidatorMock) NormalizeName(name string) (s1 string) {
	mm_atomic.AddUint64(&mmNormalizeName.beforeNormalizeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmNormalizeName.afterNormalizeNameCounter, 1)

	mmNormalizeName.t.Helper()

	if mmNormalizeName.inspectFuncNormalizeName != nil {
		mmNormalizeName.inspectFuncNormalizeName(name)
	}

	mm_params := ValidatorMockNormalizeNameParams{name}

	// Record call args
	mmNormalizeName.NormalizeNameMock.mutex.Lock()
	mmNormalizeName.NormalizeNameMock.callArgs = append(mmNormalizeName.NormalizeNameMock.callArgs, &mm_params)
	mmNormalizeName.NormalizeNameMock.mutex.Unlock()

	for _, e := range mmNormalizeName.NormalizeNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmNormalizeName.NormalizeNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNormalizeName.NormalizeNameMock.defaultExpectation.Counter, 1)
		mm_want := mmNormalizeName.NormalizeNameMock.defaultExpectation.params
		mm_want_ptrs := mmNormalizeName.NormalizeNameMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockNormalizeNameParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmNormalizeName.t.Errorf("ValidatorMock.NormalizeName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNormalizeName.NormalizeNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNormalizeName.t.Errorf("ValidatorMock.NormalizeName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNormalizeName.NormalizeNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNormalizeName.NormalizeNameMock.defaultExpectation.results
		if mm_results == nil {
			mmNormalizeName.t.Fatal("No results are set for the ValidatorMock.NormalizeName")
		}
		return (*mm_results).s1
	}
	if mmNormalizeName.funcNormalizeName != nil {
		return mmNormalizeName.funcNormalizeName(name)
	}
	mmNormalizeName.t.Fatalf("Unexpected call to ValidatorMock.NormalizeName. %v", name)
	return
}

// NormalizeNameAfterCounter returns a count of finished ValidatorMock.NormalizeName invocations
func (mmNormalizeName *ValidatorMock) NormalizeNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNormalizeName.afterNormalizeNameCounter)
}

// NormalizeNameBeforeCounter returns a count of ValidatorMock.NormalizeName invocations
func (mmNormalizeName *ValidatorMock) NormalizeNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNormalizeName.beforeNormalizeNameCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.NormalizeName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNormalizeName *mValidatorMockNormalizeName) Calls() []*ValidatorMockNormalizeNameParams {
	mmNormalizeName.mutex.RLock()

	argCopy := make([]*ValidatorMockNormalizeNameParams, len(mmNormalizeName.callArgs))
	copy(argCopy, mmNormalizeName.callArgs)

	mmNormalizeName.mutex.RUnlock()

	return argCopy
}

// MinimockNormalizeNameDone returns true if the count of the NormalizeName invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockNormalizeNameDone() bool {
	if m.NormalizeNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NormalizeNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NormalizeNameMock.invocationsDone()
}

// MinimockNormalizeNameInspect logs each unmet expectation
func (m *ValidatorMock) MinimockNormalizeNameInspect() {
	for _, e := range m.NormalizeNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNormalizeNameCounter := mm_atomic.LoadUint64(&m.afterNormalizeNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NormalizeNameMock.defaultExpectation != nil && afterNormalizeNameCounter < 1 {
		if m.NormalizeNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s", m.NormalizeNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s with params: %#v", m.NormalizeNameMock.defaultExpectation.expectationOrigins.origin, *m.NormalizeNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNormalizeName != nil && afterNormalizeNameCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s", m.funcNormalizeNameOrigin)
	}

	if !m.NormalizeNameMock.invocationsDone() && afterNormalizeNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.NormalizeName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NormalizeNameMock.expectedInvocations), m.NormalizeNameMock.expectedInvocationsOrigin, afterNormalizeNameCounter)
	}
}

type mValidatorMockValidateEmail struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockValidateEmailExpectation
	expectations       []*ValidatorMockValidateEmailExpectation

	callArgs []*ValidatorMockValidateEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockValidateEmailExpectation specifies expectation struct of the Validator.ValidateEmail
type ValidatorMockValidateEmailExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockValidateEmailParams
	paramPtrs          *ValidatorMockValidateEmailParamPtrs
	expectationOrigins ValidatorMockValidateEmailExpectationOrigins
	results            *ValidatorMockValidateEmailResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockValidateEmailParams contains parameters of the Validator.ValidateEmail
type ValidatorMockValidateEmailParams struct {
	address        string
	validateLength bool
}

// ValidatorMockValidateEmailParamPtrs contains pointers to parameters of the Validator.ValidateEmail
type ValidatorMockValidateEmailParamPtrs struct {
	address        *string
	validateLength *bool
}

// ValidatorMockValidateEmailResults contains results of the Validator.ValidateEmail
type ValidatorMockValidateEmailResults struct {
	err error
}

// ValidatorMockValidateEmailOrigins contains origins of expectations of the Validator.ValidateEmail
type ValidatorMockValidateEmailExpectationOrigins struct {
	origin               string
	originAddress        string
	originValidateLength string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateEmail *mValidatorMockValidateEmail) Optional() *mValidatorMockValidateEmail {
	mmValidateEmail.optional = true
	return mmValidateEmail
}

// Expect sets up expected params for Validator.ValidateEmail
func (mmValidateEmail *mValidatorMockValidateEmail) Expect(address string, validateLength bool) *mValidatorMockValidateEmail {
	if mmValidateEmail.mock.funcValidateEmail != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Set")
	}

	if mmValidateEmail.defaultExpectation == nil {
		mmValidateEmail.defaultExpectation = &ValidatorMockValidateEmailExpectation{}
	}

	if mmValidateEmail.defaultExpectation.paramPtrs != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by ExpectParams functions")
	}

	mmValidateEmail.defaultExpectation.params = &ValidatorMockValidateEmailParams{address, validateLength}
	mmValidateEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateEmail.expectations {
		if minimock.Equal(e.params, mmValidateEmail.defaultExpectation.params) {
			mmValidateEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateEmail.defaultExpectation.params)
		}
	}

	return mmValidateEmail
}

// ExpectAddressParam1 sets up expected param address for Validator.ValidateEmail
func (mmValidateEmail *mValidatorMockValidateEmail) ExpectAddressParam1(address string) *mValidatorMockValidateEmail {
	if mmValidateEmail.mock.funcValidateEmail != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Set")
	}

	if mmValidateEmail.defaultExpectation == nil {
		mmValidateEmail.defaultExpectation = &ValidatorMockValidateEmailExpectation{}
	}

	if mmValidateEmail.defaultExpectation.params != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Expect")
	}

	if mmValidateEmail.defaultExpectation.paramPtrs == nil {
		mmValidateEmail.defaultExpectation.paramPtrs = &ValidatorMockValidateEmailParamPtrs{}
	}
	mmValidateEmail.defaultExpectation.paramPtrs.address = &address
	mmValidateEmail.defaultExpectation.expectationOrigins.originAddress = minimock.CallerInfo(1)

	return mmValidateEmail
}

// ExpectValidateLengthParam2 sets up expected param validateLength for Validator.ValidateEmail
func (mmValidateEmail *mValidatorMockValidateEmail) ExpectValidateLengthParam2(validateLength bool) *mValidatorMockValidateEmail {
	if mmValidateEmail.mock.funcValidateEmail != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Set")
	}

	if mmValidateEmail.defaultExpectation == nil {
		mmValidateEmail.defaultExpectation = &ValidatorMockValidateEmailExpectation{}
	}

	if mmValidateEmail.defaultExpectation.params != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Expect")
	}

	if mmValidateEmail.defaultExpectation.paramPtrs == nil {
		mmValidateEmail.defaultExpectation.paramPtrs = &ValidatorMockValidateEmailParamPtrs{}
	}
	mmValidateEmail.defaultExpectation.paramPtrs.validateLength = &validateLength
	mmValidateEmail.defaultExpectation.expectationOrigins.originValidateLength = minimock.CallerInfo(1)

	return mmValidateEmail
}

// Inspect accepts an inspector function that has same arguments as the Validator.ValidateEmail
func (mmValidateEmail *mValidatorMockValidateEmail) Inspect(f func(address string, validateLength bool)) *mValidatorMockValidateEmail {
	if mmValidateEmail.mock.inspectFuncValidateEmail != nil {
		mmValidateEmail.mock.t.Fatalf("Inspect function is already set for ValidatorMock.ValidateEmail")
	}

	mmValidateEmail.mock.inspectFuncValidateEmail = f

	return mmValidateEmail
}

// Return sets up results that will be returned by Validator.ValidateEmail
func (mmValidateEmail *mValidatorMockValidateEmail) Return(err error) *ValidatorMock {
	if mmValidateEmail.mock.funcValidateEmail != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Set")
	}

	if mmValidateEmail.defaultExpectation == nil {
		mmValidateEmail.defaultExpectation = &ValidatorMockValidateEmailExpectation{mock: mmValidateEmail.mock}
	}
	mmValidateEmail.defaultExpectation.results = &ValidatorMockValidateEmailResults{err}
	mmValidateEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateEmail.mock
}

// Set uses given function f to mock the Validator.ValidateEmail method
func (mmValidateEmail *mValidatorMockValidateEmail) Set(f func(address string, validateLength bool) (err error)) *ValidatorMock {
	if mmValidateEmail.defaultExpectation != nil {
		mmValidateEmail.mock.t.Fatalf("Default expectation is already set for the Validator.ValidateEmail method")
	}

	if len(mmValidateEmail.expectations) > 0 {
		mmValidateEmail.mock.t.Fatalf("Some expectations are already set for the Validator.ValidateEmail method")
	}

	mmValidateEmail.mock.funcValidateEmail = f
	mmValidateEmail.mock.funcValidateEmailOrigin = minimock.CallerInfo(1)
	return mmValidateEmail.mock
}

// When sets expectation for the Validator.ValidateEmail which will trigger the result defined by the following
// Then helper
func (mmValidateEmail *mValidatorMockValidateEmail) When(address string, validateLength bool) *ValidatorMockValidateEmailExpectation {
	if mmValidateEmail.mock.funcValidateEmail != nil {
		mmValidateEmail.mock.t.Fatalf("ValidatorMock.ValidateEmail mock is already set by Set")
	}

	expectation := &ValidatorMockValidateEmailExpectation{
		mock:               mmValidateEmail.mock,
		params:             &ValidatorMockValidateEmailParams{address, validateLength},
		expectationOrigins: ValidatorMockValidateEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateEmail.expectations = append(mmValidateEmail.expectations, expectation)
	return expectation
}

// Then sets up Validator.ValidateEmail return parameters for the expectation previously defined by the When method
func (e *ValidatorMockValidateEmailExpectation) Then(err error) *ValidatorMock {
	e.results = &ValidatorMockValidateEmailResults{err}
	return e.mock
}

// Times sets number of times Validator.ValidateEmail should be invoked
func (mmValidateEmail *mValidatorMockValidateEmail) Times(n uint64) *mValidatorMockValidateEmail {
	if n == 0 {
		mmValidateEmail.mock.t.Fatalf("Times of ValidatorMock.ValidateEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateEmail.expectedInvocations, n)
	mmValidateEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateEmail
}

func (mmValidateEmail *mValidatorMockValidateEmail) invocationsDone() bool {
	if len(mmValidateEmail.expectations) == 0 && mmValidateEmail.defaultExpectation == nil && mmValidateEmail.mock.funcValidateEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateEmail.mock.afterValidateEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateEmail implements mm_user.Validator
func (mmValidateEmail *ValidatorMock) ValidateEmail(address string, validateLength bool) (err error) {
	mm_atomic.AddUint64(&mmValidateEmail.beforeValidateEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateEmail.afterValidateEmailCounter, 1)

	mmValidateEmail.t.Helper()

	if mmValidateEmail.inspectFuncValidateEmail != nil {
		mmValidateEmail.inspectFuncValidateEmail(address, validateLength)
	}

	mm_params := ValidatorMockValidateEmailParams{address, validateLength}

	// Record call args
	mmValidateEmail.ValidateEmailMock.mutex.Lock()
	mmValidateEmail.ValidateEmailMock.callArgs = append(mmValidateEmail.ValidateEmailMock.callArgs, &mm_params)
	mmValidateEmail.ValidateEmailMock.mutex.Unlock()

	for _, e := range mmValidateEmail.ValidateEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateEmail.ValidateEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateEmail.ValidateEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateEmail.ValidateEmailMock.defaultExpectation.params
		mm_want_ptrs := mmValidateEmail.ValidateEmailMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockValidateEmailParams{address, validateLength}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.address != nil && !minimock.Equal(*mm_want_ptrs.address, mm_got.address) {
				mmValidateEmail.t.Errorf("ValidatorMock.ValidateEmail got unexpected parameter address, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateEmail.ValidateEmailMock.defaultExpectation.expectationOrigins.originAddress, *mm_want_ptrs.address, mm_got.address, minimock.Diff(*mm_want_ptrs.address, mm_got.address))
			}

			if mm_want_ptrs.validateLength != nil && !minimock.Equal(*mm_want_ptrs.validateLength, mm_got.validateLength) {
				mmValidateEmail.t.Errorf("ValidatorMock.ValidateEmail got unexpected parameter validateLength, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateEmail.ValidateEmailMock.defaultExpectation.expectationOrigins.originValidateLength, *mm_want_ptrs.validateLength, mm_got.validateLength, minimock.Diff(*mm_want_ptrs.validateLength, mm_got.validateLength))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateEmail.t.Errorf("ValidatorMock.ValidateEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateEmail.ValidateEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateEmail.ValidateEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateEmail.t.Fatal("No results are set for the ValidatorMock.ValidateEmail")
		}
		return (*mm_results).err
	}
	if mmValidateEmail.funcValidateEmail != nil {
		return mmValidateEmail.funcValidateEmail(address, validateLength)
	}
	mmValidateEmail.t.Fatalf("Unexpected call to ValidatorMock.ValidateEmail. %v %v", address, validateLength)
	return
}

// ValidateEmailAfterCounter returns a count of finished ValidatorMock.ValidateEmail invocations
func (mmValidateEmail *ValidatorMock) ValidateEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateEmail.afterValidateEmailCounter)
}

// ValidateEmailBeforeCounter returns a count of ValidatorMock.ValidateEmail invocations
func (mmValidateEmail *ValidatorMock) ValidateEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateEmail.beforeValidateEmailCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.ValidateEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateEmail *mValidatorMockValidateEmail) Calls() []*ValidatorMockValidateEmailParams {
	mmValidateEmail.mutex.RLock()

	argCopy := make([]*ValidatorMockValidateEmailParams, len(mmValidateEmail.callArgs))
	copy(argCopy, mmValidateEmail.callArgs)

	mmValidateEmail.mutex.RUnlock()

	return argCopy
}

// MinimockValidateEmailDone returns true if the count of the ValidateEmail invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockValidateEmailDone() bool {
	if m.ValidateEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateEmailMock.invocationsDone()
}

// MinimockValidateEmailInspect logs each unmet expectation
func (m *ValidatorMock) MinimockValidateEmailInspect() {
	for _, e := range m.ValidateEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.ValidateEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateEmailCounter := mm_atomic.LoadUint64(&m.afterValidateEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateEmailMock.defaultExpectation != nil && afterValidateEmailCounter < 1 {
		if m.ValidateEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.ValidateEmail at\n%s", m.ValidateEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.ValidateEmail at\n%s with params: %#v", m.ValidateEmailMock.defaultExpectation.expectationOrigins.origin, *m.ValidateEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateEmail != nil && afterValidateEmailCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.ValidateEmail at\n%s", m.funcValidateEmailOrigin)
	}

	if !m.ValidateEmailMock.invocationsDone() && afterValidateEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.ValidateEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateEmailMock.expectedInvocations), m.ValidateEmailMock.expectedInvocationsOrigin, afterValidateEmailCounter)
	}
}

type mValidatorMockValidateName struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockValidateNameExpectation
	expectations       []*ValidatorMockValidateNameExpectation

	callArgs []*ValidatorMockValidateNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockValidateNameExpectation specifies expectation struct of the Validator.ValidateName
type ValidatorMockValidateNameExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockValidateNameParams
	paramPtrs          *ValidatorMockValidateNameParamPtrs
	expectationOrigins ValidatorMockValidateNameExpectationOrigins
	results            *ValidatorMockValidateNameResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockValidateNameParams contains parameters of the Validator.ValidateName
type ValidatorMockValidateNameParams struct {
	name string
}

// ValidatorMockValidateNameParamPtrs contains pointers to parameters of the Validator.ValidateName
type ValidatorMockValidateNameParamPtrs struct {
	name *string
}

// ValidatorMockValidateNameResults contains results of the Validator.ValidateName
type ValidatorMockValidateNameResults struct {
	err error
}

// ValidatorMockValidateNameOrigins contains origins of expectations of the Validator.ValidateName
type ValidatorMockValidateNameExpectationOrigins struct {
	origin     string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateName *mValidatorMockValidateName) Optional() *mValidatorMockValidateName {
	mmValidateName.optional = true
	return mmValidateName
}

// Expect sets up expected params for Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) Expect(name string) *mValidatorMockValidateName {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	if mmValidateName.defaultExpectation == nil {
		mmValidateName.defaultExpectation = &ValidatorMockValidateNameExpectation{}
	}

	if mmValidateName.defaultExpectation.paramPtrs != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by ExpectParams functions")
	}

	mmValidateName.defaultExpectation.params = &ValidatorMockValidateNameParams{name}
	mmValidateName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateName.expectations {
		if minimock.Equal(e.params, mmValidateName.defaultExpectation.params) {
			mmValidateName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateName.defaultExpectation.params)
		}
	}

	return mmValidateName
}

// ExpectNameParam1 sets up expected param name for Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) ExpectNameParam1(name string) *mValidatorMockValidateName {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	if mmValidateName.defaultExpectation == nil {
		mmValidateName.defaultExpectation = &ValidatorMockValidateNameExpectation{}
	}

	if mmValidateName.defaultExpectation.params != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Expect")
	}

	if mmValidateName.defaultExpectation.paramPtrs == nil {
		mmValidateName.defaultExpectation.paramPtrs = &ValidatorMockValidateNameParamPtrs{}
	}
	mmValidateName.defaultExpectation.paramPtrs.name = &name
	mmValidateName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmValidateName
}

// Inspect accepts an inspector function that has same arguments as the Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) Inspect(f func(name string)) *mValidatorMockValidateName {
	if mmValidateName.mock.inspectFuncValidateName != nil {
		mmValidateName.mock.t.Fatalf("Inspect function is already set for ValidatorMock.ValidateName")
	}

	mmValidateName.mock.inspectFuncValidateName = f

	return mmValidateName
}

// Return sets up results that will be returned by Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) Return(err error) *ValidatorMock {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	if mmValidateName.defaultExpectation == nil {
		mmValidateName.defaultExpectation = &ValidatorMockValidateNameExpectation{mock: mmValidateName.mock}
	}
	mmValidateName.defaultExpectation.results = &ValidatorMockValidateNameResults{err}
	mmValidateName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateName.mock
}

// Set uses given function f to mock the Validator.ValidateName method
func (mmValidateName *mValidatorMockValidateName) Set(f func(name string) (err error)) *ValidatorMock {
	if mmValidateName.defaultExpectation != nil {
		mmValidateName.mock.t.Fatalf("Default expectation is already set for the Validator.ValidateName method")
	}

	if len(mmValidateName.expectations) > 0 {
		mmValidateName.mock.t.Fatalf("Some expectations are already set for the Validator.ValidateName method")
	}

	mmValidateName.mock.funcValidateName = f
	mmValidateName.mock.funcValidateNameOrigin = minimock.CallerInfo(1)
	return mmValidateName.mock
}

// When sets expectation for the Validator.ValidateName which will trigger the result defined by the following
// Then helper
func (mmValidateName *mValidatorMockValidateName) When(name string) *ValidatorMockValidateNameExpectation {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	expectation := &ValidatorMockValidateNameExpectation{
		mock:               mmValidateName.mock,
		params:             &ValidatorMockValidateNameParams{name},
		expectationOrigins: ValidatorMockValidateNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateName.expectations = append(mmValidateName.expectations, expectation)
	return expectation
}

// Then sets up Validator.ValidateName return parameters for the expectation previously defined by the When method
func (e *ValidatorMockValidateNameExpectation) Then(err error) *ValidatorMock {
	e.results = &ValidatorMockValidateNameResults{err}
	return e.mock
}

// Times sets number of times Validator.ValidateName should be invoked
func (mmValidateName *mValidatorMockValidateName) Times(n uint64) *mValidatorMockValidateName {
	if n == 0 {
		mmValidateName.mock.t.Fatalf("Times of ValidatorMock.ValidateName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateName.expectedInvocations, n)
	mmValidateName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateName
}

func (mmValidateName *mValidatorMockValidateName) invocationsDone() bool {
	if len(mmValidateName.expectations) == 0 && mmValidateName.defaultExpectation == nil && mmValidateName.mock.funcValidateName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateName.mock.afterValidateNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateName implements mm_user.Validator
func (mmValidateName *ValidatorMock) ValidateName(name string) (err error) {
	mm_atomic.AddUint64(&mmValidateName.beforeValidateNameCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateName.afterValidateNameCounter, 1)

	mmValidateName.t.Helper()

	if mmValidateName.inspectFuncValidateName != nil {
		mmValidateName.inspectFuncValidateName(name)
	}

	mm_params := ValidatorMockValidateNameParams{name}

	// Record call args
	mmValidateName.ValidateNameMock.mutex.Lock()
	mmValidateName.ValidateNameMock.callArgs = append(mmValidateName.ValidateNameMock.callArgs, &mm_params)
	mmValidateName.ValidateNameMock.mutex.Unlock()

	for _, e := range mmValidateName.ValidateNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateName.ValidateNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateName.ValidateNameMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateName.ValidateNameMock.defaultExpectation.params
		mm_want_ptrs := mmValidateName.ValidateNameMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockValidateNameParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmValidateName.t.Errorf("ValidatorMock.ValidateName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateName.ValidateNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateName.t.Errorf("ValidatorMock.ValidateName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateName.ValidateNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateName.ValidateNameMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateName.t.Fatal("No results are set for the ValidatorMock.ValidateName")
		}
		return (*mm_results).err
	}
	if mmValidateName.funcValidateName != nil {
		return mmValidateName.funcValidateName(name)
	}
	mmValidateName.t.Fatalf("Unexpected call to ValidatorMock.ValidateName. %v", name)
	return
}

// ValidateNameAfterCounter returns a count of finished ValidatorMock.ValidateName invocations
func (mmValidateName *ValidatorMock) ValidateNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateName.afterValidateNameCounter)
}

// ValidateNameBeforeCounter returns a count of ValidatorMock.ValidateName invocations
func (mmValidateName *ValidatorMock) ValidateNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateName.beforeValidateNameCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.ValidateName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateName *mValidatorMockValidateName) Calls() []*ValidatorMockValidateNameParams {
	mmValidateName.mutex.RLock()

	argCopy := make([]*ValidatorMockValidateNameParams, len(mmValidateName.callArgs))
	copy(argCopy, mmValidateName.callArgs)

	mmValidateName.mutex.RUnlock()

	return argCopy
}

// MinimockValidateNameDone returns true if the count of the ValidateName invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockValidateNameDone() bool {
	if m.ValidateNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateNameMock.invocationsDone()
}

// MinimockValidateNameInspect logs each unmet expectation
func (m *ValidatorMock) MinimockValidateNameInspect() {
	for _, e := range m.ValidateNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateNameCounter := mm_atomic.LoadUint64(&m.afterValidateNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateNameMock.defaultExpectation != nil && afterValidateNameCounter < 1 {
		if m.ValidateNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s", m.ValidateNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s with params: %#v", m.ValidateNameMock.defaultExpectation.expectationOrigins.origin, *m.ValidateNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateName != nil && afterValidateNameCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s", m.funcValidateNameOrigin)
	}

	if !m.ValidateNameMock.invocationsDone() && afterValidateNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.ValidateName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateNameMock.expectedInvocations), m.ValidateNameMock.expectedInvocationsOrigin, afterValidateNameCounter)
	}
}

type mValidatorMockValidatePassword struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockValidatePasswordExpectation
	expectations       []*ValidatorMockValidatePasswordExpectation

	callArgs []*ValidatorMockValidatePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockValidatePasswordExpectation specifies expectation struct of the Validator.ValidatePassword
type ValidatorMockValidatePasswordExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockValidatePasswordParams
	paramPtrs          *ValidatorMockValidatePasswordParamPtrs
	expectationOrigins ValidatorMockValidatePasswordExpectationOrigins
	results            *ValidatorMockValidatePasswordResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockValidatePasswordParams contains parameters of the Validator.ValidatePassword
type ValidatorMockValidatePasswordParams struct {
	password []byte
}

// ValidatorMockValidatePasswordParamPtrs contains pointers to parameters of the Validator.ValidatePassword
type ValidatorMockValidatePasswordParamPtrs struct {
	password *[]byte
}

// ValidatorMockValidatePasswordResults contains results of the Validator.ValidatePassword
type ValidatorMockValidatePasswordResults struct {
	err error
}

// ValidatorMockValidatePasswordOrigins contains origins of expectations of the Validator.ValidatePassword
type ValidatorMockValidatePasswordExpectationOrigins struct {
	origin         string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidatePassword *mValidatorMockValidatePassword) Optional() *mValidatorMockValidatePassword {
	mmValidatePassword.optional = true
	return mmValidatePassword
}

// Expect sets up expected params for Validator.ValidatePassword
func (mmValidatePassword *mValidatorMockValidatePassword) Expect(password []byte) *mValidatorMockValidatePassword {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("ValidatorMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &ValidatorMockValidatePasswordExpectation{}
	}

	if mmValidatePassword.defaultExpectation.paramPtrs != nil {
		mmValidatePassword.mock.t.Fatalf("ValidatorMock.ValidatePassword mock is already set by ExpectParams functions")
	}

	mmValidatePassword.defaultExpectation.params = &ValidatorMockValidatePasswordParams{password}
	mmValidatePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidatePassword.expectations {
		if minimock.Equal(e.params, mmValidatePassword.defaultExpectation.params) {
			mmValidatePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidatePassword.defaultExpectation.params)
		}
	}

	return mmValidatePassword
}

// ExpectPasswordParam1 sets up expected param password for Validator.ValidatePassword
func (mmValidatePassword *mValidatorMockValidatePassword) ExpectPasswordParam1(password []byte) *mValidatorMockValidatePassword {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("ValidatorMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &ValidatorMockValidatePasswordExpectation{}
	}

	if mmValidatePassword.defaultExpectation.params != nil {
		mmValidatePassword.mock.t.Fatalf("ValidatorMock.ValidatePassword mock is already set by Expect")
	}

	if mmValidatePassword.defaultExpectation.paramPtrs == nil {
		mmValidatePassword.defaultExpectation.paramPtrs = &ValidatorMockValidatePasswordParamPtrs{}
	}
	mmValidatePassword.defaultExpectation.paramPtrs.password = &password
	mmValidatePassword.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmValidatePassword
}

// Inspect accepts an inspector function that has same arguments as the Validator.ValidatePassword
func (mmValidatePassword *mValidatorMockValidatePassword) Inspect(f func(password []byte)) *mValidatorMockValidatePassword {
	if mmValidatePassword.mock.inspectFuncValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("Inspect function is already set for ValidatorMock.ValidatePassword")
	}

	mmValidatePassword.mock.inspectFuncValidatePassword = f

	return mmValidatePassword
}

// Return sets up results that will be returned by Validator.ValidatePassword
func (mmValidatePassword *mValidatorMockValidatePassword) Return(err error) *ValidatorMock {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("ValidatorMock.ValidatePassword mock is already set by Set")
	}

	if mmValidatePassword.defaultExpectation == nil {
		mmValidatePassword.defaultExpectation = &ValidatorMockValidatePasswordExpectation{mock: mmValidatePassword.mock}
	}
	mmValidatePassword.defaultExpectation.results = &ValidatorMockValidatePasswordResults{err}
	mmValidatePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidatePassword.mock
}

// Set uses given function f to mock the Validator.ValidatePassword method
func (mmValidatePassword *mValidatorMockValidatePassword) Set(f func(password []byte) (err error)) *ValidatorMock {
	if mmValidatePassword.defaultExpectation != nil {
		mmValidatePassword.mock.t.Fatalf("Default expectation is already set for the Validator.ValidatePassword method")
	}

	if len(mmValidatePassword.expectations) > 0 {
		mmValidatePassword.mock.t.Fatalf("Some expectations are already set for the Validator.ValidatePassword method")
	}

	mmValidatePassword.mock.funcValidatePassword = f
	mmValidatePassword.mock.funcValidatePasswordOrigin = minimock.CallerInfo(1)
	return mmValidatePassword.mock
}

// When sets expectation for the Validator.ValidatePassword which will trigger the result defined by the following
// Then helper
func (mmValidatePassword *mValidatorMockValidatePassword) When(password []byte) *ValidatorMockValidatePasswordExpectation {
	if mmValidatePassword.mock.funcValidatePassword != nil {
		mmValidatePassword.mock.t.Fatalf("ValidatorMock.ValidatePassword mock is already set by Set")
	}

	expectation := &ValidatorMockValidatePasswordExpectation{
		mock:               mmValidatePassword.mock,
		params:             &ValidatorMockValidatePasswordParams{password},
		expectationOrigins: ValidatorMockValidatePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidatePassword.expectations = append(mmValidatePassword.expectations, expectation)
	return expectation
}

// Then sets up Validator.ValidatePassword return parameters for the expectation previously defined by the When method
func (e *ValidatorMockValidatePasswordExpectation) Then(err error) *ValidatorMock {
	e.results = &ValidatorMockValidatePasswordResults{err}
	return e.mock
}

// Times sets number of times Validator.ValidatePassword should be invoked
func (mmValidatePassword *mValidatorMockValidatePassword) Times(n uint64) *mValidatorMockValidatePassword {
	if n == 0 {
		mmValidatePassword.mock.t.Fatalf("Times of ValidatorMock.ValidatePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidatePassword.expectedInvocations, n)
	mmValidatePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidatePassword
}

func (mmValidatePassword *mValidatorMockValidatePassword) invocationsDone() bool {
	if len(mmValidatePassword.expectations) == 0 && mmValidatePassword.defaultExpectation == nil && mmValidatePassword.mock.funcValidatePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidatePassword.mock.afterValidatePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidatePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidatePassword implements mm_user.Validator
func (mmValidatePassword *ValidatorMock) ValidatePassword(password []byte) (err error) {
	mm_atomic.AddUint64(&mmValidatePassword.beforeValidatePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmValidatePassword.afterValidatePasswordCounter, 1)

	mmValidatePassword.t.Helper()

	if mmValidatePassword.inspectFuncValidatePassword != nil {
		mmValidatePassword.inspectFuncValidatePassword(password)
	}

	mm_params := ValidatorMockValidatePasswordParams{password}

	// Record call args
	mmValidatePassword.ValidatePasswordMock.mutex.Lock()
	mmValidatePassword.ValidatePasswordMock.callArgs = append(mmValidatePassword.ValidatePasswordMock.callArgs, &mm_params)
	mmValidatePassword.ValidatePasswordMock.mutex.Unlock()

	for _, e := range mmValidatePassword.ValidatePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidatePassword.ValidatePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidatePassword.ValidatePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmValidatePassword.ValidatePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmValidatePassword.ValidatePasswordMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockValidatePasswordParams{password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmValidatePassword.t.Errorf("ValidatorMock.ValidatePassword got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidatePassword.ValidatePasswordMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidatePassword.t.Errorf("ValidatorMock.ValidatePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidatePassword.ValidatePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidatePassword.ValidatePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmValidatePassword.t.Fatal("No results are set for the ValidatorMock.ValidatePassword")
		}
		return (*mm_results).err
	}
	if mmValidatePassword.funcValidatePassword != nil {
		return mmValidatePassword.funcValidatePassword(password)
	}
	mmValidatePassword.t.Fatalf("Unexpected call to ValidatorMock.ValidatePassword. %v", password)
	return
}

// ValidatePasswordAfterCounter returns a count of finished ValidatorMock.ValidatePassword invocations
func (mmValidatePassword *ValidatorMock) ValidatePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePassword.afterValidatePasswordCounter)
}

// ValidatePasswordBeforeCounter returns a count of ValidatorMock.ValidatePassword invocations
func (mmValidatePassword *ValidatorMock) ValidatePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePassword.beforeValidatePasswordCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.ValidatePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidatePassword *mValidatorMockValidatePassword) Calls() []*ValidatorMockValidatePasswordParams {
	mmValidatePassword.mutex.RLock()

	argCopy := make([]*ValidatorMockValidatePasswordParams, len(mmValidatePassword.callArgs))
	copy(argCopy, mmValidatePassword.callArgs)

	mmValidatePassword.mutex.RUnlock()

	return argCopy
}

// MinimockValidatePasswordDone returns true if the count of the ValidatePassword invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockValidatePasswordDone() bool {
	if m.ValidatePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidatePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidatePasswordMock.invocationsDone()
}

// MinimockValidatePasswordInspect logs each unmet expectation
func (m *ValidatorMock) MinimockValidatePasswordInspect() {
	for _, e := range m.ValidatePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.ValidatePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidatePasswordCounter := mm_atomic.LoadUint64(&m.afterValidatePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidatePasswordMock.defaultExpectation != nil && afterValidatePasswordCounter < 1 {
		if m.ValidatePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.ValidatePassword at\n%s", m.ValidatePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.ValidatePassword at\n%s with params: %#v", m.ValidatePasswordMock.defaultExpectation.expectationOrigins.origin, *m.ValidatePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidatePassword != nil && afterValidatePasswordCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.ValidatePassword at\n%s", m.funcValidatePasswordOrigin)
	}

	if !m.ValidatePasswordMock.invocationsDone() && afterValidatePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.ValidatePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidatePasswordMock.expectedInvocations), m.ValidatePasswordMock.expectedInvocationsOrigin, afterValidatePasswordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ValidatorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockNormalizeEmailInspect()

			m.MinimockNormalizeNameInspect()

			m.MinimockValidateEmailInspect()

			m.MinimockValidateNameInspect()

			m.MinimockValidatePasswordInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ValidatorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ValidatorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockNormalizeEmailDone() &&
		m.MinimockNormalizeNameDone() &&
		m.MinimockValidateEmailDone() &&
		m.MinimockValidateNameDone() &&
		m.MinimockValidatePasswordDone()
}
