// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/user/usecase.AuthService -o auth_service_mock.go -n AuthServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// AuthServiceMock implements mm_usecase.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckIsAdmin          func(ctx context.Context) (err error)
	funcCheckIsAdminOrigin    string
	inspectFuncCheckIsAdmin   func(ctx context.Context)
	afterCheckIsAdminCounter  uint64
	beforeCheckIsAdminCounter uint64
	CheckIsAdminMock          mAuthServiceMockCheckIsAdmin

	funcCheckSelf          func(ctx context.Context, targetUserID uuid.UUID) (err error)
	funcCheckSelfOrigin    string
	inspectFuncCheckSelf   func(ctx context.Context, targetUserID uuid.UUID)
	afterCheckSelfCounter  uint64
	beforeCheckSelfCounter uint64
	CheckSelfMock          mAuthServiceMockCheckSelf

	funcCheckSelfOrAdmin          func(ctx context.Context, targetUserID uuid.UUID) (err error)
	funcCheckSelfOrAdminOrigin    string
	inspectFuncCheckSelfOrAdmin   func(ctx context.Context, targetUserID uuid.UUID)
	afterCheckSelfOrAdminCounter  uint64
	beforeCheckSelfOrAdminCounter uint64
	CheckSelfOrAdminMock          mAuthServiceMockCheckSelfOrAdmin

	funcDeleteSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (err error)
	funcDeleteSessionsByUserIDOrigin    string
	inspectFuncDeleteSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterDeleteSessionsByUserIDCounter  uint64
	beforeDeleteSessionsByUserIDCounter uint64
	DeleteSessionsByUserIDMock          mAuthServiceMockDeleteSessionsByUserID

	funcIsAdmin          func(ctx context.Context) (b1 bool, err error)
	funcIsAdminOrigin    string
	inspectFuncIsAdmin   func(ctx context.Context)
	afterIsAdminCounter  uint64
	beforeIsAdminCounter uint64
	IsAdminMock          mAuthServiceMockIsAdmin
}

// NewAuthServiceMock returns a mock for mm_usecase.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckIsAdminMock = mAuthServiceMockCheckIsAdmin{mock: m}
	m.CheckIsAdminMock.callArgs = []*AuthServiceMockCheckIsAdminParams{}

	m.CheckSelfMock = mAuthServiceMockCheckSelf{mock: m}
	m.CheckSelfMock.callArgs = []*AuthServiceMockCheckSelfParams{}

	m.CheckSelfOrAdminMock = mAuthServiceMockCheckSelfOrAdmin{mock: m}
	m.CheckSelfOrAdminMock.callArgs = []*AuthServiceMockCheckSelfOrAdminParams{}

	m.DeleteSessionsByUserIDMock = mAuthServiceMockDeleteSessionsByUserID{mock: m}
	m.DeleteSessionsByUserIDMock.callArgs = []*AuthServiceMockDeleteSessionsByUserIDParams{}

	m.IsAdminMock = mAuthServiceMockIsAdmin{mock: m}
	m.IsAdminMock.callArgs = []*AuthServiceMockIsAdminParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockCheckIsAdmin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockCheckIsAdminExpectation
	expectations       []*AuthServiceMockCheckIsAdminExpectation

	callArgs []*AuthServiceMockCheckIsAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockCheckIsAdminExpectation specifies expectation struct of the AuthService.CheckIsAdmin
type AuthServiceMockCheckIsAdminExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockCheckIsAdminParams
	paramPtrs          *AuthServiceMockCheckIsAdminParamPtrs
	expectationOrigins AuthServiceMockCheckIsAdminExpectationOrigins
	results            *AuthServiceMockCheckIsAdminResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockCheckIsAdminParams contains parameters of the AuthService.CheckIsAdmin
type AuthServiceMockCheckIsAdminParams struct {
	ctx context.Context
}

// AuthServiceMockCheckIsAdminParamPtrs contains pointers to parameters of the AuthService.CheckIsAdmin
type AuthServiceMockCheckIsAdminParamPtrs struct {
	ctx *context.Context
}

// AuthServiceMockCheckIsAdminResults contains results of the AuthService.CheckIsAdmin
type AuthServiceMockCheckIsAdminResults struct {
	err error
}

// AuthServiceMockCheckIsAdminOrigins contains origins of expectations of the AuthService.CheckIsAdmin
type AuthServiceMockCheckIsAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Optional() *mAuthServiceMockCheckIsAdmin {
	mmCheckIsAdmin.optional = true
	return mmCheckIsAdmin
}

// Expect sets up expected params for AuthService.CheckIsAdmin
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Expect(ctx context.Context) *mAuthServiceMockCheckIsAdmin {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("AuthServiceMock.CheckIsAdmin mock is already set by Set")
	}

	if mmCheckIsAdmin.defaultExpectation == nil {
		mmCheckIsAdmin.defaultExpectation = &AuthServiceMockCheckIsAdminExpectation{}
	}

	if mmCheckIsAdmin.defaultExpectation.paramPtrs != nil {
		mmCheckIsAdmin.mock.t.Fatalf("AuthServiceMock.CheckIsAdmin mock is already set by ExpectParams functions")
	}

	mmCheckIsAdmin.defaultExpectation.params = &AuthServiceMockCheckIsAdminParams{ctx}
	mmCheckIsAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckIsAdmin.expectations {
		if minimock.Equal(e.params, mmCheckIsAdmin.defaultExpectation.params) {
			mmCheckIsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckIsAdmin.defaultExpectation.params)
		}
	}

	return mmCheckIsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.CheckIsAdmin
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockCheckIsAdmin {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("AuthServiceMock.CheckIsAdmin mock is already set by Set")
	}

	if mmCheckIsAdmin.defaultExpectation == nil {
		mmCheckIsAdmin.defaultExpectation = &AuthServiceMockCheckIsAdminExpectation{}
	}

	if mmCheckIsAdmin.defaultExpectation.params != nil {
		mmCheckIsAdmin.mock.t.Fatalf("AuthServiceMock.CheckIsAdmin mock is already set by Expect")
	}

	if mmCheckIsAdmin.defaultExpectation.paramPtrs == nil {
		mmCheckIsAdmin.defaultExpectation.paramPtrs = &AuthServiceMockCheckIsAdminParamPtrs{}
	}
	mmCheckIsAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckIsAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckIsAdmin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.CheckIsAdmin
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Inspect(f func(ctx context.Context)) *mAuthServiceMockCheckIsAdmin {
	if mmCheckIsAdmin.mock.inspectFuncCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.CheckIsAdmin")
	}

	mmCheckIsAdmin.mock.inspectFuncCheckIsAdmin = f

	return mmCheckIsAdmin
}

// Return sets up results that will be returned by AuthService.CheckIsAdmin
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Return(err error) *AuthServiceMock {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("AuthServiceMock.CheckIsAdmin mock is already set by Set")
	}

	if mmCheckIsAdmin.defaultExpectation == nil {
		mmCheckIsAdmin.defaultExpectation = &AuthServiceMockCheckIsAdminExpectation{mock: mmCheckIsAdmin.mock}
	}
	mmCheckIsAdmin.defaultExpectation.results = &AuthServiceMockCheckIsAdminResults{err}
	mmCheckIsAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckIsAdmin.mock
}

// Set uses given function f to mock the AuthService.CheckIsAdmin method
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Set(f func(ctx context.Context) (err error)) *AuthServiceMock {
	if mmCheckIsAdmin.defaultExpectation != nil {
		mmCheckIsAdmin.mock.t.Fatalf("Default expectation is already set for the AuthService.CheckIsAdmin method")
	}

	if len(mmCheckIsAdmin.expectations) > 0 {
		mmCheckIsAdmin.mock.t.Fatalf("Some expectations are already set for the AuthService.CheckIsAdmin method")
	}

	mmCheckIsAdmin.mock.funcCheckIsAdmin = f
	mmCheckIsAdmin.mock.funcCheckIsAdminOrigin = minimock.CallerInfo(1)
	return mmCheckIsAdmin.mock
}

// When sets expectation for the AuthService.CheckIsAdmin which will trigger the result defined by the following
// Then helper
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) When(ctx context.Context) *AuthServiceMockCheckIsAdminExpectation {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("AuthServiceMock.CheckIsAdmin mock is already set by Set")
	}

	expectation := &AuthServiceMockCheckIsAdminExpectation{
		mock:               mmCheckIsAdmin.mock,
		params:             &AuthServiceMockCheckIsAdminParams{ctx},
		expectationOrigins: AuthServiceMockCheckIsAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckIsAdmin.expectations = append(mmCheckIsAdmin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.CheckIsAdmin return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockCheckIsAdminExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockCheckIsAdminResults{err}
	return e.mock
}

// Times sets number of times AuthService.CheckIsAdmin should be invoked
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Times(n uint64) *mAuthServiceMockCheckIsAdmin {
	if n == 0 {
		mmCheckIsAdmin.mock.t.Fatalf("Times of AuthServiceMock.CheckIsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckIsAdmin.expectedInvocations, n)
	mmCheckIsAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckIsAdmin
}

func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) invocationsDone() bool {
	if len(mmCheckIsAdmin.expectations) == 0 && mmCheckIsAdmin.defaultExpectation == nil && mmCheckIsAdmin.mock.funcCheckIsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckIsAdmin.mock.afterCheckIsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckIsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckIsAdmin implements mm_usecase.AuthService
func (mmCheckIsAdmin *AuthServiceMock) CheckIsAdmin(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCheckIsAdmin.beforeCheckIsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckIsAdmin.afterCheckIsAdminCounter, 1)

	mmCheckIsAdmin.t.Helper()

	if mmCheckIsAdmin.inspectFuncCheckIsAdmin != nil {
		mmCheckIsAdmin.inspectFuncCheckIsAdmin(ctx)
	}

	mm_params := AuthServiceMockCheckIsAdminParams{ctx}

	// Record call args
	mmCheckIsAdmin.CheckIsAdminMock.mutex.Lock()
	mmCheckIsAdmin.CheckIsAdminMock.callArgs = append(mmCheckIsAdmin.CheckIsAdminMock.callArgs, &mm_params)
	mmCheckIsAdmin.CheckIsAdminMock.mutex.Unlock()

	for _, e := range mmCheckIsAdmin.CheckIsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockCheckIsAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckIsAdmin.t.Errorf("AuthServiceMock.CheckIsAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckIsAdmin.t.Errorf("AuthServiceMock.CheckIsAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckIsAdmin.t.Fatal("No results are set for the AuthServiceMock.CheckIsAdmin")
		}
		return (*mm_results).err
	}
	if mmCheckIsAdmin.funcCheckIsAdmin != nil {
		return mmCheckIsAdmin.funcCheckIsAdmin(ctx)
	}
	mmCheckIsAdmin.t.Fatalf("Unexpected call to AuthServiceMock.CheckIsAdmin. %v", ctx)
	return
}

// CheckIsAdminAfterCounter returns a count of finished AuthServiceMock.CheckIsAdmin invocations
func (mmCheckIsAdmin *AuthServiceMock) CheckIsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIsAdmin.afterCheckIsAdminCounter)
}

// CheckIsAdminBeforeCounter returns a count of AuthServiceMock.CheckIsAdmin invocations
func (mmCheckIsAdmin *AuthServiceMock) CheckIsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIsAdmin.beforeCheckIsAdminCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.CheckIsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckIsAdmin *mAuthServiceMockCheckIsAdmin) Calls() []*AuthServiceMockCheckIsAdminParams {
	mmCheckIsAdmin.mutex.RLock()

	argCopy := make([]*AuthServiceMockCheckIsAdminParams, len(mmCheckIsAdmin.callArgs))
	copy(argCopy, mmCheckIsAdmin.callArgs)

	mmCheckIsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockCheckIsAdminDone returns true if the count of the CheckIsAdmin invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockCheckIsAdminDone() bool {
	if m.CheckIsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckIsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckIsAdminMock.invocationsDone()
}

// MinimockCheckIsAdminInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockCheckIsAdminInspect() {
	for _, e := range m.CheckIsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.CheckIsAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckIsAdminCounter := mm_atomic.LoadUint64(&m.afterCheckIsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckIsAdminMock.defaultExpectation != nil && afterCheckIsAdminCounter < 1 {
		if m.CheckIsAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.CheckIsAdmin at\n%s", m.CheckIsAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.CheckIsAdmin at\n%s with params: %#v", m.CheckIsAdminMock.defaultExpectation.expectationOrigins.origin, *m.CheckIsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckIsAdmin != nil && afterCheckIsAdminCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.CheckIsAdmin at\n%s", m.funcCheckIsAdminOrigin)
	}

	if !m.CheckIsAdminMock.invocationsDone() && afterCheckIsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.CheckIsAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckIsAdminMock.expectedInvocations), m.CheckIsAdminMock.expectedInvocationsOrigin, afterCheckIsAdminCounter)
	}
}

type mAuthServiceMockCheckSelf struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockCheckSelfExpectation
	expectations       []*AuthServiceMockCheckSelfExpectation

	callArgs []*AuthServiceMockCheckSelfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockCheckSelfExpectation specifies expectation struct of the AuthService.CheckSelf
type AuthServiceMockCheckSelfExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockCheckSelfParams
	paramPtrs          *AuthServiceMockCheckSelfParamPtrs
	expectationOrigins AuthServiceMockCheckSelfExpectationOrigins
	results            *AuthServiceMockCheckSelfResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockCheckSelfParams contains parameters of the AuthService.CheckSelf
type AuthServiceMockCheckSelfParams struct {
	ctx          context.Context
	targetUserID uuid.UUID
}

// AuthServiceMockCheckSelfParamPtrs contains pointers to parameters of the AuthService.CheckSelf
type AuthServiceMockCheckSelfParamPtrs struct {
	ctx          *context.Context
	targetUserID *uuid.UUID
}

// AuthServiceMockCheckSelfResults contains results of the AuthService.CheckSelf
type AuthServiceMockCheckSelfResults struct {
	err error
}

// AuthServiceMockCheckSelfOrigins contains origins of expectations of the AuthService.CheckSelf
type AuthServiceMockCheckSelfExpectationOrigins struct {
	origin             string
	originCtx          string
	originTargetUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckSelf *mAuthServiceMockCheckSelf) Optional() *mAuthServiceMockCheckSelf {
	mmCheckSelf.optional = true
	return mmCheckSelf
}

// Expect sets up expected params for AuthService.CheckSelf
func (mmCheckSelf *mAuthServiceMockCheckSelf) Expect(ctx context.Context, targetUserID uuid.UUID) *mAuthServiceMockCheckSelf {
	if mmCheckSelf.mock.funcCheckSelf != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Set")
	}

	if mmCheckSelf.defaultExpectation == nil {
		mmCheckSelf.defaultExpectation = &AuthServiceMockCheckSelfExpectation{}
	}

	if mmCheckSelf.defaultExpectation.paramPtrs != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by ExpectParams functions")
	}

	mmCheckSelf.defaultExpectation.params = &AuthServiceMockCheckSelfParams{ctx, targetUserID}
	mmCheckSelf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckSelf.expectations {
		if minimock.Equal(e.params, mmCheckSelf.defaultExpectation.params) {
			mmCheckSelf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckSelf.defaultExpectation.params)
		}
	}

	return mmCheckSelf
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.CheckSelf
func (mmCheckSelf *mAuthServiceMockCheckSelf) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockCheckSelf {
	if mmCheckSelf.mock.funcCheckSelf != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Set")
	}

	if mmCheckSelf.defaultExpectation == nil {
		mmCheckSelf.defaultExpectation = &AuthServiceMockCheckSelfExpectation{}
	}

	if mmCheckSelf.defaultExpectation.params != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Expect")
	}

	if mmCheckSelf.defaultExpectation.paramPtrs == nil {
		mmCheckSelf.defaultExpectation.paramPtrs = &AuthServiceMockCheckSelfParamPtrs{}
	}
	mmCheckSelf.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckSelf.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckSelf
}

// ExpectTargetUserIDParam2 sets up expected param targetUserID for AuthService.CheckSelf
func (mmCheckSelf *mAuthServiceMockCheckSelf) ExpectTargetUserIDParam2(targetUserID uuid.UUID) *mAuthServiceMockCheckSelf {
	if mmCheckSelf.mock.funcCheckSelf != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Set")
	}

	if mmCheckSelf.defaultExpectation == nil {
		mmCheckSelf.defaultExpectation = &AuthServiceMockCheckSelfExpectation{}
	}

	if mmCheckSelf.defaultExpectation.params != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Expect")
	}

	if mmCheckSelf.defaultExpectation.paramPtrs == nil {
		mmCheckSelf.defaultExpectation.paramPtrs = &AuthServiceMockCheckSelfParamPtrs{}
	}
	mmCheckSelf.defaultExpectation.paramPtrs.targetUserID = &targetUserID
	mmCheckSelf.defaultExpectation.expectationOrigins.originTargetUserID = minimock.CallerInfo(1)

	return mmCheckSelf
}

// Inspect accepts an inspector function that has same arguments as the AuthService.CheckSelf
func (mmCheckSelf *mAuthServiceMockCheckSelf) Inspect(f func(ctx context.Context, targetUserID uuid.UUID)) *mAuthServiceMockCheckSelf {
	if mmCheckSelf.mock.inspectFuncCheckSelf != nil {
		mmCheckSelf.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.CheckSelf")
	}

	mmCheckSelf.mock.inspectFuncCheckSelf = f

	return mmCheckSelf
}

// Return sets up results that will be returned by AuthService.CheckSelf
func (mmCheckSelf *mAuthServiceMockCheckSelf) Return(err error) *AuthServiceMock {
	if mmCheckSelf.mock.funcCheckSelf != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Set")
	}

	if mmCheckSelf.defaultExpectation == nil {
		mmCheckSelf.defaultExpectation = &AuthServiceMockCheckSelfExpectation{mock: mmCheckSelf.mock}
	}
	mmCheckSelf.defaultExpectation.results = &AuthServiceMockCheckSelfResults{err}
	mmCheckSelf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckSelf.mock
}

// Set uses given function f to mock the AuthService.CheckSelf method
func (mmCheckSelf *mAuthServiceMockCheckSelf) Set(f func(ctx context.Context, targetUserID uuid.UUID) (err error)) *AuthServiceMock {
	if mmCheckSelf.defaultExpectation != nil {
		mmCheckSelf.mock.t.Fatalf("Default expectation is already set for the AuthService.CheckSelf method")
	}

	if len(mmCheckSelf.expectations) > 0 {
		mmCheckSelf.mock.t.Fatalf("Some expectations are already set for the AuthService.CheckSelf method")
	}

	mmCheckSelf.mock.funcCheckSelf = f
	mmCheckSelf.mock.funcCheckSelfOrigin = minimock.CallerInfo(1)
	return mmCheckSelf.mock
}

// When sets expectation for the AuthService.CheckSelf which will trigger the result defined by the following
// Then helper
func (mmCheckSelf *mAuthServiceMockCheckSelf) When(ctx context.Context, targetUserID uuid.UUID) *AuthServiceMockCheckSelfExpectation {
	if mmCheckSelf.mock.funcCheckSelf != nil {
		mmCheckSelf.mock.t.Fatalf("AuthServiceMock.CheckSelf mock is already set by Set")
	}

	expectation := &AuthServiceMockCheckSelfExpectation{
		mock:               mmCheckSelf.mock,
		params:             &AuthServiceMockCheckSelfParams{ctx, targetUserID},
		expectationOrigins: AuthServiceMockCheckSelfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckSelf.expectations = append(mmCheckSelf.expectations, expectation)
	return expectation
}

// Then sets up AuthService.CheckSelf return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockCheckSelfExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockCheckSelfResults{err}
	return e.mock
}

// Times sets number of times AuthService.CheckSelf should be invoked
func (mmCheckSelf *mAuthServiceMockCheckSelf) Times(n uint64) *mAuthServiceMockCheckSelf {
	if n == 0 {
		mmCheckSelf.mock.t.Fatalf("Times of AuthServiceMock.CheckSelf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckSelf.expectedInvocations, n)
	mmCheckSelf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckSelf
}

func (mmCheckSelf *mAuthServiceMockCheckSelf) invocationsDone() bool {
	if len(mmCheckSelf.expectations) == 0 && mmCheckSelf.defaultExpectation == nil && mmCheckSelf.mock.funcCheckSelf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckSelf.mock.afterCheckSelfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckSelf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckSelf implements mm_usecase.AuthService
func (mmCheckSelf *AuthServiceMock) CheckSelf(ctx context.Context, targetUserID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCheckSelf.beforeCheckSelfCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckSelf.afterCheckSelfCounter, 1)

	mmCheckSelf.t.Helper()

	if mmCheckSelf.inspectFuncCheckSelf != nil {
		mmCheckSelf.inspectFuncCheckSelf(ctx, targetUserID)
	}

	mm_params := AuthServiceMockCheckSelfParams{ctx, targetUserID}

	// Record call args
	mmCheckSelf.CheckSelfMock.mutex.Lock()
	mmCheckSelf.CheckSelfMock.callArgs = append(mmCheckSelf.CheckSelfMock.callArgs, &mm_params)
	mmCheckSelf.CheckSelfMock.mutex.Unlock()

	for _, e := range mmCheckSelf.CheckSelfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckSelf.CheckSelfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckSelf.CheckSelfMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckSelf.CheckSelfMock.defaultExpectation.params
		mm_want_ptrs := mmCheckSelf.CheckSelfMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockCheckSelfParams{ctx, targetUserID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckSelf.t.Errorf("AuthServiceMock.CheckSelf got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckSelf.CheckSelfMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.targetUserID != nil && !minimock.Equal(*mm_want_ptrs.targetUserID, mm_got.targetUserID) {
				mmCheckSelf.t.Errorf("AuthServiceMock.CheckSelf got unexpected parameter targetUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckSelf.CheckSelfMock.defaultExpectation.expectationOrigins.originTargetUserID, *mm_want_ptrs.targetUserID, mm_got.targetUserID, minimock.Diff(*mm_want_ptrs.targetUserID, mm_got.targetUserID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckSelf.t.Errorf("AuthServiceMock.CheckSelf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckSelf.CheckSelfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckSelf.CheckSelfMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckSelf.t.Fatal("No results are set for the AuthServiceMock.CheckSelf")
		}
		return (*mm_results).err
	}
	if mmCheckSelf.funcCheckSelf != nil {
		return mmCheckSelf.funcCheckSelf(ctx, targetUserID)
	}
	mmCheckSelf.t.Fatalf("Unexpected call to AuthServiceMock.CheckSelf. %v %v", ctx, targetUserID)
	return
}

// CheckSelfAfterCounter returns a count of finished AuthServiceMock.CheckSelf invocations
func (mmCheckSelf *AuthServiceMock) CheckSelfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckSelf.afterCheckSelfCounter)
}

// CheckSelfBeforeCounter returns a count of AuthServiceMock.CheckSelf invocations
func (mmCheckSelf *AuthServiceMock) CheckSelfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckSelf.beforeCheckSelfCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.CheckSelf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckSelf *mAuthServiceMockCheckSelf) Calls() []*AuthServiceMockCheckSelfParams {
	mmCheckSelf.mutex.RLock()

	argCopy := make([]*AuthServiceMockCheckSelfParams, len(mmCheckSelf.callArgs))
	copy(argCopy, mmCheckSelf.callArgs)

	mmCheckSelf.mutex.RUnlock()

	return argCopy
}

// MinimockCheckSelfDone returns true if the count of the CheckSelf invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockCheckSelfDone() bool {
	if m.CheckSelfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckSelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckSelfMock.invocationsDone()
}

// MinimockCheckSelfInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockCheckSelfInspect() {
	for _, e := range m.CheckSelfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.CheckSelf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckSelfCounter := mm_atomic.LoadUint64(&m.afterCheckSelfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckSelfMock.defaultExpectation != nil && afterCheckSelfCounter < 1 {
		if m.CheckSelfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.CheckSelf at\n%s", m.CheckSelfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.CheckSelf at\n%s with params: %#v", m.CheckSelfMock.defaultExpectation.expectationOrigins.origin, *m.CheckSelfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckSelf != nil && afterCheckSelfCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.CheckSelf at\n%s", m.funcCheckSelfOrigin)
	}

	if !m.CheckSelfMock.invocationsDone() && afterCheckSelfCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.CheckSelf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckSelfMock.expectedInvocations), m.CheckSelfMock.expectedInvocationsOrigin, afterCheckSelfCounter)
	}
}

type mAuthServiceMockCheckSelfOrAdmin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockCheckSelfOrAdminExpectation
	expectations       []*AuthServiceMockCheckSelfOrAdminExpectation

	callArgs []*AuthServiceMockCheckSelfOrAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockCheckSelfOrAdminExpectation specifies expectation struct of the AuthService.CheckSelfOrAdmin
type AuthServiceMockCheckSelfOrAdminExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockCheckSelfOrAdminParams
	paramPtrs          *AuthServiceMockCheckSelfOrAdminParamPtrs
	expectationOrigins AuthServiceMockCheckSelfOrAdminExpectationOrigins
	results            *AuthServiceMockCheckSelfOrAdminResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockCheckSelfOrAdminParams contains parameters of the AuthService.CheckSelfOrAdmin
type AuthServiceMockCheckSelfOrAdminParams struct {
	ctx          context.Context
	targetUserID uuid.UUID
}

// AuthServiceMockCheckSelfOrAdminParamPtrs contains pointers to parameters of the AuthService.CheckSelfOrAdmin
type AuthServiceMockCheckSelfOrAdminParamPtrs struct {
	ctx          *context.Context
	targetUserID *uuid.UUID
}

// AuthServiceMockCheckSelfOrAdminResults contains results of the AuthService.CheckSelfOrAdmin
type AuthServiceMockCheckSelfOrAdminResults struct {
	err error
}

// AuthServiceMockCheckSelfOrAdminOrigins contains origins of expectations of the AuthService.CheckSelfOrAdmin
type AuthServiceMockCheckSelfOrAdminExpectationOrigins struct {
	origin             string
	originCtx          string
	originTargetUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Optional() *mAuthServiceMockCheckSelfOrAdmin {
	mmCheckSelfOrAdmin.optional = true
	return mmCheckSelfOrAdmin
}

// Expect sets up expected params for AuthService.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Expect(ctx context.Context, targetUserID uuid.UUID) *mAuthServiceMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &AuthServiceMockCheckSelfOrAdminExpectation{}
	}

	if mmCheckSelfOrAdmin.defaultExpectation.paramPtrs != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by ExpectParams functions")
	}

	mmCheckSelfOrAdmin.defaultExpectation.params = &AuthServiceMockCheckSelfOrAdminParams{ctx, targetUserID}
	mmCheckSelfOrAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckSelfOrAdmin.expectations {
		if minimock.Equal(e.params, mmCheckSelfOrAdmin.defaultExpectation.params) {
			mmCheckSelfOrAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckSelfOrAdmin.defaultExpectation.params)
		}
	}

	return mmCheckSelfOrAdmin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &AuthServiceMockCheckSelfOrAdminExpectation{}
	}

	if mmCheckSelfOrAdmin.defaultExpectation.params != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Expect")
	}

	if mmCheckSelfOrAdmin.defaultExpectation.paramPtrs == nil {
		mmCheckSelfOrAdmin.defaultExpectation.paramPtrs = &AuthServiceMockCheckSelfOrAdminParamPtrs{}
	}
	mmCheckSelfOrAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckSelfOrAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckSelfOrAdmin
}

// ExpectTargetUserIDParam2 sets up expected param targetUserID for AuthService.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) ExpectTargetUserIDParam2(targetUserID uuid.UUID) *mAuthServiceMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &AuthServiceMockCheckSelfOrAdminExpectation{}
	}

	if mmCheckSelfOrAdmin.defaultExpectation.params != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Expect")
	}

	if mmCheckSelfOrAdmin.defaultExpectation.paramPtrs == nil {
		mmCheckSelfOrAdmin.defaultExpectation.paramPtrs = &AuthServiceMockCheckSelfOrAdminParamPtrs{}
	}
	mmCheckSelfOrAdmin.defaultExpectation.paramPtrs.targetUserID = &targetUserID
	mmCheckSelfOrAdmin.defaultExpectation.expectationOrigins.originTargetUserID = minimock.CallerInfo(1)

	return mmCheckSelfOrAdmin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Inspect(f func(ctx context.Context, targetUserID uuid.UUID)) *mAuthServiceMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.inspectFuncCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.CheckSelfOrAdmin")
	}

	mmCheckSelfOrAdmin.mock.inspectFuncCheckSelfOrAdmin = f

	return mmCheckSelfOrAdmin
}

// Return sets up results that will be returned by AuthService.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Return(err error) *AuthServiceMock {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &AuthServiceMockCheckSelfOrAdminExpectation{mock: mmCheckSelfOrAdmin.mock}
	}
	mmCheckSelfOrAdmin.defaultExpectation.results = &AuthServiceMockCheckSelfOrAdminResults{err}
	mmCheckSelfOrAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckSelfOrAdmin.mock
}

// Set uses given function f to mock the AuthService.CheckSelfOrAdmin method
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Set(f func(ctx context.Context, targetUserID uuid.UUID) (err error)) *AuthServiceMock {
	if mmCheckSelfOrAdmin.defaultExpectation != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Default expectation is already set for the AuthService.CheckSelfOrAdmin method")
	}

	if len(mmCheckSelfOrAdmin.expectations) > 0 {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Some expectations are already set for the AuthService.CheckSelfOrAdmin method")
	}

	mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin = f
	mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdminOrigin = minimock.CallerInfo(1)
	return mmCheckSelfOrAdmin.mock
}

// When sets expectation for the AuthService.CheckSelfOrAdmin which will trigger the result defined by the following
// Then helper
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) When(ctx context.Context, targetUserID uuid.UUID) *AuthServiceMockCheckSelfOrAdminExpectation {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("AuthServiceMock.CheckSelfOrAdmin mock is already set by Set")
	}

	expectation := &AuthServiceMockCheckSelfOrAdminExpectation{
		mock:               mmCheckSelfOrAdmin.mock,
		params:             &AuthServiceMockCheckSelfOrAdminParams{ctx, targetUserID},
		expectationOrigins: AuthServiceMockCheckSelfOrAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckSelfOrAdmin.expectations = append(mmCheckSelfOrAdmin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.CheckSelfOrAdmin return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockCheckSelfOrAdminExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockCheckSelfOrAdminResults{err}
	return e.mock
}

// Times sets number of times AuthService.CheckSelfOrAdmin should be invoked
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Times(n uint64) *mAuthServiceMockCheckSelfOrAdmin {
	if n == 0 {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Times of AuthServiceMock.CheckSelfOrAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckSelfOrAdmin.expectedInvocations, n)
	mmCheckSelfOrAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckSelfOrAdmin
}

func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) invocationsDone() bool {
	if len(mmCheckSelfOrAdmin.expectations) == 0 && mmCheckSelfOrAdmin.defaultExpectation == nil && mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.mock.afterCheckSelfOrAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckSelfOrAdmin implements mm_usecase.AuthService
func (mmCheckSelfOrAdmin *AuthServiceMock) CheckSelfOrAdmin(ctx context.Context, targetUserID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCheckSelfOrAdmin.beforeCheckSelfOrAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckSelfOrAdmin.afterCheckSelfOrAdminCounter, 1)

	mmCheckSelfOrAdmin.t.Helper()

	if mmCheckSelfOrAdmin.inspectFuncCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.inspectFuncCheckSelfOrAdmin(ctx, targetUserID)
	}

	mm_params := AuthServiceMockCheckSelfOrAdminParams{ctx, targetUserID}

	// Record call args
	mmCheckSelfOrAdmin.CheckSelfOrAdminMock.mutex.Lock()
	mmCheckSelfOrAdmin.CheckSelfOrAdminMock.callArgs = append(mmCheckSelfOrAdmin.CheckSelfOrAdminMock.callArgs, &mm_params)
	mmCheckSelfOrAdmin.CheckSelfOrAdminMock.mutex.Unlock()

	for _, e := range mmCheckSelfOrAdmin.CheckSelfOrAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.params
		mm_want_ptrs := mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockCheckSelfOrAdminParams{ctx, targetUserID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckSelfOrAdmin.t.Errorf("AuthServiceMock.CheckSelfOrAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.targetUserID != nil && !minimock.Equal(*mm_want_ptrs.targetUserID, mm_got.targetUserID) {
				mmCheckSelfOrAdmin.t.Errorf("AuthServiceMock.CheckSelfOrAdmin got unexpected parameter targetUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.originTargetUserID, *mm_want_ptrs.targetUserID, mm_got.targetUserID, minimock.Diff(*mm_want_ptrs.targetUserID, mm_got.targetUserID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckSelfOrAdmin.t.Errorf("AuthServiceMock.CheckSelfOrAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckSelfOrAdmin.t.Fatal("No results are set for the AuthServiceMock.CheckSelfOrAdmin")
		}
		return (*mm_results).err
	}
	if mmCheckSelfOrAdmin.funcCheckSelfOrAdmin != nil {
		return mmCheckSelfOrAdmin.funcCheckSelfOrAdmin(ctx, targetUserID)
	}
	mmCheckSelfOrAdmin.t.Fatalf("Unexpected call to AuthServiceMock.CheckSelfOrAdmin. %v %v", ctx, targetUserID)
	return
}

// CheckSelfOrAdminAfterCounter returns a count of finished AuthServiceMock.CheckSelfOrAdmin invocations
func (mmCheckSelfOrAdmin *AuthServiceMock) CheckSelfOrAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.afterCheckSelfOrAdminCounter)
}

// CheckSelfOrAdminBeforeCounter returns a count of AuthServiceMock.CheckSelfOrAdmin invocations
func (mmCheckSelfOrAdmin *AuthServiceMock) CheckSelfOrAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.beforeCheckSelfOrAdminCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.CheckSelfOrAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckSelfOrAdmin *mAuthServiceMockCheckSelfOrAdmin) Calls() []*AuthServiceMockCheckSelfOrAdminParams {
	mmCheckSelfOrAdmin.mutex.RLock()

	argCopy := make([]*AuthServiceMockCheckSelfOrAdminParams, len(mmCheckSelfOrAdmin.callArgs))
	copy(argCopy, mmCheckSelfOrAdmin.callArgs)

	mmCheckSelfOrAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockCheckSelfOrAdminDone returns true if the count of the CheckSelfOrAdmin invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockCheckSelfOrAdminDone() bool {
	if m.CheckSelfOrAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckSelfOrAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckSelfOrAdminMock.invocationsDone()
}

// MinimockCheckSelfOrAdminInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockCheckSelfOrAdminInspect() {
	for _, e := range m.CheckSelfOrAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.CheckSelfOrAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckSelfOrAdminCounter := mm_atomic.LoadUint64(&m.afterCheckSelfOrAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckSelfOrAdminMock.defaultExpectation != nil && afterCheckSelfOrAdminCounter < 1 {
		if m.CheckSelfOrAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.CheckSelfOrAdmin at\n%s", m.CheckSelfOrAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.CheckSelfOrAdmin at\n%s with params: %#v", m.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.origin, *m.CheckSelfOrAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckSelfOrAdmin != nil && afterCheckSelfOrAdminCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.CheckSelfOrAdmin at\n%s", m.funcCheckSelfOrAdminOrigin)
	}

	if !m.CheckSelfOrAdminMock.invocationsDone() && afterCheckSelfOrAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.CheckSelfOrAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckSelfOrAdminMock.expectedInvocations), m.CheckSelfOrAdminMock.expectedInvocationsOrigin, afterCheckSelfOrAdminCounter)
	}
}

type mAuthServiceMockDeleteSessionsByUserID struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockDeleteSessionsByUserIDExpectation
	expectations       []*AuthServiceMockDeleteSessionsByUserIDExpectation

	callArgs []*AuthServiceMockDeleteSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockDeleteSessionsByUserIDExpectation specifies expectation struct of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockDeleteSessionsByUserIDParams
	paramPtrs          *AuthServiceMockDeleteSessionsByUserIDParamPtrs
	expectationOrigins AuthServiceMockDeleteSessionsByUserIDExpectationOrigins
	results            *AuthServiceMockDeleteSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockDeleteSessionsByUserIDParams contains parameters of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// AuthServiceMockDeleteSessionsByUserIDParamPtrs contains pointers to parameters of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// AuthServiceMockDeleteSessionsByUserIDResults contains results of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDResults struct {
	err error
}

// AuthServiceMockDeleteSessionsByUserIDOrigins contains origins of expectations of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Optional() *mAuthServiceMockDeleteSessionsByUserID {
	mmDeleteSessionsByUserID.optional = true
	return mmDeleteSessionsByUserID
}

// Expect sets up expected params for AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteSessionsByUserID.defaultExpectation.params = &AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID}
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteSessionsByUserID.defaultExpectation.params) {
			mmDeleteSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.DeleteSessionsByUserID")
	}

	mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID = f

	return mmDeleteSessionsByUserID
}

// Return sets up results that will be returned by AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Return(err error) *AuthServiceMock {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{mock: mmDeleteSessionsByUserID.mock}
	}
	mmDeleteSessionsByUserID.defaultExpectation.results = &AuthServiceMockDeleteSessionsByUserIDResults{err}
	mmDeleteSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// Set uses given function f to mock the AuthService.DeleteSessionsByUserID method
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (err error)) *AuthServiceMock {
	if mmDeleteSessionsByUserID.defaultExpectation != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the AuthService.DeleteSessionsByUserID method")
	}

	if len(mmDeleteSessionsByUserID.expectations) > 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the AuthService.DeleteSessionsByUserID method")
	}

	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID = f
	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// When sets expectation for the AuthService.DeleteSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *AuthServiceMockDeleteSessionsByUserIDExpectation {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	expectation := &AuthServiceMockDeleteSessionsByUserIDExpectation{
		mock:               mmDeleteSessionsByUserID.mock,
		params:             &AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID},
		expectationOrigins: AuthServiceMockDeleteSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSessionsByUserID.expectations = append(mmDeleteSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up AuthService.DeleteSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockDeleteSessionsByUserIDExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockDeleteSessionsByUserIDResults{err}
	return e.mock
}

// Times sets number of times AuthService.DeleteSessionsByUserID should be invoked
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Times(n uint64) *mAuthServiceMockDeleteSessionsByUserID {
	if n == 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Times of AuthServiceMock.DeleteSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSessionsByUserID.expectedInvocations, n)
	mmDeleteSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID
}

func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) invocationsDone() bool {
	if len(mmDeleteSessionsByUserID.expectations) == 0 && mmDeleteSessionsByUserID.defaultExpectation == nil && mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.mock.afterDeleteSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSessionsByUserID implements mm_usecase.AuthService
func (mmDeleteSessionsByUserID *AuthServiceMock) DeleteSessionsByUserID(ctx context.Context, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter, 1)

	mmDeleteSessionsByUserID.t.Helper()

	if mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID(ctx, userID)
	}

	mm_params := AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Lock()
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs = append(mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs, &mm_params)
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSessionsByUserID.t.Errorf("AuthServiceMock.DeleteSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSessionsByUserID.t.Errorf("AuthServiceMock.DeleteSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSessionsByUserID.t.Errorf("AuthServiceMock.DeleteSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSessionsByUserID.t.Fatal("No results are set for the AuthServiceMock.DeleteSessionsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteSessionsByUserID.funcDeleteSessionsByUserID != nil {
		return mmDeleteSessionsByUserID.funcDeleteSessionsByUserID(ctx, userID)
	}
	mmDeleteSessionsByUserID.t.Fatalf("Unexpected call to AuthServiceMock.DeleteSessionsByUserID. %v %v", ctx, userID)
	return
}

// DeleteSessionsByUserIDAfterCounter returns a count of finished AuthServiceMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *AuthServiceMock) DeleteSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter)
}

// DeleteSessionsByUserIDBeforeCounter returns a count of AuthServiceMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *AuthServiceMock) DeleteSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.DeleteSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Calls() []*AuthServiceMockDeleteSessionsByUserIDParams {
	mmDeleteSessionsByUserID.mutex.RLock()

	argCopy := make([]*AuthServiceMockDeleteSessionsByUserIDParams, len(mmDeleteSessionsByUserID.callArgs))
	copy(argCopy, mmDeleteSessionsByUserID.callArgs)

	mmDeleteSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionsByUserIDDone returns true if the count of the DeleteSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockDeleteSessionsByUserIDDone() bool {
	if m.DeleteSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionsByUserIDMock.invocationsDone()
}

// MinimockDeleteSessionsByUserIDInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockDeleteSessionsByUserIDInspect() {
	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionsByUserIDMock.defaultExpectation != nil && afterDeleteSessionsByUserIDCounter < 1 {
		if m.DeleteSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s", m.DeleteSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s with params: %#v", m.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSessionsByUserID != nil && afterDeleteSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s", m.funcDeleteSessionsByUserIDOrigin)
	}

	if !m.DeleteSessionsByUserIDMock.invocationsDone() && afterDeleteSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.DeleteSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionsByUserIDMock.expectedInvocations), m.DeleteSessionsByUserIDMock.expectedInvocationsOrigin, afterDeleteSessionsByUserIDCounter)
	}
}

type mAuthServiceMockIsAdmin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockIsAdminExpectation
	expectations       []*AuthServiceMockIsAdminExpectation

	callArgs []*AuthServiceMockIsAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockIsAdminExpectation specifies expectation struct of the AuthService.IsAdmin
type AuthServiceMockIsAdminExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockIsAdminParams
	paramPtrs          *AuthServiceMockIsAdminParamPtrs
	expectationOrigins AuthServiceMockIsAdminExpectationOrigins
	results            *AuthServiceMockIsAdminResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockIsAdminParams contains parameters of the AuthService.IsAdmin
type AuthServiceMockIsAdminParams struct {
	ctx context.Context
}

// AuthServiceMockIsAdminParamPtrs contains pointers to parameters of the AuthService.IsAdmin
type AuthServiceMockIsAdminParamPtrs struct {
	ctx *context.Context
}

// AuthServiceMockIsAdminResults contains results of the AuthService.IsAdmin
type AuthServiceMockIsAdminResults struct {
	b1  bool
	err error
}

// AuthServiceMockIsAdminOrigins contains origins of expectations of the AuthService.IsAdmin
type AuthServiceMockIsAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAdmin *mAuthServiceMockIsAdmin) Optional() *mAuthServiceMockIsAdmin {
	mmIsAdmin.optional = true
	return mmIsAdmin
}

// Expect sets up expected params for AuthService.IsAdmin
func (mmIsAdmin *mAuthServiceMockIsAdmin) Expect(ctx context.Context) *mAuthServiceMockIsAdmin {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("AuthServiceMock.IsAdmin mock is already set by Set")
	}

	if mmIsAdmin.defaultExpectation == nil {
		mmIsAdmin.defaultExpectation = &AuthServiceMockIsAdminExpectation{}
	}

	if mmIsAdmin.defaultExpectation.paramPtrs != nil {
		mmIsAdmin.mock.t.Fatalf("AuthServiceMock.IsAdmin mock is already set by ExpectParams functions")
	}

	mmIsAdmin.defaultExpectation.params = &AuthServiceMockIsAdminParams{ctx}
	mmIsAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsAdmin.expectations {
		if minimock.Equal(e.params, mmIsAdmin.defaultExpectation.params) {
			mmIsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsAdmin.defaultExpectation.params)
		}
	}

	return mmIsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.IsAdmin
func (mmIsAdmin *mAuthServiceMockIsAdmin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockIsAdmin {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("AuthServiceMock.IsAdmin mock is already set by Set")
	}

	if mmIsAdmin.defaultExpectation == nil {
		mmIsAdmin.defaultExpectation = &AuthServiceMockIsAdminExpectation{}
	}

	if mmIsAdmin.defaultExpectation.params != nil {
		mmIsAdmin.mock.t.Fatalf("AuthServiceMock.IsAdmin mock is already set by Expect")
	}

	if mmIsAdmin.defaultExpectation.paramPtrs == nil {
		mmIsAdmin.defaultExpectation.paramPtrs = &AuthServiceMockIsAdminParamPtrs{}
	}
	mmIsAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsAdmin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.IsAdmin
func (mmIsAdmin *mAuthServiceMockIsAdmin) Inspect(f func(ctx context.Context)) *mAuthServiceMockIsAdmin {
	if mmIsAdmin.mock.inspectFuncIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.IsAdmin")
	}

	mmIsAdmin.mock.inspectFuncIsAdmin = f

	return mmIsAdmin
}

// Return sets up results that will be returned by AuthService.IsAdmin
func (mmIsAdmin *mAuthServiceMockIsAdmin) Return(b1 bool, err error) *AuthServiceMock {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("AuthServiceMock.IsAdmin mock is already set by Set")
	}

	if mmIsAdmin.defaultExpectation == nil {
		mmIsAdmin.defaultExpectation = &AuthServiceMockIsAdminExpectation{mock: mmIsAdmin.mock}
	}
	mmIsAdmin.defaultExpectation.results = &AuthServiceMockIsAdminResults{b1, err}
	mmIsAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAdmin.mock
}

// Set uses given function f to mock the AuthService.IsAdmin method
func (mmIsAdmin *mAuthServiceMockIsAdmin) Set(f func(ctx context.Context) (b1 bool, err error)) *AuthServiceMock {
	if mmIsAdmin.defaultExpectation != nil {
		mmIsAdmin.mock.t.Fatalf("Default expectation is already set for the AuthService.IsAdmin method")
	}

	if len(mmIsAdmin.expectations) > 0 {
		mmIsAdmin.mock.t.Fatalf("Some expectations are already set for the AuthService.IsAdmin method")
	}

	mmIsAdmin.mock.funcIsAdmin = f
	mmIsAdmin.mock.funcIsAdminOrigin = minimock.CallerInfo(1)
	return mmIsAdmin.mock
}

// When sets expectation for the AuthService.IsAdmin which will trigger the result defined by the following
// Then helper
func (mmIsAdmin *mAuthServiceMockIsAdmin) When(ctx context.Context) *AuthServiceMockIsAdminExpectation {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("AuthServiceMock.IsAdmin mock is already set by Set")
	}

	expectation := &AuthServiceMockIsAdminExpectation{
		mock:               mmIsAdmin.mock,
		params:             &AuthServiceMockIsAdminParams{ctx},
		expectationOrigins: AuthServiceMockIsAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsAdmin.expectations = append(mmIsAdmin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.IsAdmin return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockIsAdminExpectation) Then(b1 bool, err error) *AuthServiceMock {
	e.results = &AuthServiceMockIsAdminResults{b1, err}
	return e.mock
}

// Times sets number of times AuthService.IsAdmin should be invoked
func (mmIsAdmin *mAuthServiceMockIsAdmin) Times(n uint64) *mAuthServiceMockIsAdmin {
	if n == 0 {
		mmIsAdmin.mock.t.Fatalf("Times of AuthServiceMock.IsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAdmin.expectedInvocations, n)
	mmIsAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAdmin
}

func (mmIsAdmin *mAuthServiceMockIsAdmin) invocationsDone() bool {
	if len(mmIsAdmin.expectations) == 0 && mmIsAdmin.defaultExpectation == nil && mmIsAdmin.mock.funcIsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAdmin.mock.afterIsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAdmin implements mm_usecase.AuthService
func (mmIsAdmin *AuthServiceMock) IsAdmin(ctx context.Context) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsAdmin.beforeIsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAdmin.afterIsAdminCounter, 1)

	mmIsAdmin.t.Helper()

	if mmIsAdmin.inspectFuncIsAdmin != nil {
		mmIsAdmin.inspectFuncIsAdmin(ctx)
	}

	mm_params := AuthServiceMockIsAdminParams{ctx}

	// Record call args
	mmIsAdmin.IsAdminMock.mutex.Lock()
	mmIsAdmin.IsAdminMock.callArgs = append(mmIsAdmin.IsAdminMock.callArgs, &mm_params)
	mmIsAdmin.IsAdminMock.mutex.Unlock()

	for _, e := range mmIsAdmin.IsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsAdmin.IsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAdmin.IsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmIsAdmin.IsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmIsAdmin.IsAdminMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockIsAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsAdmin.t.Errorf("AuthServiceMock.IsAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAdmin.IsAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsAdmin.t.Errorf("AuthServiceMock.IsAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsAdmin.IsAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsAdmin.IsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAdmin.t.Fatal("No results are set for the AuthServiceMock.IsAdmin")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsAdmin.funcIsAdmin != nil {
		return mmIsAdmin.funcIsAdmin(ctx)
	}
	mmIsAdmin.t.Fatalf("Unexpected call to AuthServiceMock.IsAdmin. %v", ctx)
	return
}

// IsAdminAfterCounter returns a count of finished AuthServiceMock.IsAdmin invocations
func (mmIsAdmin *AuthServiceMock) IsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAdmin.afterIsAdminCounter)
}

// IsAdminBeforeCounter returns a count of AuthServiceMock.IsAdmin invocations
func (mmIsAdmin *AuthServiceMock) IsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAdmin.beforeIsAdminCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.IsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsAdmin *mAuthServiceMockIsAdmin) Calls() []*AuthServiceMockIsAdminParams {
	mmIsAdmin.mutex.RLock()

	argCopy := make([]*AuthServiceMockIsAdminParams, len(mmIsAdmin.callArgs))
	copy(argCopy, mmIsAdmin.callArgs)

	mmIsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockIsAdminDone returns true if the count of the IsAdmin invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockIsAdminDone() bool {
	if m.IsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAdminMock.invocationsDone()
}

// MinimockIsAdminInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockIsAdminInspect() {
	for _, e := range m.IsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.IsAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsAdminCounter := mm_atomic.LoadUint64(&m.afterIsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAdminMock.defaultExpectation != nil && afterIsAdminCounter < 1 {
		if m.IsAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.IsAdmin at\n%s", m.IsAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.IsAdmin at\n%s with params: %#v", m.IsAdminMock.defaultExpectation.expectationOrigins.origin, *m.IsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAdmin != nil && afterIsAdminCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.IsAdmin at\n%s", m.funcIsAdminOrigin)
	}

	if !m.IsAdminMock.invocationsDone() && afterIsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.IsAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAdminMock.expectedInvocations), m.IsAdminMock.expectedInvocationsOrigin, afterIsAdminCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckIsAdminInspect()

			m.MinimockCheckSelfInspect()

			m.MinimockCheckSelfOrAdminInspect()

			m.MinimockDeleteSessionsByUserIDInspect()

			m.MinimockIsAdminInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckIsAdminDone() &&
		m.MinimockCheckSelfDone() &&
		m.MinimockCheckSelfOrAdminDone() &&
		m.MinimockDeleteSessionsByUserIDDone() &&
		m.MinimockIsAdminDone()
}
