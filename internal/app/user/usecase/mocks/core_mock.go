// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/user/usecase.Core -o core_mock.go -n CoreMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/user"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// CoreMock implements mm_usecase.Core
type CoreMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangePassword          func(ctx context.Context, id uuid.UUID, newPassword []byte) (err error)
	funcChangePasswordOrigin    string
	inspectFuncChangePassword   func(ctx context.Context, id uuid.UUID, newPassword []byte)
	afterChangePasswordCounter  uint64
	beforeChangePasswordCounter uint64
	ChangePasswordMock          mCoreMockChangePassword

	funcCreateUser          func(ctx context.Context, req user.CreateUserReq) (u1 uuid.UUID, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, req user.CreateUserReq)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mCoreMockCreateUser

	funcDeleteUser          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id uuid.UUID)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mCoreMockDeleteUser

	funcGetAllUsers          func(ctx context.Context) (ua1 []user.User, err error)
	funcGetAllUsersOrigin    string
	inspectFuncGetAllUsers   func(ctx context.Context)
	afterGetAllUsersCounter  uint64
	beforeGetAllUsersCounter uint64
	GetAllUsersMock          mCoreMockGetAllUsers

	funcGetUser          func(ctx context.Context, id uuid.UUID) (u1 user.User, s1 string, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id uuid.UUID)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mCoreMockGetUser

	funcUpdateUser          func(ctx context.Context, req user.UpdateUserReq) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, req user.UpdateUserReq)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mCoreMockUpdateUser
}

// NewCoreMock returns a mock for mm_usecase.Core
func NewCoreMock(t minimock.Tester) *CoreMock {
	m := &CoreMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangePasswordMock = mCoreMockChangePassword{mock: m}
	m.ChangePasswordMock.callArgs = []*CoreMockChangePasswordParams{}

	m.CreateUserMock = mCoreMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*CoreMockCreateUserParams{}

	m.DeleteUserMock = mCoreMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*CoreMockDeleteUserParams{}

	m.GetAllUsersMock = mCoreMockGetAllUsers{mock: m}
	m.GetAllUsersMock.callArgs = []*CoreMockGetAllUsersParams{}

	m.GetUserMock = mCoreMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*CoreMockGetUserParams{}

	m.UpdateUserMock = mCoreMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*CoreMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCoreMockChangePassword struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockChangePasswordExpectation
	expectations       []*CoreMockChangePasswordExpectation

	callArgs []*CoreMockChangePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockChangePasswordExpectation specifies expectation struct of the Core.ChangePassword
type CoreMockChangePasswordExpectation struct {
	mock               *CoreMock
	params             *CoreMockChangePasswordParams
	paramPtrs          *CoreMockChangePasswordParamPtrs
	expectationOrigins CoreMockChangePasswordExpectationOrigins
	results            *CoreMockChangePasswordResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockChangePasswordParams contains parameters of the Core.ChangePassword
type CoreMockChangePasswordParams struct {
	ctx         context.Context
	id          uuid.UUID
	newPassword []byte
}

// CoreMockChangePasswordParamPtrs contains pointers to parameters of the Core.ChangePassword
type CoreMockChangePasswordParamPtrs struct {
	ctx         *context.Context
	id          *uuid.UUID
	newPassword *[]byte
}

// CoreMockChangePasswordResults contains results of the Core.ChangePassword
type CoreMockChangePasswordResults struct {
	err error
}

// CoreMockChangePasswordOrigins contains origins of expectations of the Core.ChangePassword
type CoreMockChangePasswordExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originNewPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangePassword *mCoreMockChangePassword) Optional() *mCoreMockChangePassword {
	mmChangePassword.optional = true
	return mmChangePassword
}

// Expect sets up expected params for Core.ChangePassword
func (mmChangePassword *mCoreMockChangePassword) Expect(ctx context.Context, id uuid.UUID, newPassword []byte) *mCoreMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &CoreMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.paramPtrs != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by ExpectParams functions")
	}

	mmChangePassword.defaultExpectation.params = &CoreMockChangePasswordParams{ctx, id, newPassword}
	mmChangePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChangePassword.expectations {
		if minimock.Equal(e.params, mmChangePassword.defaultExpectation.params) {
			mmChangePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangePassword.defaultExpectation.params)
		}
	}

	return mmChangePassword
}

// ExpectCtxParam1 sets up expected param ctx for Core.ChangePassword
func (mmChangePassword *mCoreMockChangePassword) ExpectCtxParam1(ctx context.Context) *mCoreMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &CoreMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &CoreMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.ctx = &ctx
	mmChangePassword.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChangePassword
}

// ExpectIdParam2 sets up expected param id for Core.ChangePassword
func (mmChangePassword *mCoreMockChangePassword) ExpectIdParam2(id uuid.UUID) *mCoreMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &CoreMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &CoreMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.id = &id
	mmChangePassword.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmChangePassword
}

// ExpectNewPasswordParam3 sets up expected param newPassword for Core.ChangePassword
func (mmChangePassword *mCoreMockChangePassword) ExpectNewPasswordParam3(newPassword []byte) *mCoreMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &CoreMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &CoreMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.newPassword = &newPassword
	mmChangePassword.defaultExpectation.expectationOrigins.originNewPassword = minimock.CallerInfo(1)

	return mmChangePassword
}

// Inspect accepts an inspector function that has same arguments as the Core.ChangePassword
func (mmChangePassword *mCoreMockChangePassword) Inspect(f func(ctx context.Context, id uuid.UUID, newPassword []byte)) *mCoreMockChangePassword {
	if mmChangePassword.mock.inspectFuncChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("Inspect function is already set for CoreMock.ChangePassword")
	}

	mmChangePassword.mock.inspectFuncChangePassword = f

	return mmChangePassword
}

// Return sets up results that will be returned by Core.ChangePassword
func (mmChangePassword *mCoreMockChangePassword) Return(err error) *CoreMock {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &CoreMockChangePasswordExpectation{mock: mmChangePassword.mock}
	}
	mmChangePassword.defaultExpectation.results = &CoreMockChangePasswordResults{err}
	mmChangePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChangePassword.mock
}

// Set uses given function f to mock the Core.ChangePassword method
func (mmChangePassword *mCoreMockChangePassword) Set(f func(ctx context.Context, id uuid.UUID, newPassword []byte) (err error)) *CoreMock {
	if mmChangePassword.defaultExpectation != nil {
		mmChangePassword.mock.t.Fatalf("Default expectation is already set for the Core.ChangePassword method")
	}

	if len(mmChangePassword.expectations) > 0 {
		mmChangePassword.mock.t.Fatalf("Some expectations are already set for the Core.ChangePassword method")
	}

	mmChangePassword.mock.funcChangePassword = f
	mmChangePassword.mock.funcChangePasswordOrigin = minimock.CallerInfo(1)
	return mmChangePassword.mock
}

// When sets expectation for the Core.ChangePassword which will trigger the result defined by the following
// Then helper
func (mmChangePassword *mCoreMockChangePassword) When(ctx context.Context, id uuid.UUID, newPassword []byte) *CoreMockChangePasswordExpectation {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("CoreMock.ChangePassword mock is already set by Set")
	}

	expectation := &CoreMockChangePasswordExpectation{
		mock:               mmChangePassword.mock,
		params:             &CoreMockChangePasswordParams{ctx, id, newPassword},
		expectationOrigins: CoreMockChangePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChangePassword.expectations = append(mmChangePassword.expectations, expectation)
	return expectation
}

// Then sets up Core.ChangePassword return parameters for the expectation previously defined by the When method
func (e *CoreMockChangePasswordExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockChangePasswordResults{err}
	return e.mock
}

// Times sets number of times Core.ChangePassword should be invoked
func (mmChangePassword *mCoreMockChangePassword) Times(n uint64) *mCoreMockChangePassword {
	if n == 0 {
		mmChangePassword.mock.t.Fatalf("Times of CoreMock.ChangePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangePassword.expectedInvocations, n)
	mmChangePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChangePassword
}

func (mmChangePassword *mCoreMockChangePassword) invocationsDone() bool {
	if len(mmChangePassword.expectations) == 0 && mmChangePassword.defaultExpectation == nil && mmChangePassword.mock.funcChangePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangePassword.mock.afterChangePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangePassword implements mm_usecase.Core
func (mmChangePassword *CoreMock) ChangePassword(ctx context.Context, id uuid.UUID, newPassword []byte) (err error) {
	mm_atomic.AddUint64(&mmChangePassword.beforeChangePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmChangePassword.afterChangePasswordCounter, 1)

	mmChangePassword.t.Helper()

	if mmChangePassword.inspectFuncChangePassword != nil {
		mmChangePassword.inspectFuncChangePassword(ctx, id, newPassword)
	}

	mm_params := CoreMockChangePasswordParams{ctx, id, newPassword}

	// Record call args
	mmChangePassword.ChangePasswordMock.mutex.Lock()
	mmChangePassword.ChangePasswordMock.callArgs = append(mmChangePassword.ChangePasswordMock.callArgs, &mm_params)
	mmChangePassword.ChangePasswordMock.mutex.Unlock()

	for _, e := range mmChangePassword.ChangePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangePassword.ChangePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangePassword.ChangePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmChangePassword.ChangePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmChangePassword.ChangePasswordMock.defaultExpectation.paramPtrs

		mm_got := CoreMockChangePasswordParams{ctx, id, newPassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangePassword.t.Errorf("CoreMock.ChangePassword got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmChangePassword.t.Errorf("CoreMock.ChangePassword got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newPassword != nil && !minimock.Equal(*mm_want_ptrs.newPassword, mm_got.newPassword) {
				mmChangePassword.t.Errorf("CoreMock.ChangePassword got unexpected parameter newPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originNewPassword, *mm_want_ptrs.newPassword, mm_got.newPassword, minimock.Diff(*mm_want_ptrs.newPassword, mm_got.newPassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangePassword.t.Errorf("CoreMock.ChangePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangePassword.ChangePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmChangePassword.t.Fatal("No results are set for the CoreMock.ChangePassword")
		}
		return (*mm_results).err
	}
	if mmChangePassword.funcChangePassword != nil {
		return mmChangePassword.funcChangePassword(ctx, id, newPassword)
	}
	mmChangePassword.t.Fatalf("Unexpected call to CoreMock.ChangePassword. %v %v %v", ctx, id, newPassword)
	return
}

// ChangePasswordAfterCounter returns a count of finished CoreMock.ChangePassword invocations
func (mmChangePassword *CoreMock) ChangePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePassword.afterChangePasswordCounter)
}

// ChangePasswordBeforeCounter returns a count of CoreMock.ChangePassword invocations
func (mmChangePassword *CoreMock) ChangePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePassword.beforeChangePasswordCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.ChangePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangePassword *mCoreMockChangePassword) Calls() []*CoreMockChangePasswordParams {
	mmChangePassword.mutex.RLock()

	argCopy := make([]*CoreMockChangePasswordParams, len(mmChangePassword.callArgs))
	copy(argCopy, mmChangePassword.callArgs)

	mmChangePassword.mutex.RUnlock()

	return argCopy
}

// MinimockChangePasswordDone returns true if the count of the ChangePassword invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockChangePasswordDone() bool {
	if m.ChangePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangePasswordMock.invocationsDone()
}

// MinimockChangePasswordInspect logs each unmet expectation
func (m *CoreMock) MinimockChangePasswordInspect() {
	for _, e := range m.ChangePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.ChangePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChangePasswordCounter := mm_atomic.LoadUint64(&m.afterChangePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangePasswordMock.defaultExpectation != nil && afterChangePasswordCounter < 1 {
		if m.ChangePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.ChangePassword at\n%s", m.ChangePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.ChangePassword at\n%s with params: %#v", m.ChangePasswordMock.defaultExpectation.expectationOrigins.origin, *m.ChangePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangePassword != nil && afterChangePasswordCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.ChangePassword at\n%s", m.funcChangePasswordOrigin)
	}

	if !m.ChangePasswordMock.invocationsDone() && afterChangePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.ChangePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChangePasswordMock.expectedInvocations), m.ChangePasswordMock.expectedInvocationsOrigin, afterChangePasswordCounter)
	}
}

type mCoreMockCreateUser struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockCreateUserExpectation
	expectations       []*CoreMockCreateUserExpectation

	callArgs []*CoreMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockCreateUserExpectation specifies expectation struct of the Core.CreateUser
type CoreMockCreateUserExpectation struct {
	mock               *CoreMock
	params             *CoreMockCreateUserParams
	paramPtrs          *CoreMockCreateUserParamPtrs
	expectationOrigins CoreMockCreateUserExpectationOrigins
	results            *CoreMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockCreateUserParams contains parameters of the Core.CreateUser
type CoreMockCreateUserParams struct {
	ctx context.Context
	req user.CreateUserReq
}

// CoreMockCreateUserParamPtrs contains pointers to parameters of the Core.CreateUser
type CoreMockCreateUserParamPtrs struct {
	ctx *context.Context
	req *user.CreateUserReq
}

// CoreMockCreateUserResults contains results of the Core.CreateUser
type CoreMockCreateUserResults struct {
	u1  uuid.UUID
	err error
}

// CoreMockCreateUserOrigins contains origins of expectations of the Core.CreateUser
type CoreMockCreateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mCoreMockCreateUser) Optional() *mCoreMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Core.CreateUser
func (mmCreateUser *mCoreMockCreateUser) Expect(ctx context.Context, req user.CreateUserReq) *mCoreMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &CoreMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &CoreMockCreateUserParams{ctx, req}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Core.CreateUser
func (mmCreateUser *mCoreMockCreateUser) ExpectCtxParam1(ctx context.Context) *mCoreMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &CoreMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &CoreMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectReqParam2 sets up expected param req for Core.CreateUser
func (mmCreateUser *mCoreMockCreateUser) ExpectReqParam2(req user.CreateUserReq) *mCoreMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &CoreMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &CoreMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.req = &req
	mmCreateUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Core.CreateUser
func (mmCreateUser *mCoreMockCreateUser) Inspect(f func(ctx context.Context, req user.CreateUserReq)) *mCoreMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for CoreMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Core.CreateUser
func (mmCreateUser *mCoreMockCreateUser) Return(u1 uuid.UUID, err error) *CoreMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &CoreMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &CoreMockCreateUserResults{u1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the Core.CreateUser method
func (mmCreateUser *mCoreMockCreateUser) Set(f func(ctx context.Context, req user.CreateUserReq) (u1 uuid.UUID, err error)) *CoreMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Core.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Core.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the Core.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mCoreMockCreateUser) When(ctx context.Context, req user.CreateUserReq) *CoreMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("CoreMock.CreateUser mock is already set by Set")
	}

	expectation := &CoreMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &CoreMockCreateUserParams{ctx, req},
		expectationOrigins: CoreMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Core.CreateUser return parameters for the expectation previously defined by the When method
func (e *CoreMockCreateUserExpectation) Then(u1 uuid.UUID, err error) *CoreMock {
	e.results = &CoreMockCreateUserResults{u1, err}
	return e.mock
}

// Times sets number of times Core.CreateUser should be invoked
func (mmCreateUser *mCoreMockCreateUser) Times(n uint64) *mCoreMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of CoreMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mCoreMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_usecase.Core
func (mmCreateUser *CoreMock) CreateUser(ctx context.Context, req user.CreateUserReq) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, req)
	}

	mm_params := CoreMockCreateUserParams{ctx, req}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := CoreMockCreateUserParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("CoreMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateUser.t.Errorf("CoreMock.CreateUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("CoreMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the CoreMock.CreateUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, req)
	}
	mmCreateUser.t.Fatalf("Unexpected call to CoreMock.CreateUser. %v %v", ctx, req)
	return
}

// CreateUserAfterCounter returns a count of finished CoreMock.CreateUser invocations
func (mmCreateUser *CoreMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of CoreMock.CreateUser invocations
func (mmCreateUser *CoreMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mCoreMockCreateUser) Calls() []*CoreMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*CoreMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *CoreMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mCoreMockDeleteUser struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockDeleteUserExpectation
	expectations       []*CoreMockDeleteUserExpectation

	callArgs []*CoreMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockDeleteUserExpectation specifies expectation struct of the Core.DeleteUser
type CoreMockDeleteUserExpectation struct {
	mock               *CoreMock
	params             *CoreMockDeleteUserParams
	paramPtrs          *CoreMockDeleteUserParamPtrs
	expectationOrigins CoreMockDeleteUserExpectationOrigins
	results            *CoreMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockDeleteUserParams contains parameters of the Core.DeleteUser
type CoreMockDeleteUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockDeleteUserParamPtrs contains pointers to parameters of the Core.DeleteUser
type CoreMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockDeleteUserResults contains results of the Core.DeleteUser
type CoreMockDeleteUserResults struct {
	err error
}

// CoreMockDeleteUserOrigins contains origins of expectations of the Core.DeleteUser
type CoreMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mCoreMockDeleteUser) Optional() *mCoreMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for Core.DeleteUser
func (mmDeleteUser *mCoreMockDeleteUser) Expect(ctx context.Context, id uuid.UUID) *mCoreMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &CoreMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &CoreMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for Core.DeleteUser
func (mmDeleteUser *mCoreMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mCoreMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &CoreMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &CoreMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for Core.DeleteUser
func (mmDeleteUser *mCoreMockDeleteUser) ExpectIdParam2(id uuid.UUID) *mCoreMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &CoreMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &CoreMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Core.DeleteUser
func (mmDeleteUser *mCoreMockDeleteUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for CoreMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Core.DeleteUser
func (mmDeleteUser *mCoreMockDeleteUser) Return(err error) *CoreMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &CoreMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &CoreMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the Core.DeleteUser method
func (mmDeleteUser *mCoreMockDeleteUser) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *CoreMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Core.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Core.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the Core.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mCoreMockDeleteUser) When(ctx context.Context, id uuid.UUID) *CoreMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("CoreMock.DeleteUser mock is already set by Set")
	}

	expectation := &CoreMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &CoreMockDeleteUserParams{ctx, id},
		expectationOrigins: CoreMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Core.DeleteUser return parameters for the expectation previously defined by the When method
func (e *CoreMockDeleteUserExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times Core.DeleteUser should be invoked
func (mmDeleteUser *mCoreMockDeleteUser) Times(n uint64) *mCoreMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of CoreMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mCoreMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_usecase.Core
func (mmDeleteUser *CoreMock) DeleteUser(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := CoreMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := CoreMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("CoreMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("CoreMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("CoreMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the CoreMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to CoreMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished CoreMock.DeleteUser invocations
func (mmDeleteUser *CoreMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of CoreMock.DeleteUser invocations
func (mmDeleteUser *CoreMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mCoreMockDeleteUser) Calls() []*CoreMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*CoreMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *CoreMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mCoreMockGetAllUsers struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetAllUsersExpectation
	expectations       []*CoreMockGetAllUsersExpectation

	callArgs []*CoreMockGetAllUsersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetAllUsersExpectation specifies expectation struct of the Core.GetAllUsers
type CoreMockGetAllUsersExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetAllUsersParams
	paramPtrs          *CoreMockGetAllUsersParamPtrs
	expectationOrigins CoreMockGetAllUsersExpectationOrigins
	results            *CoreMockGetAllUsersResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetAllUsersParams contains parameters of the Core.GetAllUsers
type CoreMockGetAllUsersParams struct {
	ctx context.Context
}

// CoreMockGetAllUsersParamPtrs contains pointers to parameters of the Core.GetAllUsers
type CoreMockGetAllUsersParamPtrs struct {
	ctx *context.Context
}

// CoreMockGetAllUsersResults contains results of the Core.GetAllUsers
type CoreMockGetAllUsersResults struct {
	ua1 []user.User
	err error
}

// CoreMockGetAllUsersOrigins contains origins of expectations of the Core.GetAllUsers
type CoreMockGetAllUsersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllUsers *mCoreMockGetAllUsers) Optional() *mCoreMockGetAllUsers {
	mmGetAllUsers.optional = true
	return mmGetAllUsers
}

// Expect sets up expected params for Core.GetAllUsers
func (mmGetAllUsers *mCoreMockGetAllUsers) Expect(ctx context.Context) *mCoreMockGetAllUsers {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("CoreMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &CoreMockGetAllUsersExpectation{}
	}

	if mmGetAllUsers.defaultExpectation.paramPtrs != nil {
		mmGetAllUsers.mock.t.Fatalf("CoreMock.GetAllUsers mock is already set by ExpectParams functions")
	}

	mmGetAllUsers.defaultExpectation.params = &CoreMockGetAllUsersParams{ctx}
	mmGetAllUsers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllUsers.expectations {
		if minimock.Equal(e.params, mmGetAllUsers.defaultExpectation.params) {
			mmGetAllUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllUsers.defaultExpectation.params)
		}
	}

	return mmGetAllUsers
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetAllUsers
func (mmGetAllUsers *mCoreMockGetAllUsers) ExpectCtxParam1(ctx context.Context) *mCoreMockGetAllUsers {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("CoreMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &CoreMockGetAllUsersExpectation{}
	}

	if mmGetAllUsers.defaultExpectation.params != nil {
		mmGetAllUsers.mock.t.Fatalf("CoreMock.GetAllUsers mock is already set by Expect")
	}

	if mmGetAllUsers.defaultExpectation.paramPtrs == nil {
		mmGetAllUsers.defaultExpectation.paramPtrs = &CoreMockGetAllUsersParamPtrs{}
	}
	mmGetAllUsers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllUsers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllUsers
}

// Inspect accepts an inspector function that has same arguments as the Core.GetAllUsers
func (mmGetAllUsers *mCoreMockGetAllUsers) Inspect(f func(ctx context.Context)) *mCoreMockGetAllUsers {
	if mmGetAllUsers.mock.inspectFuncGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("Inspect function is already set for CoreMock.GetAllUsers")
	}

	mmGetAllUsers.mock.inspectFuncGetAllUsers = f

	return mmGetAllUsers
}

// Return sets up results that will be returned by Core.GetAllUsers
func (mmGetAllUsers *mCoreMockGetAllUsers) Return(ua1 []user.User, err error) *CoreMock {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("CoreMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &CoreMockGetAllUsersExpectation{mock: mmGetAllUsers.mock}
	}
	mmGetAllUsers.defaultExpectation.results = &CoreMockGetAllUsersResults{ua1, err}
	mmGetAllUsers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers.mock
}

// Set uses given function f to mock the Core.GetAllUsers method
func (mmGetAllUsers *mCoreMockGetAllUsers) Set(f func(ctx context.Context) (ua1 []user.User, err error)) *CoreMock {
	if mmGetAllUsers.defaultExpectation != nil {
		mmGetAllUsers.mock.t.Fatalf("Default expectation is already set for the Core.GetAllUsers method")
	}

	if len(mmGetAllUsers.expectations) > 0 {
		mmGetAllUsers.mock.t.Fatalf("Some expectations are already set for the Core.GetAllUsers method")
	}

	mmGetAllUsers.mock.funcGetAllUsers = f
	mmGetAllUsers.mock.funcGetAllUsersOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers.mock
}

// When sets expectation for the Core.GetAllUsers which will trigger the result defined by the following
// Then helper
func (mmGetAllUsers *mCoreMockGetAllUsers) When(ctx context.Context) *CoreMockGetAllUsersExpectation {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("CoreMock.GetAllUsers mock is already set by Set")
	}

	expectation := &CoreMockGetAllUsersExpectation{
		mock:               mmGetAllUsers.mock,
		params:             &CoreMockGetAllUsersParams{ctx},
		expectationOrigins: CoreMockGetAllUsersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllUsers.expectations = append(mmGetAllUsers.expectations, expectation)
	return expectation
}

// Then sets up Core.GetAllUsers return parameters for the expectation previously defined by the When method
func (e *CoreMockGetAllUsersExpectation) Then(ua1 []user.User, err error) *CoreMock {
	e.results = &CoreMockGetAllUsersResults{ua1, err}
	return e.mock
}

// Times sets number of times Core.GetAllUsers should be invoked
func (mmGetAllUsers *mCoreMockGetAllUsers) Times(n uint64) *mCoreMockGetAllUsers {
	if n == 0 {
		mmGetAllUsers.mock.t.Fatalf("Times of CoreMock.GetAllUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllUsers.expectedInvocations, n)
	mmGetAllUsers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers
}

func (mmGetAllUsers *mCoreMockGetAllUsers) invocationsDone() bool {
	if len(mmGetAllUsers.expectations) == 0 && mmGetAllUsers.defaultExpectation == nil && mmGetAllUsers.mock.funcGetAllUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllUsers.mock.afterGetAllUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllUsers implements mm_usecase.Core
func (mmGetAllUsers *CoreMock) GetAllUsers(ctx context.Context) (ua1 []user.User, err error) {
	mm_atomic.AddUint64(&mmGetAllUsers.beforeGetAllUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllUsers.afterGetAllUsersCounter, 1)

	mmGetAllUsers.t.Helper()

	if mmGetAllUsers.inspectFuncGetAllUsers != nil {
		mmGetAllUsers.inspectFuncGetAllUsers(ctx)
	}

	mm_params := CoreMockGetAllUsersParams{ctx}

	// Record call args
	mmGetAllUsers.GetAllUsersMock.mutex.Lock()
	mmGetAllUsers.GetAllUsersMock.callArgs = append(mmGetAllUsers.GetAllUsersMock.callArgs, &mm_params)
	mmGetAllUsers.GetAllUsersMock.mutex.Unlock()

	for _, e := range mmGetAllUsers.GetAllUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetAllUsers.GetAllUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllUsers.GetAllUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllUsers.GetAllUsersMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllUsers.GetAllUsersMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetAllUsersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllUsers.t.Errorf("CoreMock.GetAllUsers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllUsers.GetAllUsersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllUsers.t.Errorf("CoreMock.GetAllUsers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllUsers.GetAllUsersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllUsers.GetAllUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllUsers.t.Fatal("No results are set for the CoreMock.GetAllUsers")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetAllUsers.funcGetAllUsers != nil {
		return mmGetAllUsers.funcGetAllUsers(ctx)
	}
	mmGetAllUsers.t.Fatalf("Unexpected call to CoreMock.GetAllUsers. %v", ctx)
	return
}

// GetAllUsersAfterCounter returns a count of finished CoreMock.GetAllUsers invocations
func (mmGetAllUsers *CoreMock) GetAllUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUsers.afterGetAllUsersCounter)
}

// GetAllUsersBeforeCounter returns a count of CoreMock.GetAllUsers invocations
func (mmGetAllUsers *CoreMock) GetAllUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUsers.beforeGetAllUsersCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetAllUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllUsers *mCoreMockGetAllUsers) Calls() []*CoreMockGetAllUsersParams {
	mmGetAllUsers.mutex.RLock()

	argCopy := make([]*CoreMockGetAllUsersParams, len(mmGetAllUsers.callArgs))
	copy(argCopy, mmGetAllUsers.callArgs)

	mmGetAllUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllUsersDone returns true if the count of the GetAllUsers invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetAllUsersDone() bool {
	if m.GetAllUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllUsersMock.invocationsDone()
}

// MinimockGetAllUsersInspect logs each unmet expectation
func (m *CoreMock) MinimockGetAllUsersInspect() {
	for _, e := range m.GetAllUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetAllUsers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllUsersCounter := mm_atomic.LoadUint64(&m.afterGetAllUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllUsersMock.defaultExpectation != nil && afterGetAllUsersCounter < 1 {
		if m.GetAllUsersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetAllUsers at\n%s", m.GetAllUsersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetAllUsers at\n%s with params: %#v", m.GetAllUsersMock.defaultExpectation.expectationOrigins.origin, *m.GetAllUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllUsers != nil && afterGetAllUsersCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetAllUsers at\n%s", m.funcGetAllUsersOrigin)
	}

	if !m.GetAllUsersMock.invocationsDone() && afterGetAllUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetAllUsers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllUsersMock.expectedInvocations), m.GetAllUsersMock.expectedInvocationsOrigin, afterGetAllUsersCounter)
	}
}

type mCoreMockGetUser struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetUserExpectation
	expectations       []*CoreMockGetUserExpectation

	callArgs []*CoreMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetUserExpectation specifies expectation struct of the Core.GetUser
type CoreMockGetUserExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetUserParams
	paramPtrs          *CoreMockGetUserParamPtrs
	expectationOrigins CoreMockGetUserExpectationOrigins
	results            *CoreMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetUserParams contains parameters of the Core.GetUser
type CoreMockGetUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockGetUserParamPtrs contains pointers to parameters of the Core.GetUser
type CoreMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockGetUserResults contains results of the Core.GetUser
type CoreMockGetUserResults struct {
	u1  user.User
	s1  string
	err error
}

// CoreMockGetUserOrigins contains origins of expectations of the Core.GetUser
type CoreMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mCoreMockGetUser) Optional() *mCoreMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Core.GetUser
func (mmGetUser *mCoreMockGetUser) Expect(ctx context.Context, id uuid.UUID) *mCoreMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &CoreMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &CoreMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetUser
func (mmGetUser *mCoreMockGetUser) ExpectCtxParam1(ctx context.Context) *mCoreMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &CoreMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &CoreMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for Core.GetUser
func (mmGetUser *mCoreMockGetUser) ExpectIdParam2(id uuid.UUID) *mCoreMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &CoreMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &CoreMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Core.GetUser
func (mmGetUser *mCoreMockGetUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for CoreMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Core.GetUser
func (mmGetUser *mCoreMockGetUser) Return(u1 user.User, s1 string, err error) *CoreMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &CoreMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &CoreMockGetUserResults{u1, s1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the Core.GetUser method
func (mmGetUser *mCoreMockGetUser) Set(f func(ctx context.Context, id uuid.UUID) (u1 user.User, s1 string, err error)) *CoreMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Core.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Core.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the Core.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mCoreMockGetUser) When(ctx context.Context, id uuid.UUID) *CoreMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("CoreMock.GetUser mock is already set by Set")
	}

	expectation := &CoreMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &CoreMockGetUserParams{ctx, id},
		expectationOrigins: CoreMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Core.GetUser return parameters for the expectation previously defined by the When method
func (e *CoreMockGetUserExpectation) Then(u1 user.User, s1 string, err error) *CoreMock {
	e.results = &CoreMockGetUserResults{u1, s1, err}
	return e.mock
}

// Times sets number of times Core.GetUser should be invoked
func (mmGetUser *mCoreMockGetUser) Times(n uint64) *mCoreMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of CoreMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mCoreMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_usecase.Core
func (mmGetUser *CoreMock) GetUser(ctx context.Context, id uuid.UUID) (u1 user.User, s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := CoreMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.s1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("CoreMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("CoreMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("CoreMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the CoreMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).s1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to CoreMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished CoreMock.GetUser invocations
func (mmGetUser *CoreMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of CoreMock.GetUser invocations
func (mmGetUser *CoreMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mCoreMockGetUser) Calls() []*CoreMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*CoreMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *CoreMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mCoreMockUpdateUser struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockUpdateUserExpectation
	expectations       []*CoreMockUpdateUserExpectation

	callArgs []*CoreMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockUpdateUserExpectation specifies expectation struct of the Core.UpdateUser
type CoreMockUpdateUserExpectation struct {
	mock               *CoreMock
	params             *CoreMockUpdateUserParams
	paramPtrs          *CoreMockUpdateUserParamPtrs
	expectationOrigins CoreMockUpdateUserExpectationOrigins
	results            *CoreMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockUpdateUserParams contains parameters of the Core.UpdateUser
type CoreMockUpdateUserParams struct {
	ctx context.Context
	req user.UpdateUserReq
}

// CoreMockUpdateUserParamPtrs contains pointers to parameters of the Core.UpdateUser
type CoreMockUpdateUserParamPtrs struct {
	ctx *context.Context
	req *user.UpdateUserReq
}

// CoreMockUpdateUserResults contains results of the Core.UpdateUser
type CoreMockUpdateUserResults struct {
	err error
}

// CoreMockUpdateUserOrigins contains origins of expectations of the Core.UpdateUser
type CoreMockUpdateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mCoreMockUpdateUser) Optional() *mCoreMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for Core.UpdateUser
func (mmUpdateUser *mCoreMockUpdateUser) Expect(ctx context.Context, req user.UpdateUserReq) *mCoreMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &CoreMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &CoreMockUpdateUserParams{ctx, req}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for Core.UpdateUser
func (mmUpdateUser *mCoreMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mCoreMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &CoreMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &CoreMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectReqParam2 sets up expected param req for Core.UpdateUser
func (mmUpdateUser *mCoreMockUpdateUser) ExpectReqParam2(req user.UpdateUserReq) *mCoreMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &CoreMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &CoreMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.req = &req
	mmUpdateUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the Core.UpdateUser
func (mmUpdateUser *mCoreMockUpdateUser) Inspect(f func(ctx context.Context, req user.UpdateUserReq)) *mCoreMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for CoreMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by Core.UpdateUser
func (mmUpdateUser *mCoreMockUpdateUser) Return(err error) *CoreMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &CoreMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &CoreMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the Core.UpdateUser method
func (mmUpdateUser *mCoreMockUpdateUser) Set(f func(ctx context.Context, req user.UpdateUserReq) (err error)) *CoreMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the Core.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the Core.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the Core.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mCoreMockUpdateUser) When(ctx context.Context, req user.UpdateUserReq) *CoreMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("CoreMock.UpdateUser mock is already set by Set")
	}

	expectation := &CoreMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &CoreMockUpdateUserParams{ctx, req},
		expectationOrigins: CoreMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up Core.UpdateUser return parameters for the expectation previously defined by the When method
func (e *CoreMockUpdateUserExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times Core.UpdateUser should be invoked
func (mmUpdateUser *mCoreMockUpdateUser) Times(n uint64) *mCoreMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of CoreMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mCoreMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_usecase.Core
func (mmUpdateUser *CoreMock) UpdateUser(ctx context.Context, req user.UpdateUserReq) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, req)
	}

	mm_params := CoreMockUpdateUserParams{ctx, req}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := CoreMockUpdateUserParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("CoreMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdateUser.t.Errorf("CoreMock.UpdateUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("CoreMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the CoreMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, req)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to CoreMock.UpdateUser. %v %v", ctx, req)
	return
}

// UpdateUserAfterCounter returns a count of finished CoreMock.UpdateUser invocations
func (mmUpdateUser *CoreMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of CoreMock.UpdateUser invocations
func (mmUpdateUser *CoreMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mCoreMockUpdateUser) Calls() []*CoreMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*CoreMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *CoreMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CoreMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangePasswordInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetAllUsersInspect()

			m.MinimockGetUserInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangePasswordDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetAllUsersDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUpdateUserDone()
}
