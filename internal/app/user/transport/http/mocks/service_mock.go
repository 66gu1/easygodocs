// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/user/transport/http.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/user"
	"github.com/66gu1/easygodocs/internal/app/user/usecase"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ServiceMock implements mm_http.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangePassword          func(ctx context.Context, req usecase.ChangePasswordCmd) (err error)
	funcChangePasswordOrigin    string
	inspectFuncChangePassword   func(ctx context.Context, req usecase.ChangePasswordCmd)
	afterChangePasswordCounter  uint64
	beforeChangePasswordCounter uint64
	ChangePasswordMock          mServiceMockChangePassword

	funcCreateUser          func(ctx context.Context, req user.CreateUserReq) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, req user.CreateUserReq)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mServiceMockCreateUser

	funcDeleteUser          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id uuid.UUID)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mServiceMockDeleteUser

	funcGetAllUsers          func(ctx context.Context) (ua1 []user.User, err error)
	funcGetAllUsersOrigin    string
	inspectFuncGetAllUsers   func(ctx context.Context)
	afterGetAllUsersCounter  uint64
	beforeGetAllUsersCounter uint64
	GetAllUsersMock          mServiceMockGetAllUsers

	funcGetUser          func(ctx context.Context, id uuid.UUID) (u1 user.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id uuid.UUID)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mServiceMockGetUser

	funcUpdateUser          func(ctx context.Context, req user.UpdateUserReq) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, req user.UpdateUserReq)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mServiceMockUpdateUser
}

// NewServiceMock returns a mock for mm_http.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangePasswordMock = mServiceMockChangePassword{mock: m}
	m.ChangePasswordMock.callArgs = []*ServiceMockChangePasswordParams{}

	m.CreateUserMock = mServiceMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*ServiceMockCreateUserParams{}

	m.DeleteUserMock = mServiceMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*ServiceMockDeleteUserParams{}

	m.GetAllUsersMock = mServiceMockGetAllUsers{mock: m}
	m.GetAllUsersMock.callArgs = []*ServiceMockGetAllUsersParams{}

	m.GetUserMock = mServiceMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*ServiceMockGetUserParams{}

	m.UpdateUserMock = mServiceMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*ServiceMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockChangePassword struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockChangePasswordExpectation
	expectations       []*ServiceMockChangePasswordExpectation

	callArgs []*ServiceMockChangePasswordParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockChangePasswordExpectation specifies expectation struct of the Service.ChangePassword
type ServiceMockChangePasswordExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockChangePasswordParams
	paramPtrs          *ServiceMockChangePasswordParamPtrs
	expectationOrigins ServiceMockChangePasswordExpectationOrigins
	results            *ServiceMockChangePasswordResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockChangePasswordParams contains parameters of the Service.ChangePassword
type ServiceMockChangePasswordParams struct {
	ctx context.Context
	req usecase.ChangePasswordCmd
}

// ServiceMockChangePasswordParamPtrs contains pointers to parameters of the Service.ChangePassword
type ServiceMockChangePasswordParamPtrs struct {
	ctx *context.Context
	req *usecase.ChangePasswordCmd
}

// ServiceMockChangePasswordResults contains results of the Service.ChangePassword
type ServiceMockChangePasswordResults struct {
	err error
}

// ServiceMockChangePasswordOrigins contains origins of expectations of the Service.ChangePassword
type ServiceMockChangePasswordExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChangePassword *mServiceMockChangePassword) Optional() *mServiceMockChangePassword {
	mmChangePassword.optional = true
	return mmChangePassword
}

// Expect sets up expected params for Service.ChangePassword
func (mmChangePassword *mServiceMockChangePassword) Expect(ctx context.Context, req usecase.ChangePasswordCmd) *mServiceMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &ServiceMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.paramPtrs != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by ExpectParams functions")
	}

	mmChangePassword.defaultExpectation.params = &ServiceMockChangePasswordParams{ctx, req}
	mmChangePassword.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChangePassword.expectations {
		if minimock.Equal(e.params, mmChangePassword.defaultExpectation.params) {
			mmChangePassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangePassword.defaultExpectation.params)
		}
	}

	return mmChangePassword
}

// ExpectCtxParam1 sets up expected param ctx for Service.ChangePassword
func (mmChangePassword *mServiceMockChangePassword) ExpectCtxParam1(ctx context.Context) *mServiceMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &ServiceMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &ServiceMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.ctx = &ctx
	mmChangePassword.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChangePassword
}

// ExpectReqParam2 sets up expected param req for Service.ChangePassword
func (mmChangePassword *mServiceMockChangePassword) ExpectReqParam2(req usecase.ChangePasswordCmd) *mServiceMockChangePassword {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &ServiceMockChangePasswordExpectation{}
	}

	if mmChangePassword.defaultExpectation.params != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Expect")
	}

	if mmChangePassword.defaultExpectation.paramPtrs == nil {
		mmChangePassword.defaultExpectation.paramPtrs = &ServiceMockChangePasswordParamPtrs{}
	}
	mmChangePassword.defaultExpectation.paramPtrs.req = &req
	mmChangePassword.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmChangePassword
}

// Inspect accepts an inspector function that has same arguments as the Service.ChangePassword
func (mmChangePassword *mServiceMockChangePassword) Inspect(f func(ctx context.Context, req usecase.ChangePasswordCmd)) *mServiceMockChangePassword {
	if mmChangePassword.mock.inspectFuncChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("Inspect function is already set for ServiceMock.ChangePassword")
	}

	mmChangePassword.mock.inspectFuncChangePassword = f

	return mmChangePassword
}

// Return sets up results that will be returned by Service.ChangePassword
func (mmChangePassword *mServiceMockChangePassword) Return(err error) *ServiceMock {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Set")
	}

	if mmChangePassword.defaultExpectation == nil {
		mmChangePassword.defaultExpectation = &ServiceMockChangePasswordExpectation{mock: mmChangePassword.mock}
	}
	mmChangePassword.defaultExpectation.results = &ServiceMockChangePasswordResults{err}
	mmChangePassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChangePassword.mock
}

// Set uses given function f to mock the Service.ChangePassword method
func (mmChangePassword *mServiceMockChangePassword) Set(f func(ctx context.Context, req usecase.ChangePasswordCmd) (err error)) *ServiceMock {
	if mmChangePassword.defaultExpectation != nil {
		mmChangePassword.mock.t.Fatalf("Default expectation is already set for the Service.ChangePassword method")
	}

	if len(mmChangePassword.expectations) > 0 {
		mmChangePassword.mock.t.Fatalf("Some expectations are already set for the Service.ChangePassword method")
	}

	mmChangePassword.mock.funcChangePassword = f
	mmChangePassword.mock.funcChangePasswordOrigin = minimock.CallerInfo(1)
	return mmChangePassword.mock
}

// When sets expectation for the Service.ChangePassword which will trigger the result defined by the following
// Then helper
func (mmChangePassword *mServiceMockChangePassword) When(ctx context.Context, req usecase.ChangePasswordCmd) *ServiceMockChangePasswordExpectation {
	if mmChangePassword.mock.funcChangePassword != nil {
		mmChangePassword.mock.t.Fatalf("ServiceMock.ChangePassword mock is already set by Set")
	}

	expectation := &ServiceMockChangePasswordExpectation{
		mock:               mmChangePassword.mock,
		params:             &ServiceMockChangePasswordParams{ctx, req},
		expectationOrigins: ServiceMockChangePasswordExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChangePassword.expectations = append(mmChangePassword.expectations, expectation)
	return expectation
}

// Then sets up Service.ChangePassword return parameters for the expectation previously defined by the When method
func (e *ServiceMockChangePasswordExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockChangePasswordResults{err}
	return e.mock
}

// Times sets number of times Service.ChangePassword should be invoked
func (mmChangePassword *mServiceMockChangePassword) Times(n uint64) *mServiceMockChangePassword {
	if n == 0 {
		mmChangePassword.mock.t.Fatalf("Times of ServiceMock.ChangePassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChangePassword.expectedInvocations, n)
	mmChangePassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChangePassword
}

func (mmChangePassword *mServiceMockChangePassword) invocationsDone() bool {
	if len(mmChangePassword.expectations) == 0 && mmChangePassword.defaultExpectation == nil && mmChangePassword.mock.funcChangePassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChangePassword.mock.afterChangePasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChangePassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChangePassword implements mm_http.Service
func (mmChangePassword *ServiceMock) ChangePassword(ctx context.Context, req usecase.ChangePasswordCmd) (err error) {
	mm_atomic.AddUint64(&mmChangePassword.beforeChangePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmChangePassword.afterChangePasswordCounter, 1)

	mmChangePassword.t.Helper()

	if mmChangePassword.inspectFuncChangePassword != nil {
		mmChangePassword.inspectFuncChangePassword(ctx, req)
	}

	mm_params := ServiceMockChangePasswordParams{ctx, req}

	// Record call args
	mmChangePassword.ChangePasswordMock.mutex.Lock()
	mmChangePassword.ChangePasswordMock.callArgs = append(mmChangePassword.ChangePasswordMock.callArgs, &mm_params)
	mmChangePassword.ChangePasswordMock.mutex.Unlock()

	for _, e := range mmChangePassword.ChangePasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangePassword.ChangePasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangePassword.ChangePasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmChangePassword.ChangePasswordMock.defaultExpectation.params
		mm_want_ptrs := mmChangePassword.ChangePasswordMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockChangePasswordParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChangePassword.t.Errorf("ServiceMock.ChangePassword got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmChangePassword.t.Errorf("ServiceMock.ChangePassword got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangePassword.t.Errorf("ServiceMock.ChangePassword got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChangePassword.ChangePasswordMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangePassword.ChangePasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmChangePassword.t.Fatal("No results are set for the ServiceMock.ChangePassword")
		}
		return (*mm_results).err
	}
	if mmChangePassword.funcChangePassword != nil {
		return mmChangePassword.funcChangePassword(ctx, req)
	}
	mmChangePassword.t.Fatalf("Unexpected call to ServiceMock.ChangePassword. %v %v", ctx, req)
	return
}

// ChangePasswordAfterCounter returns a count of finished ServiceMock.ChangePassword invocations
func (mmChangePassword *ServiceMock) ChangePasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePassword.afterChangePasswordCounter)
}

// ChangePasswordBeforeCounter returns a count of ServiceMock.ChangePassword invocations
func (mmChangePassword *ServiceMock) ChangePasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangePassword.beforeChangePasswordCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ChangePassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangePassword *mServiceMockChangePassword) Calls() []*ServiceMockChangePasswordParams {
	mmChangePassword.mutex.RLock()

	argCopy := make([]*ServiceMockChangePasswordParams, len(mmChangePassword.callArgs))
	copy(argCopy, mmChangePassword.callArgs)

	mmChangePassword.mutex.RUnlock()

	return argCopy
}

// MinimockChangePasswordDone returns true if the count of the ChangePassword invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockChangePasswordDone() bool {
	if m.ChangePasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangePasswordMock.invocationsDone()
}

// MinimockChangePasswordInspect logs each unmet expectation
func (m *ServiceMock) MinimockChangePasswordInspect() {
	for _, e := range m.ChangePasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ChangePassword at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChangePasswordCounter := mm_atomic.LoadUint64(&m.afterChangePasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangePasswordMock.defaultExpectation != nil && afterChangePasswordCounter < 1 {
		if m.ChangePasswordMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ChangePassword at\n%s", m.ChangePasswordMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ChangePassword at\n%s with params: %#v", m.ChangePasswordMock.defaultExpectation.expectationOrigins.origin, *m.ChangePasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangePassword != nil && afterChangePasswordCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ChangePassword at\n%s", m.funcChangePasswordOrigin)
	}

	if !m.ChangePasswordMock.invocationsDone() && afterChangePasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ChangePassword at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChangePasswordMock.expectedInvocations), m.ChangePasswordMock.expectedInvocationsOrigin, afterChangePasswordCounter)
	}
}

type mServiceMockCreateUser struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateUserExpectation
	expectations       []*ServiceMockCreateUserExpectation

	callArgs []*ServiceMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateUserExpectation specifies expectation struct of the Service.CreateUser
type ServiceMockCreateUserExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateUserParams
	paramPtrs          *ServiceMockCreateUserParamPtrs
	expectationOrigins ServiceMockCreateUserExpectationOrigins
	results            *ServiceMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateUserParams contains parameters of the Service.CreateUser
type ServiceMockCreateUserParams struct {
	ctx context.Context
	req user.CreateUserReq
}

// ServiceMockCreateUserParamPtrs contains pointers to parameters of the Service.CreateUser
type ServiceMockCreateUserParamPtrs struct {
	ctx *context.Context
	req *user.CreateUserReq
}

// ServiceMockCreateUserResults contains results of the Service.CreateUser
type ServiceMockCreateUserResults struct {
	err error
}

// ServiceMockCreateUserOrigins contains origins of expectations of the Service.CreateUser
type ServiceMockCreateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mServiceMockCreateUser) Optional() *mServiceMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) Expect(ctx context.Context, req user.CreateUserReq) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &ServiceMockCreateUserParams{ctx, req}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) ExpectCtxParam1(ctx context.Context) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectReqParam2 sets up expected param req for Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) ExpectReqParam2(req user.CreateUserReq) *mServiceMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &ServiceMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.req = &req
	mmCreateUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) Inspect(f func(ctx context.Context, req user.CreateUserReq)) *mServiceMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Service.CreateUser
func (mmCreateUser *mServiceMockCreateUser) Return(err error) *ServiceMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &ServiceMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &ServiceMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the Service.CreateUser method
func (mmCreateUser *mServiceMockCreateUser) Set(f func(ctx context.Context, req user.CreateUserReq) (err error)) *ServiceMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Service.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Service.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the Service.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mServiceMockCreateUser) When(ctx context.Context, req user.CreateUserReq) *ServiceMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("ServiceMock.CreateUser mock is already set by Set")
	}

	expectation := &ServiceMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &ServiceMockCreateUserParams{ctx, req},
		expectationOrigins: ServiceMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateUser return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateUserExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times Service.CreateUser should be invoked
func (mmCreateUser *mServiceMockCreateUser) Times(n uint64) *mServiceMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of ServiceMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mServiceMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_http.Service
func (mmCreateUser *ServiceMock) CreateUser(ctx context.Context, req user.CreateUserReq) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, req)
	}

	mm_params := ServiceMockCreateUserParams{ctx, req}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateUserParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("ServiceMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the ServiceMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, req)
	}
	mmCreateUser.t.Fatalf("Unexpected call to ServiceMock.CreateUser. %v %v", ctx, req)
	return
}

// CreateUserAfterCounter returns a count of finished ServiceMock.CreateUser invocations
func (mmCreateUser *ServiceMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of ServiceMock.CreateUser invocations
func (mmCreateUser *ServiceMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mServiceMockCreateUser) Calls() []*ServiceMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*ServiceMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mServiceMockDeleteUser struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteUserExpectation
	expectations       []*ServiceMockDeleteUserExpectation

	callArgs []*ServiceMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteUserExpectation specifies expectation struct of the Service.DeleteUser
type ServiceMockDeleteUserExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteUserParams
	paramPtrs          *ServiceMockDeleteUserParamPtrs
	expectationOrigins ServiceMockDeleteUserExpectationOrigins
	results            *ServiceMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteUserParams contains parameters of the Service.DeleteUser
type ServiceMockDeleteUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockDeleteUserParamPtrs contains pointers to parameters of the Service.DeleteUser
type ServiceMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// ServiceMockDeleteUserResults contains results of the Service.DeleteUser
type ServiceMockDeleteUserResults struct {
	err error
}

// ServiceMockDeleteUserOrigins contains origins of expectations of the Service.DeleteUser
type ServiceMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mServiceMockDeleteUser) Optional() *mServiceMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for Service.DeleteUser
func (mmDeleteUser *mServiceMockDeleteUser) Expect(ctx context.Context, id uuid.UUID) *mServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &ServiceMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteUser
func (mmDeleteUser *mServiceMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ServiceMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for Service.DeleteUser
func (mmDeleteUser *mServiceMockDeleteUser) ExpectIdParam2(id uuid.UUID) *mServiceMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ServiceMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &ServiceMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteUser
func (mmDeleteUser *mServiceMockDeleteUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Service.DeleteUser
func (mmDeleteUser *mServiceMockDeleteUser) Return(err error) *ServiceMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &ServiceMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &ServiceMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the Service.DeleteUser method
func (mmDeleteUser *mServiceMockDeleteUser) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *ServiceMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Service.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Service.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the Service.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mServiceMockDeleteUser) When(ctx context.Context, id uuid.UUID) *ServiceMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("ServiceMock.DeleteUser mock is already set by Set")
	}

	expectation := &ServiceMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &ServiceMockDeleteUserParams{ctx, id},
		expectationOrigins: ServiceMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteUser return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteUserExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteUser should be invoked
func (mmDeleteUser *mServiceMockDeleteUser) Times(n uint64) *mServiceMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of ServiceMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mServiceMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_http.Service
func (mmDeleteUser *ServiceMock) DeleteUser(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := ServiceMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("ServiceMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("ServiceMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("ServiceMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the ServiceMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to ServiceMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished ServiceMock.DeleteUser invocations
func (mmDeleteUser *ServiceMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of ServiceMock.DeleteUser invocations
func (mmDeleteUser *ServiceMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mServiceMockDeleteUser) Calls() []*ServiceMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mServiceMockGetAllUsers struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetAllUsersExpectation
	expectations       []*ServiceMockGetAllUsersExpectation

	callArgs []*ServiceMockGetAllUsersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetAllUsersExpectation specifies expectation struct of the Service.GetAllUsers
type ServiceMockGetAllUsersExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetAllUsersParams
	paramPtrs          *ServiceMockGetAllUsersParamPtrs
	expectationOrigins ServiceMockGetAllUsersExpectationOrigins
	results            *ServiceMockGetAllUsersResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetAllUsersParams contains parameters of the Service.GetAllUsers
type ServiceMockGetAllUsersParams struct {
	ctx context.Context
}

// ServiceMockGetAllUsersParamPtrs contains pointers to parameters of the Service.GetAllUsers
type ServiceMockGetAllUsersParamPtrs struct {
	ctx *context.Context
}

// ServiceMockGetAllUsersResults contains results of the Service.GetAllUsers
type ServiceMockGetAllUsersResults struct {
	ua1 []user.User
	err error
}

// ServiceMockGetAllUsersOrigins contains origins of expectations of the Service.GetAllUsers
type ServiceMockGetAllUsersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllUsers *mServiceMockGetAllUsers) Optional() *mServiceMockGetAllUsers {
	mmGetAllUsers.optional = true
	return mmGetAllUsers
}

// Expect sets up expected params for Service.GetAllUsers
func (mmGetAllUsers *mServiceMockGetAllUsers) Expect(ctx context.Context) *mServiceMockGetAllUsers {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("ServiceMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &ServiceMockGetAllUsersExpectation{}
	}

	if mmGetAllUsers.defaultExpectation.paramPtrs != nil {
		mmGetAllUsers.mock.t.Fatalf("ServiceMock.GetAllUsers mock is already set by ExpectParams functions")
	}

	mmGetAllUsers.defaultExpectation.params = &ServiceMockGetAllUsersParams{ctx}
	mmGetAllUsers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllUsers.expectations {
		if minimock.Equal(e.params, mmGetAllUsers.defaultExpectation.params) {
			mmGetAllUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllUsers.defaultExpectation.params)
		}
	}

	return mmGetAllUsers
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetAllUsers
func (mmGetAllUsers *mServiceMockGetAllUsers) ExpectCtxParam1(ctx context.Context) *mServiceMockGetAllUsers {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("ServiceMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &ServiceMockGetAllUsersExpectation{}
	}

	if mmGetAllUsers.defaultExpectation.params != nil {
		mmGetAllUsers.mock.t.Fatalf("ServiceMock.GetAllUsers mock is already set by Expect")
	}

	if mmGetAllUsers.defaultExpectation.paramPtrs == nil {
		mmGetAllUsers.defaultExpectation.paramPtrs = &ServiceMockGetAllUsersParamPtrs{}
	}
	mmGetAllUsers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllUsers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllUsers
}

// Inspect accepts an inspector function that has same arguments as the Service.GetAllUsers
func (mmGetAllUsers *mServiceMockGetAllUsers) Inspect(f func(ctx context.Context)) *mServiceMockGetAllUsers {
	if mmGetAllUsers.mock.inspectFuncGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetAllUsers")
	}

	mmGetAllUsers.mock.inspectFuncGetAllUsers = f

	return mmGetAllUsers
}

// Return sets up results that will be returned by Service.GetAllUsers
func (mmGetAllUsers *mServiceMockGetAllUsers) Return(ua1 []user.User, err error) *ServiceMock {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("ServiceMock.GetAllUsers mock is already set by Set")
	}

	if mmGetAllUsers.defaultExpectation == nil {
		mmGetAllUsers.defaultExpectation = &ServiceMockGetAllUsersExpectation{mock: mmGetAllUsers.mock}
	}
	mmGetAllUsers.defaultExpectation.results = &ServiceMockGetAllUsersResults{ua1, err}
	mmGetAllUsers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers.mock
}

// Set uses given function f to mock the Service.GetAllUsers method
func (mmGetAllUsers *mServiceMockGetAllUsers) Set(f func(ctx context.Context) (ua1 []user.User, err error)) *ServiceMock {
	if mmGetAllUsers.defaultExpectation != nil {
		mmGetAllUsers.mock.t.Fatalf("Default expectation is already set for the Service.GetAllUsers method")
	}

	if len(mmGetAllUsers.expectations) > 0 {
		mmGetAllUsers.mock.t.Fatalf("Some expectations are already set for the Service.GetAllUsers method")
	}

	mmGetAllUsers.mock.funcGetAllUsers = f
	mmGetAllUsers.mock.funcGetAllUsersOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers.mock
}

// When sets expectation for the Service.GetAllUsers which will trigger the result defined by the following
// Then helper
func (mmGetAllUsers *mServiceMockGetAllUsers) When(ctx context.Context) *ServiceMockGetAllUsersExpectation {
	if mmGetAllUsers.mock.funcGetAllUsers != nil {
		mmGetAllUsers.mock.t.Fatalf("ServiceMock.GetAllUsers mock is already set by Set")
	}

	expectation := &ServiceMockGetAllUsersExpectation{
		mock:               mmGetAllUsers.mock,
		params:             &ServiceMockGetAllUsersParams{ctx},
		expectationOrigins: ServiceMockGetAllUsersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllUsers.expectations = append(mmGetAllUsers.expectations, expectation)
	return expectation
}

// Then sets up Service.GetAllUsers return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetAllUsersExpectation) Then(ua1 []user.User, err error) *ServiceMock {
	e.results = &ServiceMockGetAllUsersResults{ua1, err}
	return e.mock
}

// Times sets number of times Service.GetAllUsers should be invoked
func (mmGetAllUsers *mServiceMockGetAllUsers) Times(n uint64) *mServiceMockGetAllUsers {
	if n == 0 {
		mmGetAllUsers.mock.t.Fatalf("Times of ServiceMock.GetAllUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllUsers.expectedInvocations, n)
	mmGetAllUsers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllUsers
}

func (mmGetAllUsers *mServiceMockGetAllUsers) invocationsDone() bool {
	if len(mmGetAllUsers.expectations) == 0 && mmGetAllUsers.defaultExpectation == nil && mmGetAllUsers.mock.funcGetAllUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllUsers.mock.afterGetAllUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllUsers implements mm_http.Service
func (mmGetAllUsers *ServiceMock) GetAllUsers(ctx context.Context) (ua1 []user.User, err error) {
	mm_atomic.AddUint64(&mmGetAllUsers.beforeGetAllUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllUsers.afterGetAllUsersCounter, 1)

	mmGetAllUsers.t.Helper()

	if mmGetAllUsers.inspectFuncGetAllUsers != nil {
		mmGetAllUsers.inspectFuncGetAllUsers(ctx)
	}

	mm_params := ServiceMockGetAllUsersParams{ctx}

	// Record call args
	mmGetAllUsers.GetAllUsersMock.mutex.Lock()
	mmGetAllUsers.GetAllUsersMock.callArgs = append(mmGetAllUsers.GetAllUsersMock.callArgs, &mm_params)
	mmGetAllUsers.GetAllUsersMock.mutex.Unlock()

	for _, e := range mmGetAllUsers.GetAllUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetAllUsers.GetAllUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllUsers.GetAllUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllUsers.GetAllUsersMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllUsers.GetAllUsersMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetAllUsersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllUsers.t.Errorf("ServiceMock.GetAllUsers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllUsers.GetAllUsersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllUsers.t.Errorf("ServiceMock.GetAllUsers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllUsers.GetAllUsersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllUsers.GetAllUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllUsers.t.Fatal("No results are set for the ServiceMock.GetAllUsers")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetAllUsers.funcGetAllUsers != nil {
		return mmGetAllUsers.funcGetAllUsers(ctx)
	}
	mmGetAllUsers.t.Fatalf("Unexpected call to ServiceMock.GetAllUsers. %v", ctx)
	return
}

// GetAllUsersAfterCounter returns a count of finished ServiceMock.GetAllUsers invocations
func (mmGetAllUsers *ServiceMock) GetAllUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUsers.afterGetAllUsersCounter)
}

// GetAllUsersBeforeCounter returns a count of ServiceMock.GetAllUsers invocations
func (mmGetAllUsers *ServiceMock) GetAllUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllUsers.beforeGetAllUsersCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetAllUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllUsers *mServiceMockGetAllUsers) Calls() []*ServiceMockGetAllUsersParams {
	mmGetAllUsers.mutex.RLock()

	argCopy := make([]*ServiceMockGetAllUsersParams, len(mmGetAllUsers.callArgs))
	copy(argCopy, mmGetAllUsers.callArgs)

	mmGetAllUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllUsersDone returns true if the count of the GetAllUsers invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetAllUsersDone() bool {
	if m.GetAllUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllUsersMock.invocationsDone()
}

// MinimockGetAllUsersInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetAllUsersInspect() {
	for _, e := range m.GetAllUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetAllUsers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllUsersCounter := mm_atomic.LoadUint64(&m.afterGetAllUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllUsersMock.defaultExpectation != nil && afterGetAllUsersCounter < 1 {
		if m.GetAllUsersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetAllUsers at\n%s", m.GetAllUsersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetAllUsers at\n%s with params: %#v", m.GetAllUsersMock.defaultExpectation.expectationOrigins.origin, *m.GetAllUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllUsers != nil && afterGetAllUsersCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetAllUsers at\n%s", m.funcGetAllUsersOrigin)
	}

	if !m.GetAllUsersMock.invocationsDone() && afterGetAllUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetAllUsers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllUsersMock.expectedInvocations), m.GetAllUsersMock.expectedInvocationsOrigin, afterGetAllUsersCounter)
	}
}

type mServiceMockGetUser struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetUserExpectation
	expectations       []*ServiceMockGetUserExpectation

	callArgs []*ServiceMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetUserExpectation specifies expectation struct of the Service.GetUser
type ServiceMockGetUserExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetUserParams
	paramPtrs          *ServiceMockGetUserParamPtrs
	expectationOrigins ServiceMockGetUserExpectationOrigins
	results            *ServiceMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetUserParams contains parameters of the Service.GetUser
type ServiceMockGetUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockGetUserParamPtrs contains pointers to parameters of the Service.GetUser
type ServiceMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// ServiceMockGetUserResults contains results of the Service.GetUser
type ServiceMockGetUserResults struct {
	u1  user.User
	err error
}

// ServiceMockGetUserOrigins contains origins of expectations of the Service.GetUser
type ServiceMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mServiceMockGetUser) Optional() *mServiceMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for Service.GetUser
func (mmGetUser *mServiceMockGetUser) Expect(ctx context.Context, id uuid.UUID) *mServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &ServiceMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetUser
func (mmGetUser *mServiceMockGetUser) ExpectCtxParam1(ctx context.Context) *mServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ServiceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for Service.GetUser
func (mmGetUser *mServiceMockGetUser) ExpectIdParam2(id uuid.UUID) *mServiceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &ServiceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Service.GetUser
func (mmGetUser *mServiceMockGetUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Service.GetUser
func (mmGetUser *mServiceMockGetUser) Return(u1 user.User, err error) *ServiceMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &ServiceMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &ServiceMockGetUserResults{u1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the Service.GetUser method
func (mmGetUser *mServiceMockGetUser) Set(f func(ctx context.Context, id uuid.UUID) (u1 user.User, err error)) *ServiceMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Service.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Service.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the Service.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mServiceMockGetUser) When(ctx context.Context, id uuid.UUID) *ServiceMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("ServiceMock.GetUser mock is already set by Set")
	}

	expectation := &ServiceMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &ServiceMockGetUserParams{ctx, id},
		expectationOrigins: ServiceMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up Service.GetUser return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetUserExpectation) Then(u1 user.User, err error) *ServiceMock {
	e.results = &ServiceMockGetUserResults{u1, err}
	return e.mock
}

// Times sets number of times Service.GetUser should be invoked
func (mmGetUser *mServiceMockGetUser) Times(n uint64) *mServiceMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of ServiceMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mServiceMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_http.Service
func (mmGetUser *ServiceMock) GetUser(ctx context.Context, id uuid.UUID) (u1 user.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := ServiceMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("ServiceMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("ServiceMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("ServiceMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the ServiceMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to ServiceMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished ServiceMock.GetUser invocations
func (mmGetUser *ServiceMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of ServiceMock.GetUser invocations
func (mmGetUser *ServiceMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mServiceMockGetUser) Calls() []*ServiceMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*ServiceMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mServiceMockUpdateUser struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateUserExpectation
	expectations       []*ServiceMockUpdateUserExpectation

	callArgs []*ServiceMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUpdateUserExpectation specifies expectation struct of the Service.UpdateUser
type ServiceMockUpdateUserExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUpdateUserParams
	paramPtrs          *ServiceMockUpdateUserParamPtrs
	expectationOrigins ServiceMockUpdateUserExpectationOrigins
	results            *ServiceMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUpdateUserParams contains parameters of the Service.UpdateUser
type ServiceMockUpdateUserParams struct {
	ctx context.Context
	req user.UpdateUserReq
}

// ServiceMockUpdateUserParamPtrs contains pointers to parameters of the Service.UpdateUser
type ServiceMockUpdateUserParamPtrs struct {
	ctx *context.Context
	req *user.UpdateUserReq
}

// ServiceMockUpdateUserResults contains results of the Service.UpdateUser
type ServiceMockUpdateUserResults struct {
	err error
}

// ServiceMockUpdateUserOrigins contains origins of expectations of the Service.UpdateUser
type ServiceMockUpdateUserExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mServiceMockUpdateUser) Optional() *mServiceMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for Service.UpdateUser
func (mmUpdateUser *mServiceMockUpdateUser) Expect(ctx context.Context, req user.UpdateUserReq) *mServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &ServiceMockUpdateUserParams{ctx, req}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for Service.UpdateUser
func (mmUpdateUser *mServiceMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &ServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectReqParam2 sets up expected param req for Service.UpdateUser
func (mmUpdateUser *mServiceMockUpdateUser) ExpectReqParam2(req user.UpdateUserReq) *mServiceMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ServiceMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &ServiceMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.req = &req
	mmUpdateUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the Service.UpdateUser
func (mmUpdateUser *mServiceMockUpdateUser) Inspect(f func(ctx context.Context, req user.UpdateUserReq)) *mServiceMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for ServiceMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by Service.UpdateUser
func (mmUpdateUser *mServiceMockUpdateUser) Return(err error) *ServiceMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &ServiceMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &ServiceMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the Service.UpdateUser method
func (mmUpdateUser *mServiceMockUpdateUser) Set(f func(ctx context.Context, req user.UpdateUserReq) (err error)) *ServiceMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the Service.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the Service.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the Service.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mServiceMockUpdateUser) When(ctx context.Context, req user.UpdateUserReq) *ServiceMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("ServiceMock.UpdateUser mock is already set by Set")
	}

	expectation := &ServiceMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &ServiceMockUpdateUserParams{ctx, req},
		expectationOrigins: ServiceMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up Service.UpdateUser return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateUserExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times Service.UpdateUser should be invoked
func (mmUpdateUser *mServiceMockUpdateUser) Times(n uint64) *mServiceMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of ServiceMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mServiceMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_http.Service
func (mmUpdateUser *ServiceMock) UpdateUser(ctx context.Context, req user.UpdateUserReq) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, req)
	}

	mm_params := ServiceMockUpdateUserParams{ctx, req}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUpdateUserParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("ServiceMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdateUser.t.Errorf("ServiceMock.UpdateUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("ServiceMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the ServiceMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, req)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to ServiceMock.UpdateUser. %v %v", ctx, req)
	return
}

// UpdateUserAfterCounter returns a count of finished ServiceMock.UpdateUser invocations
func (mmUpdateUser *ServiceMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of ServiceMock.UpdateUser invocations
func (mmUpdateUser *ServiceMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mServiceMockUpdateUser) Calls() []*ServiceMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangePasswordInspect()

			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetAllUsersInspect()

			m.MinimockGetUserInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangePasswordDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetAllUsersDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUpdateUserDone()
}
