// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/auth/transport/http.AuthService -o auth_service_mock.go -n AuthServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/auth"
	"github.com/66gu1/easygodocs/internal/app/auth/usecase"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// AuthServiceMock implements mm_http.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUserRole          func(ctx context.Context, role auth.UserRole) (err error)
	funcAddUserRoleOrigin    string
	inspectFuncAddUserRole   func(ctx context.Context, role auth.UserRole)
	afterAddUserRoleCounter  uint64
	beforeAddUserRoleCounter uint64
	AddUserRoleMock          mAuthServiceMockAddUserRole

	funcDeleteSession          func(ctx context.Context, userID uuid.UUID, id uuid.UUID) (err error)
	funcDeleteSessionOrigin    string
	inspectFuncDeleteSession   func(ctx context.Context, userID uuid.UUID, id uuid.UUID)
	afterDeleteSessionCounter  uint64
	beforeDeleteSessionCounter uint64
	DeleteSessionMock          mAuthServiceMockDeleteSession

	funcDeleteSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (err error)
	funcDeleteSessionsByUserIDOrigin    string
	inspectFuncDeleteSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterDeleteSessionsByUserIDCounter  uint64
	beforeDeleteSessionsByUserIDCounter uint64
	DeleteSessionsByUserIDMock          mAuthServiceMockDeleteSessionsByUserID

	funcDeleteUserRole          func(ctx context.Context, role auth.UserRole) (err error)
	funcDeleteUserRoleOrigin    string
	inspectFuncDeleteUserRole   func(ctx context.Context, role auth.UserRole)
	afterDeleteUserRoleCounter  uint64
	beforeDeleteUserRoleCounter uint64
	DeleteUserRoleMock          mAuthServiceMockDeleteUserRole

	funcGetSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (sa1 []auth.Session, err error)
	funcGetSessionsByUserIDOrigin    string
	inspectFuncGetSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterGetSessionsByUserIDCounter  uint64
	beforeGetSessionsByUserIDCounter uint64
	GetSessionsByUserIDMock          mAuthServiceMockGetSessionsByUserID

	funcListUserRoles          func(ctx context.Context, userID uuid.UUID) (ua1 []auth.UserRole, err error)
	funcListUserRolesOrigin    string
	inspectFuncListUserRoles   func(ctx context.Context, userID uuid.UUID)
	afterListUserRolesCounter  uint64
	beforeListUserRolesCounter uint64
	ListUserRolesMock          mAuthServiceMockListUserRoles

	funcLogin          func(ctx context.Context, req usecase.LoginCmd) (t1 auth.Tokens, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, req usecase.LoginCmd)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mAuthServiceMockLogin

	funcRefreshTokens          func(ctx context.Context, refreshToken auth.RefreshToken) (t1 auth.Tokens, err error)
	funcRefreshTokensOrigin    string
	inspectFuncRefreshTokens   func(ctx context.Context, refreshToken auth.RefreshToken)
	afterRefreshTokensCounter  uint64
	beforeRefreshTokensCounter uint64
	RefreshTokensMock          mAuthServiceMockRefreshTokens
}

// NewAuthServiceMock returns a mock for mm_http.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUserRoleMock = mAuthServiceMockAddUserRole{mock: m}
	m.AddUserRoleMock.callArgs = []*AuthServiceMockAddUserRoleParams{}

	m.DeleteSessionMock = mAuthServiceMockDeleteSession{mock: m}
	m.DeleteSessionMock.callArgs = []*AuthServiceMockDeleteSessionParams{}

	m.DeleteSessionsByUserIDMock = mAuthServiceMockDeleteSessionsByUserID{mock: m}
	m.DeleteSessionsByUserIDMock.callArgs = []*AuthServiceMockDeleteSessionsByUserIDParams{}

	m.DeleteUserRoleMock = mAuthServiceMockDeleteUserRole{mock: m}
	m.DeleteUserRoleMock.callArgs = []*AuthServiceMockDeleteUserRoleParams{}

	m.GetSessionsByUserIDMock = mAuthServiceMockGetSessionsByUserID{mock: m}
	m.GetSessionsByUserIDMock.callArgs = []*AuthServiceMockGetSessionsByUserIDParams{}

	m.ListUserRolesMock = mAuthServiceMockListUserRoles{mock: m}
	m.ListUserRolesMock.callArgs = []*AuthServiceMockListUserRolesParams{}

	m.LoginMock = mAuthServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*AuthServiceMockLoginParams{}

	m.RefreshTokensMock = mAuthServiceMockRefreshTokens{mock: m}
	m.RefreshTokensMock.callArgs = []*AuthServiceMockRefreshTokensParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockAddUserRole struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockAddUserRoleExpectation
	expectations       []*AuthServiceMockAddUserRoleExpectation

	callArgs []*AuthServiceMockAddUserRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockAddUserRoleExpectation specifies expectation struct of the AuthService.AddUserRole
type AuthServiceMockAddUserRoleExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockAddUserRoleParams
	paramPtrs          *AuthServiceMockAddUserRoleParamPtrs
	expectationOrigins AuthServiceMockAddUserRoleExpectationOrigins
	results            *AuthServiceMockAddUserRoleResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockAddUserRoleParams contains parameters of the AuthService.AddUserRole
type AuthServiceMockAddUserRoleParams struct {
	ctx  context.Context
	role auth.UserRole
}

// AuthServiceMockAddUserRoleParamPtrs contains pointers to parameters of the AuthService.AddUserRole
type AuthServiceMockAddUserRoleParamPtrs struct {
	ctx  *context.Context
	role *auth.UserRole
}

// AuthServiceMockAddUserRoleResults contains results of the AuthService.AddUserRole
type AuthServiceMockAddUserRoleResults struct {
	err error
}

// AuthServiceMockAddUserRoleOrigins contains origins of expectations of the AuthService.AddUserRole
type AuthServiceMockAddUserRoleExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUserRole *mAuthServiceMockAddUserRole) Optional() *mAuthServiceMockAddUserRole {
	mmAddUserRole.optional = true
	return mmAddUserRole
}

// Expect sets up expected params for AuthService.AddUserRole
func (mmAddUserRole *mAuthServiceMockAddUserRole) Expect(ctx context.Context, role auth.UserRole) *mAuthServiceMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &AuthServiceMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.paramPtrs != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by ExpectParams functions")
	}

	mmAddUserRole.defaultExpectation.params = &AuthServiceMockAddUserRoleParams{ctx, role}
	mmAddUserRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUserRole.expectations {
		if minimock.Equal(e.params, mmAddUserRole.defaultExpectation.params) {
			mmAddUserRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUserRole.defaultExpectation.params)
		}
	}

	return mmAddUserRole
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.AddUserRole
func (mmAddUserRole *mAuthServiceMockAddUserRole) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &AuthServiceMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.params != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Expect")
	}

	if mmAddUserRole.defaultExpectation.paramPtrs == nil {
		mmAddUserRole.defaultExpectation.paramPtrs = &AuthServiceMockAddUserRoleParamPtrs{}
	}
	mmAddUserRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddUserRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddUserRole
}

// ExpectRoleParam2 sets up expected param role for AuthService.AddUserRole
func (mmAddUserRole *mAuthServiceMockAddUserRole) ExpectRoleParam2(role auth.UserRole) *mAuthServiceMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &AuthServiceMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.params != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Expect")
	}

	if mmAddUserRole.defaultExpectation.paramPtrs == nil {
		mmAddUserRole.defaultExpectation.paramPtrs = &AuthServiceMockAddUserRoleParamPtrs{}
	}
	mmAddUserRole.defaultExpectation.paramPtrs.role = &role
	mmAddUserRole.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmAddUserRole
}

// Inspect accepts an inspector function that has same arguments as the AuthService.AddUserRole
func (mmAddUserRole *mAuthServiceMockAddUserRole) Inspect(f func(ctx context.Context, role auth.UserRole)) *mAuthServiceMockAddUserRole {
	if mmAddUserRole.mock.inspectFuncAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.AddUserRole")
	}

	mmAddUserRole.mock.inspectFuncAddUserRole = f

	return mmAddUserRole
}

// Return sets up results that will be returned by AuthService.AddUserRole
func (mmAddUserRole *mAuthServiceMockAddUserRole) Return(err error) *AuthServiceMock {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &AuthServiceMockAddUserRoleExpectation{mock: mmAddUserRole.mock}
	}
	mmAddUserRole.defaultExpectation.results = &AuthServiceMockAddUserRoleResults{err}
	mmAddUserRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUserRole.mock
}

// Set uses given function f to mock the AuthService.AddUserRole method
func (mmAddUserRole *mAuthServiceMockAddUserRole) Set(f func(ctx context.Context, role auth.UserRole) (err error)) *AuthServiceMock {
	if mmAddUserRole.defaultExpectation != nil {
		mmAddUserRole.mock.t.Fatalf("Default expectation is already set for the AuthService.AddUserRole method")
	}

	if len(mmAddUserRole.expectations) > 0 {
		mmAddUserRole.mock.t.Fatalf("Some expectations are already set for the AuthService.AddUserRole method")
	}

	mmAddUserRole.mock.funcAddUserRole = f
	mmAddUserRole.mock.funcAddUserRoleOrigin = minimock.CallerInfo(1)
	return mmAddUserRole.mock
}

// When sets expectation for the AuthService.AddUserRole which will trigger the result defined by the following
// Then helper
func (mmAddUserRole *mAuthServiceMockAddUserRole) When(ctx context.Context, role auth.UserRole) *AuthServiceMockAddUserRoleExpectation {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("AuthServiceMock.AddUserRole mock is already set by Set")
	}

	expectation := &AuthServiceMockAddUserRoleExpectation{
		mock:               mmAddUserRole.mock,
		params:             &AuthServiceMockAddUserRoleParams{ctx, role},
		expectationOrigins: AuthServiceMockAddUserRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddUserRole.expectations = append(mmAddUserRole.expectations, expectation)
	return expectation
}

// Then sets up AuthService.AddUserRole return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockAddUserRoleExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockAddUserRoleResults{err}
	return e.mock
}

// Times sets number of times AuthService.AddUserRole should be invoked
func (mmAddUserRole *mAuthServiceMockAddUserRole) Times(n uint64) *mAuthServiceMockAddUserRole {
	if n == 0 {
		mmAddUserRole.mock.t.Fatalf("Times of AuthServiceMock.AddUserRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUserRole.expectedInvocations, n)
	mmAddUserRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUserRole
}

func (mmAddUserRole *mAuthServiceMockAddUserRole) invocationsDone() bool {
	if len(mmAddUserRole.expectations) == 0 && mmAddUserRole.defaultExpectation == nil && mmAddUserRole.mock.funcAddUserRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUserRole.mock.afterAddUserRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUserRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUserRole implements mm_http.AuthService
func (mmAddUserRole *AuthServiceMock) AddUserRole(ctx context.Context, role auth.UserRole) (err error) {
	mm_atomic.AddUint64(&mmAddUserRole.beforeAddUserRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUserRole.afterAddUserRoleCounter, 1)

	mmAddUserRole.t.Helper()

	if mmAddUserRole.inspectFuncAddUserRole != nil {
		mmAddUserRole.inspectFuncAddUserRole(ctx, role)
	}

	mm_params := AuthServiceMockAddUserRoleParams{ctx, role}

	// Record call args
	mmAddUserRole.AddUserRoleMock.mutex.Lock()
	mmAddUserRole.AddUserRoleMock.callArgs = append(mmAddUserRole.AddUserRoleMock.callArgs, &mm_params)
	mmAddUserRole.AddUserRoleMock.mutex.Unlock()

	for _, e := range mmAddUserRole.AddUserRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUserRole.AddUserRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUserRole.AddUserRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUserRole.AddUserRoleMock.defaultExpectation.params
		mm_want_ptrs := mmAddUserRole.AddUserRoleMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockAddUserRoleParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUserRole.t.Errorf("AuthServiceMock.AddUserRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmAddUserRole.t.Errorf("AuthServiceMock.AddUserRole got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUserRole.t.Errorf("AuthServiceMock.AddUserRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUserRole.AddUserRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUserRole.t.Fatal("No results are set for the AuthServiceMock.AddUserRole")
		}
		return (*mm_results).err
	}
	if mmAddUserRole.funcAddUserRole != nil {
		return mmAddUserRole.funcAddUserRole(ctx, role)
	}
	mmAddUserRole.t.Fatalf("Unexpected call to AuthServiceMock.AddUserRole. %v %v", ctx, role)
	return
}

// AddUserRoleAfterCounter returns a count of finished AuthServiceMock.AddUserRole invocations
func (mmAddUserRole *AuthServiceMock) AddUserRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUserRole.afterAddUserRoleCounter)
}

// AddUserRoleBeforeCounter returns a count of AuthServiceMock.AddUserRole invocations
func (mmAddUserRole *AuthServiceMock) AddUserRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUserRole.beforeAddUserRoleCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.AddUserRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUserRole *mAuthServiceMockAddUserRole) Calls() []*AuthServiceMockAddUserRoleParams {
	mmAddUserRole.mutex.RLock()

	argCopy := make([]*AuthServiceMockAddUserRoleParams, len(mmAddUserRole.callArgs))
	copy(argCopy, mmAddUserRole.callArgs)

	mmAddUserRole.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserRoleDone returns true if the count of the AddUserRole invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockAddUserRoleDone() bool {
	if m.AddUserRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUserRoleMock.invocationsDone()
}

// MinimockAddUserRoleInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockAddUserRoleInspect() {
	for _, e := range m.AddUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.AddUserRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUserRoleCounter := mm_atomic.LoadUint64(&m.afterAddUserRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserRoleMock.defaultExpectation != nil && afterAddUserRoleCounter < 1 {
		if m.AddUserRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.AddUserRole at\n%s", m.AddUserRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.AddUserRole at\n%s with params: %#v", m.AddUserRoleMock.defaultExpectation.expectationOrigins.origin, *m.AddUserRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUserRole != nil && afterAddUserRoleCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.AddUserRole at\n%s", m.funcAddUserRoleOrigin)
	}

	if !m.AddUserRoleMock.invocationsDone() && afterAddUserRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.AddUserRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUserRoleMock.expectedInvocations), m.AddUserRoleMock.expectedInvocationsOrigin, afterAddUserRoleCounter)
	}
}

type mAuthServiceMockDeleteSession struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockDeleteSessionExpectation
	expectations       []*AuthServiceMockDeleteSessionExpectation

	callArgs []*AuthServiceMockDeleteSessionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockDeleteSessionExpectation specifies expectation struct of the AuthService.DeleteSession
type AuthServiceMockDeleteSessionExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockDeleteSessionParams
	paramPtrs          *AuthServiceMockDeleteSessionParamPtrs
	expectationOrigins AuthServiceMockDeleteSessionExpectationOrigins
	results            *AuthServiceMockDeleteSessionResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockDeleteSessionParams contains parameters of the AuthService.DeleteSession
type AuthServiceMockDeleteSessionParams struct {
	ctx    context.Context
	userID uuid.UUID
	id     uuid.UUID
}

// AuthServiceMockDeleteSessionParamPtrs contains pointers to parameters of the AuthService.DeleteSession
type AuthServiceMockDeleteSessionParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
	id     *uuid.UUID
}

// AuthServiceMockDeleteSessionResults contains results of the AuthService.DeleteSession
type AuthServiceMockDeleteSessionResults struct {
	err error
}

// AuthServiceMockDeleteSessionOrigins contains origins of expectations of the AuthService.DeleteSession
type AuthServiceMockDeleteSessionExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originId     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSession *mAuthServiceMockDeleteSession) Optional() *mAuthServiceMockDeleteSession {
	mmDeleteSession.optional = true
	return mmDeleteSession
}

// Expect sets up expected params for AuthService.DeleteSession
func (mmDeleteSession *mAuthServiceMockDeleteSession) Expect(ctx context.Context, userID uuid.UUID, id uuid.UUID) *mAuthServiceMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &AuthServiceMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.paramPtrs != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by ExpectParams functions")
	}

	mmDeleteSession.defaultExpectation.params = &AuthServiceMockDeleteSessionParams{ctx, userID, id}
	mmDeleteSession.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSession.expectations {
		if minimock.Equal(e.params, mmDeleteSession.defaultExpectation.params) {
			mmDeleteSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSession.defaultExpectation.params)
		}
	}

	return mmDeleteSession
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.DeleteSession
func (mmDeleteSession *mAuthServiceMockDeleteSession) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &AuthServiceMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.params != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Expect")
	}

	if mmDeleteSession.defaultExpectation.paramPtrs == nil {
		mmDeleteSession.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionParamPtrs{}
	}
	mmDeleteSession.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSession.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSession
}

// ExpectUserIDParam2 sets up expected param userID for AuthService.DeleteSession
func (mmDeleteSession *mAuthServiceMockDeleteSession) ExpectUserIDParam2(userID uuid.UUID) *mAuthServiceMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &AuthServiceMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.params != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Expect")
	}

	if mmDeleteSession.defaultExpectation.paramPtrs == nil {
		mmDeleteSession.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionParamPtrs{}
	}
	mmDeleteSession.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSession.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSession
}

// ExpectIdParam3 sets up expected param id for AuthService.DeleteSession
func (mmDeleteSession *mAuthServiceMockDeleteSession) ExpectIdParam3(id uuid.UUID) *mAuthServiceMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &AuthServiceMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.params != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Expect")
	}

	if mmDeleteSession.defaultExpectation.paramPtrs == nil {
		mmDeleteSession.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionParamPtrs{}
	}
	mmDeleteSession.defaultExpectation.paramPtrs.id = &id
	mmDeleteSession.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteSession
}

// Inspect accepts an inspector function that has same arguments as the AuthService.DeleteSession
func (mmDeleteSession *mAuthServiceMockDeleteSession) Inspect(f func(ctx context.Context, userID uuid.UUID, id uuid.UUID)) *mAuthServiceMockDeleteSession {
	if mmDeleteSession.mock.inspectFuncDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.DeleteSession")
	}

	mmDeleteSession.mock.inspectFuncDeleteSession = f

	return mmDeleteSession
}

// Return sets up results that will be returned by AuthService.DeleteSession
func (mmDeleteSession *mAuthServiceMockDeleteSession) Return(err error) *AuthServiceMock {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &AuthServiceMockDeleteSessionExpectation{mock: mmDeleteSession.mock}
	}
	mmDeleteSession.defaultExpectation.results = &AuthServiceMockDeleteSessionResults{err}
	mmDeleteSession.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSession.mock
}

// Set uses given function f to mock the AuthService.DeleteSession method
func (mmDeleteSession *mAuthServiceMockDeleteSession) Set(f func(ctx context.Context, userID uuid.UUID, id uuid.UUID) (err error)) *AuthServiceMock {
	if mmDeleteSession.defaultExpectation != nil {
		mmDeleteSession.mock.t.Fatalf("Default expectation is already set for the AuthService.DeleteSession method")
	}

	if len(mmDeleteSession.expectations) > 0 {
		mmDeleteSession.mock.t.Fatalf("Some expectations are already set for the AuthService.DeleteSession method")
	}

	mmDeleteSession.mock.funcDeleteSession = f
	mmDeleteSession.mock.funcDeleteSessionOrigin = minimock.CallerInfo(1)
	return mmDeleteSession.mock
}

// When sets expectation for the AuthService.DeleteSession which will trigger the result defined by the following
// Then helper
func (mmDeleteSession *mAuthServiceMockDeleteSession) When(ctx context.Context, userID uuid.UUID, id uuid.UUID) *AuthServiceMockDeleteSessionExpectation {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("AuthServiceMock.DeleteSession mock is already set by Set")
	}

	expectation := &AuthServiceMockDeleteSessionExpectation{
		mock:               mmDeleteSession.mock,
		params:             &AuthServiceMockDeleteSessionParams{ctx, userID, id},
		expectationOrigins: AuthServiceMockDeleteSessionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSession.expectations = append(mmDeleteSession.expectations, expectation)
	return expectation
}

// Then sets up AuthService.DeleteSession return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockDeleteSessionExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockDeleteSessionResults{err}
	return e.mock
}

// Times sets number of times AuthService.DeleteSession should be invoked
func (mmDeleteSession *mAuthServiceMockDeleteSession) Times(n uint64) *mAuthServiceMockDeleteSession {
	if n == 0 {
		mmDeleteSession.mock.t.Fatalf("Times of AuthServiceMock.DeleteSession mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSession.expectedInvocations, n)
	mmDeleteSession.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSession
}

func (mmDeleteSession *mAuthServiceMockDeleteSession) invocationsDone() bool {
	if len(mmDeleteSession.expectations) == 0 && mmDeleteSession.defaultExpectation == nil && mmDeleteSession.mock.funcDeleteSession == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSession.mock.afterDeleteSessionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSession.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSession implements mm_http.AuthService
func (mmDeleteSession *AuthServiceMock) DeleteSession(ctx context.Context, userID uuid.UUID, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSession.beforeDeleteSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSession.afterDeleteSessionCounter, 1)

	mmDeleteSession.t.Helper()

	if mmDeleteSession.inspectFuncDeleteSession != nil {
		mmDeleteSession.inspectFuncDeleteSession(ctx, userID, id)
	}

	mm_params := AuthServiceMockDeleteSessionParams{ctx, userID, id}

	// Record call args
	mmDeleteSession.DeleteSessionMock.mutex.Lock()
	mmDeleteSession.DeleteSessionMock.callArgs = append(mmDeleteSession.DeleteSessionMock.callArgs, &mm_params)
	mmDeleteSession.DeleteSessionMock.mutex.Unlock()

	for _, e := range mmDeleteSession.DeleteSessionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSession.DeleteSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSession.DeleteSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSession.DeleteSessionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSession.DeleteSessionMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockDeleteSessionParams{ctx, userID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSession.t.Errorf("AuthServiceMock.DeleteSession got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSession.t.Errorf("AuthServiceMock.DeleteSession got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteSession.t.Errorf("AuthServiceMock.DeleteSession got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSession.t.Errorf("AuthServiceMock.DeleteSession got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSession.DeleteSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSession.t.Fatal("No results are set for the AuthServiceMock.DeleteSession")
		}
		return (*mm_results).err
	}
	if mmDeleteSession.funcDeleteSession != nil {
		return mmDeleteSession.funcDeleteSession(ctx, userID, id)
	}
	mmDeleteSession.t.Fatalf("Unexpected call to AuthServiceMock.DeleteSession. %v %v %v", ctx, userID, id)
	return
}

// DeleteSessionAfterCounter returns a count of finished AuthServiceMock.DeleteSession invocations
func (mmDeleteSession *AuthServiceMock) DeleteSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.afterDeleteSessionCounter)
}

// DeleteSessionBeforeCounter returns a count of AuthServiceMock.DeleteSession invocations
func (mmDeleteSession *AuthServiceMock) DeleteSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.beforeDeleteSessionCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.DeleteSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSession *mAuthServiceMockDeleteSession) Calls() []*AuthServiceMockDeleteSessionParams {
	mmDeleteSession.mutex.RLock()

	argCopy := make([]*AuthServiceMockDeleteSessionParams, len(mmDeleteSession.callArgs))
	copy(argCopy, mmDeleteSession.callArgs)

	mmDeleteSession.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionDone returns true if the count of the DeleteSession invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockDeleteSessionDone() bool {
	if m.DeleteSessionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionMock.invocationsDone()
}

// MinimockDeleteSessionInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockDeleteSessionInspect() {
	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSession at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionMock.defaultExpectation != nil && afterDeleteSessionCounter < 1 {
		if m.DeleteSessionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSession at\n%s", m.DeleteSessionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSession at\n%s with params: %#v", m.DeleteSessionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSession != nil && afterDeleteSessionCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.DeleteSession at\n%s", m.funcDeleteSessionOrigin)
	}

	if !m.DeleteSessionMock.invocationsDone() && afterDeleteSessionCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.DeleteSession at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionMock.expectedInvocations), m.DeleteSessionMock.expectedInvocationsOrigin, afterDeleteSessionCounter)
	}
}

type mAuthServiceMockDeleteSessionsByUserID struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockDeleteSessionsByUserIDExpectation
	expectations       []*AuthServiceMockDeleteSessionsByUserIDExpectation

	callArgs []*AuthServiceMockDeleteSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockDeleteSessionsByUserIDExpectation specifies expectation struct of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockDeleteSessionsByUserIDParams
	paramPtrs          *AuthServiceMockDeleteSessionsByUserIDParamPtrs
	expectationOrigins AuthServiceMockDeleteSessionsByUserIDExpectationOrigins
	results            *AuthServiceMockDeleteSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockDeleteSessionsByUserIDParams contains parameters of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// AuthServiceMockDeleteSessionsByUserIDParamPtrs contains pointers to parameters of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// AuthServiceMockDeleteSessionsByUserIDResults contains results of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDResults struct {
	err error
}

// AuthServiceMockDeleteSessionsByUserIDOrigins contains origins of expectations of the AuthService.DeleteSessionsByUserID
type AuthServiceMockDeleteSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Optional() *mAuthServiceMockDeleteSessionsByUserID {
	mmDeleteSessionsByUserID.optional = true
	return mmDeleteSessionsByUserID
}

// Expect sets up expected params for AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteSessionsByUserID.defaultExpectation.params = &AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID}
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteSessionsByUserID.defaultExpectation.params) {
			mmDeleteSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &AuthServiceMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mAuthServiceMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.DeleteSessionsByUserID")
	}

	mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID = f

	return mmDeleteSessionsByUserID
}

// Return sets up results that will be returned by AuthService.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Return(err error) *AuthServiceMock {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &AuthServiceMockDeleteSessionsByUserIDExpectation{mock: mmDeleteSessionsByUserID.mock}
	}
	mmDeleteSessionsByUserID.defaultExpectation.results = &AuthServiceMockDeleteSessionsByUserIDResults{err}
	mmDeleteSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// Set uses given function f to mock the AuthService.DeleteSessionsByUserID method
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (err error)) *AuthServiceMock {
	if mmDeleteSessionsByUserID.defaultExpectation != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the AuthService.DeleteSessionsByUserID method")
	}

	if len(mmDeleteSessionsByUserID.expectations) > 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the AuthService.DeleteSessionsByUserID method")
	}

	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID = f
	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// When sets expectation for the AuthService.DeleteSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *AuthServiceMockDeleteSessionsByUserIDExpectation {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("AuthServiceMock.DeleteSessionsByUserID mock is already set by Set")
	}

	expectation := &AuthServiceMockDeleteSessionsByUserIDExpectation{
		mock:               mmDeleteSessionsByUserID.mock,
		params:             &AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID},
		expectationOrigins: AuthServiceMockDeleteSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSessionsByUserID.expectations = append(mmDeleteSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up AuthService.DeleteSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockDeleteSessionsByUserIDExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockDeleteSessionsByUserIDResults{err}
	return e.mock
}

// Times sets number of times AuthService.DeleteSessionsByUserID should be invoked
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Times(n uint64) *mAuthServiceMockDeleteSessionsByUserID {
	if n == 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Times of AuthServiceMock.DeleteSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSessionsByUserID.expectedInvocations, n)
	mmDeleteSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID
}

func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) invocationsDone() bool {
	if len(mmDeleteSessionsByUserID.expectations) == 0 && mmDeleteSessionsByUserID.defaultExpectation == nil && mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.mock.afterDeleteSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSessionsByUserID implements mm_http.AuthService
func (mmDeleteSessionsByUserID *AuthServiceMock) DeleteSessionsByUserID(ctx context.Context, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter, 1)

	mmDeleteSessionsByUserID.t.Helper()

	if mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID(ctx, userID)
	}

	mm_params := AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Lock()
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs = append(mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs, &mm_params)
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockDeleteSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSessionsByUserID.t.Errorf("AuthServiceMock.DeleteSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSessionsByUserID.t.Errorf("AuthServiceMock.DeleteSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSessionsByUserID.t.Errorf("AuthServiceMock.DeleteSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSessionsByUserID.t.Fatal("No results are set for the AuthServiceMock.DeleteSessionsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteSessionsByUserID.funcDeleteSessionsByUserID != nil {
		return mmDeleteSessionsByUserID.funcDeleteSessionsByUserID(ctx, userID)
	}
	mmDeleteSessionsByUserID.t.Fatalf("Unexpected call to AuthServiceMock.DeleteSessionsByUserID. %v %v", ctx, userID)
	return
}

// DeleteSessionsByUserIDAfterCounter returns a count of finished AuthServiceMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *AuthServiceMock) DeleteSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter)
}

// DeleteSessionsByUserIDBeforeCounter returns a count of AuthServiceMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *AuthServiceMock) DeleteSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.DeleteSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSessionsByUserID *mAuthServiceMockDeleteSessionsByUserID) Calls() []*AuthServiceMockDeleteSessionsByUserIDParams {
	mmDeleteSessionsByUserID.mutex.RLock()

	argCopy := make([]*AuthServiceMockDeleteSessionsByUserIDParams, len(mmDeleteSessionsByUserID.callArgs))
	copy(argCopy, mmDeleteSessionsByUserID.callArgs)

	mmDeleteSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionsByUserIDDone returns true if the count of the DeleteSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockDeleteSessionsByUserIDDone() bool {
	if m.DeleteSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionsByUserIDMock.invocationsDone()
}

// MinimockDeleteSessionsByUserIDInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockDeleteSessionsByUserIDInspect() {
	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionsByUserIDMock.defaultExpectation != nil && afterDeleteSessionsByUserIDCounter < 1 {
		if m.DeleteSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s", m.DeleteSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s with params: %#v", m.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSessionsByUserID != nil && afterDeleteSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.DeleteSessionsByUserID at\n%s", m.funcDeleteSessionsByUserIDOrigin)
	}

	if !m.DeleteSessionsByUserIDMock.invocationsDone() && afterDeleteSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.DeleteSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionsByUserIDMock.expectedInvocations), m.DeleteSessionsByUserIDMock.expectedInvocationsOrigin, afterDeleteSessionsByUserIDCounter)
	}
}

type mAuthServiceMockDeleteUserRole struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockDeleteUserRoleExpectation
	expectations       []*AuthServiceMockDeleteUserRoleExpectation

	callArgs []*AuthServiceMockDeleteUserRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockDeleteUserRoleExpectation specifies expectation struct of the AuthService.DeleteUserRole
type AuthServiceMockDeleteUserRoleExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockDeleteUserRoleParams
	paramPtrs          *AuthServiceMockDeleteUserRoleParamPtrs
	expectationOrigins AuthServiceMockDeleteUserRoleExpectationOrigins
	results            *AuthServiceMockDeleteUserRoleResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockDeleteUserRoleParams contains parameters of the AuthService.DeleteUserRole
type AuthServiceMockDeleteUserRoleParams struct {
	ctx  context.Context
	role auth.UserRole
}

// AuthServiceMockDeleteUserRoleParamPtrs contains pointers to parameters of the AuthService.DeleteUserRole
type AuthServiceMockDeleteUserRoleParamPtrs struct {
	ctx  *context.Context
	role *auth.UserRole
}

// AuthServiceMockDeleteUserRoleResults contains results of the AuthService.DeleteUserRole
type AuthServiceMockDeleteUserRoleResults struct {
	err error
}

// AuthServiceMockDeleteUserRoleOrigins contains origins of expectations of the AuthService.DeleteUserRole
type AuthServiceMockDeleteUserRoleExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Optional() *mAuthServiceMockDeleteUserRole {
	mmDeleteUserRole.optional = true
	return mmDeleteUserRole
}

// Expect sets up expected params for AuthService.DeleteUserRole
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Expect(ctx context.Context, role auth.UserRole) *mAuthServiceMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &AuthServiceMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by ExpectParams functions")
	}

	mmDeleteUserRole.defaultExpectation.params = &AuthServiceMockDeleteUserRoleParams{ctx, role}
	mmDeleteUserRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUserRole.expectations {
		if minimock.Equal(e.params, mmDeleteUserRole.defaultExpectation.params) {
			mmDeleteUserRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserRole.defaultExpectation.params)
		}
	}

	return mmDeleteUserRole
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.DeleteUserRole
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &AuthServiceMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.params != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Expect")
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs == nil {
		mmDeleteUserRole.defaultExpectation.paramPtrs = &AuthServiceMockDeleteUserRoleParamPtrs{}
	}
	mmDeleteUserRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUserRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUserRole
}

// ExpectRoleParam2 sets up expected param role for AuthService.DeleteUserRole
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) ExpectRoleParam2(role auth.UserRole) *mAuthServiceMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &AuthServiceMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.params != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Expect")
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs == nil {
		mmDeleteUserRole.defaultExpectation.paramPtrs = &AuthServiceMockDeleteUserRoleParamPtrs{}
	}
	mmDeleteUserRole.defaultExpectation.paramPtrs.role = &role
	mmDeleteUserRole.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmDeleteUserRole
}

// Inspect accepts an inspector function that has same arguments as the AuthService.DeleteUserRole
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Inspect(f func(ctx context.Context, role auth.UserRole)) *mAuthServiceMockDeleteUserRole {
	if mmDeleteUserRole.mock.inspectFuncDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.DeleteUserRole")
	}

	mmDeleteUserRole.mock.inspectFuncDeleteUserRole = f

	return mmDeleteUserRole
}

// Return sets up results that will be returned by AuthService.DeleteUserRole
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Return(err error) *AuthServiceMock {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &AuthServiceMockDeleteUserRoleExpectation{mock: mmDeleteUserRole.mock}
	}
	mmDeleteUserRole.defaultExpectation.results = &AuthServiceMockDeleteUserRoleResults{err}
	mmDeleteUserRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole.mock
}

// Set uses given function f to mock the AuthService.DeleteUserRole method
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Set(f func(ctx context.Context, role auth.UserRole) (err error)) *AuthServiceMock {
	if mmDeleteUserRole.defaultExpectation != nil {
		mmDeleteUserRole.mock.t.Fatalf("Default expectation is already set for the AuthService.DeleteUserRole method")
	}

	if len(mmDeleteUserRole.expectations) > 0 {
		mmDeleteUserRole.mock.t.Fatalf("Some expectations are already set for the AuthService.DeleteUserRole method")
	}

	mmDeleteUserRole.mock.funcDeleteUserRole = f
	mmDeleteUserRole.mock.funcDeleteUserRoleOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole.mock
}

// When sets expectation for the AuthService.DeleteUserRole which will trigger the result defined by the following
// Then helper
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) When(ctx context.Context, role auth.UserRole) *AuthServiceMockDeleteUserRoleExpectation {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("AuthServiceMock.DeleteUserRole mock is already set by Set")
	}

	expectation := &AuthServiceMockDeleteUserRoleExpectation{
		mock:               mmDeleteUserRole.mock,
		params:             &AuthServiceMockDeleteUserRoleParams{ctx, role},
		expectationOrigins: AuthServiceMockDeleteUserRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUserRole.expectations = append(mmDeleteUserRole.expectations, expectation)
	return expectation
}

// Then sets up AuthService.DeleteUserRole return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockDeleteUserRoleExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockDeleteUserRoleResults{err}
	return e.mock
}

// Times sets number of times AuthService.DeleteUserRole should be invoked
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Times(n uint64) *mAuthServiceMockDeleteUserRole {
	if n == 0 {
		mmDeleteUserRole.mock.t.Fatalf("Times of AuthServiceMock.DeleteUserRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUserRole.expectedInvocations, n)
	mmDeleteUserRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole
}

func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) invocationsDone() bool {
	if len(mmDeleteUserRole.expectations) == 0 && mmDeleteUserRole.defaultExpectation == nil && mmDeleteUserRole.mock.funcDeleteUserRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUserRole.mock.afterDeleteUserRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUserRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUserRole implements mm_http.AuthService
func (mmDeleteUserRole *AuthServiceMock) DeleteUserRole(ctx context.Context, role auth.UserRole) (err error) {
	mm_atomic.AddUint64(&mmDeleteUserRole.beforeDeleteUserRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserRole.afterDeleteUserRoleCounter, 1)

	mmDeleteUserRole.t.Helper()

	if mmDeleteUserRole.inspectFuncDeleteUserRole != nil {
		mmDeleteUserRole.inspectFuncDeleteUserRole(ctx, role)
	}

	mm_params := AuthServiceMockDeleteUserRoleParams{ctx, role}

	// Record call args
	mmDeleteUserRole.DeleteUserRoleMock.mutex.Lock()
	mmDeleteUserRole.DeleteUserRoleMock.callArgs = append(mmDeleteUserRole.DeleteUserRoleMock.callArgs, &mm_params)
	mmDeleteUserRole.DeleteUserRoleMock.mutex.Unlock()

	for _, e := range mmDeleteUserRole.DeleteUserRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockDeleteUserRoleParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUserRole.t.Errorf("AuthServiceMock.DeleteUserRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmDeleteUserRole.t.Errorf("AuthServiceMock.DeleteUserRole got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserRole.t.Errorf("AuthServiceMock.DeleteUserRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserRole.t.Fatal("No results are set for the AuthServiceMock.DeleteUserRole")
		}
		return (*mm_results).err
	}
	if mmDeleteUserRole.funcDeleteUserRole != nil {
		return mmDeleteUserRole.funcDeleteUserRole(ctx, role)
	}
	mmDeleteUserRole.t.Fatalf("Unexpected call to AuthServiceMock.DeleteUserRole. %v %v", ctx, role)
	return
}

// DeleteUserRoleAfterCounter returns a count of finished AuthServiceMock.DeleteUserRole invocations
func (mmDeleteUserRole *AuthServiceMock) DeleteUserRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserRole.afterDeleteUserRoleCounter)
}

// DeleteUserRoleBeforeCounter returns a count of AuthServiceMock.DeleteUserRole invocations
func (mmDeleteUserRole *AuthServiceMock) DeleteUserRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserRole.beforeDeleteUserRoleCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.DeleteUserRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserRole *mAuthServiceMockDeleteUserRole) Calls() []*AuthServiceMockDeleteUserRoleParams {
	mmDeleteUserRole.mutex.RLock()

	argCopy := make([]*AuthServiceMockDeleteUserRoleParams, len(mmDeleteUserRole.callArgs))
	copy(argCopy, mmDeleteUserRole.callArgs)

	mmDeleteUserRole.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserRoleDone returns true if the count of the DeleteUserRole invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockDeleteUserRoleDone() bool {
	if m.DeleteUserRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserRoleMock.invocationsDone()
}

// MinimockDeleteUserRoleInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockDeleteUserRoleInspect() {
	for _, e := range m.DeleteUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteUserRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserRoleCounter := mm_atomic.LoadUint64(&m.afterDeleteUserRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserRoleMock.defaultExpectation != nil && afterDeleteUserRoleCounter < 1 {
		if m.DeleteUserRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteUserRole at\n%s", m.DeleteUserRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.DeleteUserRole at\n%s with params: %#v", m.DeleteUserRoleMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserRole != nil && afterDeleteUserRoleCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.DeleteUserRole at\n%s", m.funcDeleteUserRoleOrigin)
	}

	if !m.DeleteUserRoleMock.invocationsDone() && afterDeleteUserRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.DeleteUserRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserRoleMock.expectedInvocations), m.DeleteUserRoleMock.expectedInvocationsOrigin, afterDeleteUserRoleCounter)
	}
}

type mAuthServiceMockGetSessionsByUserID struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetSessionsByUserIDExpectation
	expectations       []*AuthServiceMockGetSessionsByUserIDExpectation

	callArgs []*AuthServiceMockGetSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockGetSessionsByUserIDExpectation specifies expectation struct of the AuthService.GetSessionsByUserID
type AuthServiceMockGetSessionsByUserIDExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockGetSessionsByUserIDParams
	paramPtrs          *AuthServiceMockGetSessionsByUserIDParamPtrs
	expectationOrigins AuthServiceMockGetSessionsByUserIDExpectationOrigins
	results            *AuthServiceMockGetSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockGetSessionsByUserIDParams contains parameters of the AuthService.GetSessionsByUserID
type AuthServiceMockGetSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// AuthServiceMockGetSessionsByUserIDParamPtrs contains pointers to parameters of the AuthService.GetSessionsByUserID
type AuthServiceMockGetSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// AuthServiceMockGetSessionsByUserIDResults contains results of the AuthService.GetSessionsByUserID
type AuthServiceMockGetSessionsByUserIDResults struct {
	sa1 []auth.Session
	err error
}

// AuthServiceMockGetSessionsByUserIDOrigins contains origins of expectations of the AuthService.GetSessionsByUserID
type AuthServiceMockGetSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Optional() *mAuthServiceMockGetSessionsByUserID {
	mmGetSessionsByUserID.optional = true
	return mmGetSessionsByUserID
}

// Expect sets up expected params for AuthService.GetSessionsByUserID
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mAuthServiceMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &AuthServiceMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmGetSessionsByUserID.defaultExpectation.params = &AuthServiceMockGetSessionsByUserIDParams{ctx, userID}
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmGetSessionsByUserID.defaultExpectation.params) {
			mmGetSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmGetSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.GetSessionsByUserID
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &AuthServiceMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.params != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Expect")
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetSessionsByUserID.defaultExpectation.paramPtrs = &AuthServiceMockGetSessionsByUserIDParamPtrs{}
	}
	mmGetSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for AuthService.GetSessionsByUserID
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mAuthServiceMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &AuthServiceMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.params != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Expect")
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetSessionsByUserID.defaultExpectation.paramPtrs = &AuthServiceMockGetSessionsByUserIDParamPtrs{}
	}
	mmGetSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the AuthService.GetSessionsByUserID
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mAuthServiceMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.inspectFuncGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.GetSessionsByUserID")
	}

	mmGetSessionsByUserID.mock.inspectFuncGetSessionsByUserID = f

	return mmGetSessionsByUserID
}

// Return sets up results that will be returned by AuthService.GetSessionsByUserID
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Return(sa1 []auth.Session, err error) *AuthServiceMock {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &AuthServiceMockGetSessionsByUserIDExpectation{mock: mmGetSessionsByUserID.mock}
	}
	mmGetSessionsByUserID.defaultExpectation.results = &AuthServiceMockGetSessionsByUserIDResults{sa1, err}
	mmGetSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID.mock
}

// Set uses given function f to mock the AuthService.GetSessionsByUserID method
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (sa1 []auth.Session, err error)) *AuthServiceMock {
	if mmGetSessionsByUserID.defaultExpectation != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the AuthService.GetSessionsByUserID method")
	}

	if len(mmGetSessionsByUserID.expectations) > 0 {
		mmGetSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the AuthService.GetSessionsByUserID method")
	}

	mmGetSessionsByUserID.mock.funcGetSessionsByUserID = f
	mmGetSessionsByUserID.mock.funcGetSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID.mock
}

// When sets expectation for the AuthService.GetSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *AuthServiceMockGetSessionsByUserIDExpectation {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("AuthServiceMock.GetSessionsByUserID mock is already set by Set")
	}

	expectation := &AuthServiceMockGetSessionsByUserIDExpectation{
		mock:               mmGetSessionsByUserID.mock,
		params:             &AuthServiceMockGetSessionsByUserIDParams{ctx, userID},
		expectationOrigins: AuthServiceMockGetSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSessionsByUserID.expectations = append(mmGetSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up AuthService.GetSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetSessionsByUserIDExpectation) Then(sa1 []auth.Session, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetSessionsByUserIDResults{sa1, err}
	return e.mock
}

// Times sets number of times AuthService.GetSessionsByUserID should be invoked
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Times(n uint64) *mAuthServiceMockGetSessionsByUserID {
	if n == 0 {
		mmGetSessionsByUserID.mock.t.Fatalf("Times of AuthServiceMock.GetSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSessionsByUserID.expectedInvocations, n)
	mmGetSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID
}

func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) invocationsDone() bool {
	if len(mmGetSessionsByUserID.expectations) == 0 && mmGetSessionsByUserID.defaultExpectation == nil && mmGetSessionsByUserID.mock.funcGetSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSessionsByUserID.mock.afterGetSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSessionsByUserID implements mm_http.AuthService
func (mmGetSessionsByUserID *AuthServiceMock) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) (sa1 []auth.Session, err error) {
	mm_atomic.AddUint64(&mmGetSessionsByUserID.beforeGetSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSessionsByUserID.afterGetSessionsByUserIDCounter, 1)

	mmGetSessionsByUserID.t.Helper()

	if mmGetSessionsByUserID.inspectFuncGetSessionsByUserID != nil {
		mmGetSessionsByUserID.inspectFuncGetSessionsByUserID(ctx, userID)
	}

	mm_params := AuthServiceMockGetSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmGetSessionsByUserID.GetSessionsByUserIDMock.mutex.Lock()
	mmGetSessionsByUserID.GetSessionsByUserIDMock.callArgs = append(mmGetSessionsByUserID.GetSessionsByUserIDMock.callArgs, &mm_params)
	mmGetSessionsByUserID.GetSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetSessionsByUserID.GetSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSessionsByUserID.t.Errorf("AuthServiceMock.GetSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetSessionsByUserID.t.Errorf("AuthServiceMock.GetSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSessionsByUserID.t.Errorf("AuthServiceMock.GetSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSessionsByUserID.t.Fatal("No results are set for the AuthServiceMock.GetSessionsByUserID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSessionsByUserID.funcGetSessionsByUserID != nil {
		return mmGetSessionsByUserID.funcGetSessionsByUserID(ctx, userID)
	}
	mmGetSessionsByUserID.t.Fatalf("Unexpected call to AuthServiceMock.GetSessionsByUserID. %v %v", ctx, userID)
	return
}

// GetSessionsByUserIDAfterCounter returns a count of finished AuthServiceMock.GetSessionsByUserID invocations
func (mmGetSessionsByUserID *AuthServiceMock) GetSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionsByUserID.afterGetSessionsByUserIDCounter)
}

// GetSessionsByUserIDBeforeCounter returns a count of AuthServiceMock.GetSessionsByUserID invocations
func (mmGetSessionsByUserID *AuthServiceMock) GetSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionsByUserID.beforeGetSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.GetSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSessionsByUserID *mAuthServiceMockGetSessionsByUserID) Calls() []*AuthServiceMockGetSessionsByUserIDParams {
	mmGetSessionsByUserID.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetSessionsByUserIDParams, len(mmGetSessionsByUserID.callArgs))
	copy(argCopy, mmGetSessionsByUserID.callArgs)

	mmGetSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSessionsByUserIDDone returns true if the count of the GetSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetSessionsByUserIDDone() bool {
	if m.GetSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSessionsByUserIDMock.invocationsDone()
}

// MinimockGetSessionsByUserIDInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetSessionsByUserIDInspect() {
	for _, e := range m.GetSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.GetSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSessionsByUserIDMock.defaultExpectation != nil && afterGetSessionsByUserIDCounter < 1 {
		if m.GetSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.GetSessionsByUserID at\n%s", m.GetSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.GetSessionsByUserID at\n%s with params: %#v", m.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSessionsByUserID != nil && afterGetSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.GetSessionsByUserID at\n%s", m.funcGetSessionsByUserIDOrigin)
	}

	if !m.GetSessionsByUserIDMock.invocationsDone() && afterGetSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.GetSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSessionsByUserIDMock.expectedInvocations), m.GetSessionsByUserIDMock.expectedInvocationsOrigin, afterGetSessionsByUserIDCounter)
	}
}

type mAuthServiceMockListUserRoles struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockListUserRolesExpectation
	expectations       []*AuthServiceMockListUserRolesExpectation

	callArgs []*AuthServiceMockListUserRolesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockListUserRolesExpectation specifies expectation struct of the AuthService.ListUserRoles
type AuthServiceMockListUserRolesExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockListUserRolesParams
	paramPtrs          *AuthServiceMockListUserRolesParamPtrs
	expectationOrigins AuthServiceMockListUserRolesExpectationOrigins
	results            *AuthServiceMockListUserRolesResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockListUserRolesParams contains parameters of the AuthService.ListUserRoles
type AuthServiceMockListUserRolesParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// AuthServiceMockListUserRolesParamPtrs contains pointers to parameters of the AuthService.ListUserRoles
type AuthServiceMockListUserRolesParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// AuthServiceMockListUserRolesResults contains results of the AuthService.ListUserRoles
type AuthServiceMockListUserRolesResults struct {
	ua1 []auth.UserRole
	err error
}

// AuthServiceMockListUserRolesOrigins contains origins of expectations of the AuthService.ListUserRoles
type AuthServiceMockListUserRolesExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserRoles *mAuthServiceMockListUserRoles) Optional() *mAuthServiceMockListUserRoles {
	mmListUserRoles.optional = true
	return mmListUserRoles
}

// Expect sets up expected params for AuthService.ListUserRoles
func (mmListUserRoles *mAuthServiceMockListUserRoles) Expect(ctx context.Context, userID uuid.UUID) *mAuthServiceMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &AuthServiceMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.paramPtrs != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by ExpectParams functions")
	}

	mmListUserRoles.defaultExpectation.params = &AuthServiceMockListUserRolesParams{ctx, userID}
	mmListUserRoles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListUserRoles.expectations {
		if minimock.Equal(e.params, mmListUserRoles.defaultExpectation.params) {
			mmListUserRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserRoles.defaultExpectation.params)
		}
	}

	return mmListUserRoles
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.ListUserRoles
func (mmListUserRoles *mAuthServiceMockListUserRoles) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &AuthServiceMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.params != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Expect")
	}

	if mmListUserRoles.defaultExpectation.paramPtrs == nil {
		mmListUserRoles.defaultExpectation.paramPtrs = &AuthServiceMockListUserRolesParamPtrs{}
	}
	mmListUserRoles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListUserRoles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListUserRoles
}

// ExpectUserIDParam2 sets up expected param userID for AuthService.ListUserRoles
func (mmListUserRoles *mAuthServiceMockListUserRoles) ExpectUserIDParam2(userID uuid.UUID) *mAuthServiceMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &AuthServiceMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.params != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Expect")
	}

	if mmListUserRoles.defaultExpectation.paramPtrs == nil {
		mmListUserRoles.defaultExpectation.paramPtrs = &AuthServiceMockListUserRolesParamPtrs{}
	}
	mmListUserRoles.defaultExpectation.paramPtrs.userID = &userID
	mmListUserRoles.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListUserRoles
}

// Inspect accepts an inspector function that has same arguments as the AuthService.ListUserRoles
func (mmListUserRoles *mAuthServiceMockListUserRoles) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mAuthServiceMockListUserRoles {
	if mmListUserRoles.mock.inspectFuncListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.ListUserRoles")
	}

	mmListUserRoles.mock.inspectFuncListUserRoles = f

	return mmListUserRoles
}

// Return sets up results that will be returned by AuthService.ListUserRoles
func (mmListUserRoles *mAuthServiceMockListUserRoles) Return(ua1 []auth.UserRole, err error) *AuthServiceMock {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &AuthServiceMockListUserRolesExpectation{mock: mmListUserRoles.mock}
	}
	mmListUserRoles.defaultExpectation.results = &AuthServiceMockListUserRolesResults{ua1, err}
	mmListUserRoles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListUserRoles.mock
}

// Set uses given function f to mock the AuthService.ListUserRoles method
func (mmListUserRoles *mAuthServiceMockListUserRoles) Set(f func(ctx context.Context, userID uuid.UUID) (ua1 []auth.UserRole, err error)) *AuthServiceMock {
	if mmListUserRoles.defaultExpectation != nil {
		mmListUserRoles.mock.t.Fatalf("Default expectation is already set for the AuthService.ListUserRoles method")
	}

	if len(mmListUserRoles.expectations) > 0 {
		mmListUserRoles.mock.t.Fatalf("Some expectations are already set for the AuthService.ListUserRoles method")
	}

	mmListUserRoles.mock.funcListUserRoles = f
	mmListUserRoles.mock.funcListUserRolesOrigin = minimock.CallerInfo(1)
	return mmListUserRoles.mock
}

// When sets expectation for the AuthService.ListUserRoles which will trigger the result defined by the following
// Then helper
func (mmListUserRoles *mAuthServiceMockListUserRoles) When(ctx context.Context, userID uuid.UUID) *AuthServiceMockListUserRolesExpectation {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("AuthServiceMock.ListUserRoles mock is already set by Set")
	}

	expectation := &AuthServiceMockListUserRolesExpectation{
		mock:               mmListUserRoles.mock,
		params:             &AuthServiceMockListUserRolesParams{ctx, userID},
		expectationOrigins: AuthServiceMockListUserRolesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListUserRoles.expectations = append(mmListUserRoles.expectations, expectation)
	return expectation
}

// Then sets up AuthService.ListUserRoles return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockListUserRolesExpectation) Then(ua1 []auth.UserRole, err error) *AuthServiceMock {
	e.results = &AuthServiceMockListUserRolesResults{ua1, err}
	return e.mock
}

// Times sets number of times AuthService.ListUserRoles should be invoked
func (mmListUserRoles *mAuthServiceMockListUserRoles) Times(n uint64) *mAuthServiceMockListUserRoles {
	if n == 0 {
		mmListUserRoles.mock.t.Fatalf("Times of AuthServiceMock.ListUserRoles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListUserRoles.expectedInvocations, n)
	mmListUserRoles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListUserRoles
}

func (mmListUserRoles *mAuthServiceMockListUserRoles) invocationsDone() bool {
	if len(mmListUserRoles.expectations) == 0 && mmListUserRoles.defaultExpectation == nil && mmListUserRoles.mock.funcListUserRoles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListUserRoles.mock.afterListUserRolesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListUserRoles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListUserRoles implements mm_http.AuthService
func (mmListUserRoles *AuthServiceMock) ListUserRoles(ctx context.Context, userID uuid.UUID) (ua1 []auth.UserRole, err error) {
	mm_atomic.AddUint64(&mmListUserRoles.beforeListUserRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmListUserRoles.afterListUserRolesCounter, 1)

	mmListUserRoles.t.Helper()

	if mmListUserRoles.inspectFuncListUserRoles != nil {
		mmListUserRoles.inspectFuncListUserRoles(ctx, userID)
	}

	mm_params := AuthServiceMockListUserRolesParams{ctx, userID}

	// Record call args
	mmListUserRoles.ListUserRolesMock.mutex.Lock()
	mmListUserRoles.ListUserRolesMock.callArgs = append(mmListUserRoles.ListUserRolesMock.callArgs, &mm_params)
	mmListUserRoles.ListUserRolesMock.mutex.Unlock()

	for _, e := range mmListUserRoles.ListUserRolesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListUserRoles.ListUserRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUserRoles.ListUserRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmListUserRoles.ListUserRolesMock.defaultExpectation.params
		mm_want_ptrs := mmListUserRoles.ListUserRolesMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockListUserRolesParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListUserRoles.t.Errorf("AuthServiceMock.ListUserRoles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListUserRoles.t.Errorf("AuthServiceMock.ListUserRoles got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUserRoles.t.Errorf("AuthServiceMock.ListUserRoles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUserRoles.ListUserRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmListUserRoles.t.Fatal("No results are set for the AuthServiceMock.ListUserRoles")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListUserRoles.funcListUserRoles != nil {
		return mmListUserRoles.funcListUserRoles(ctx, userID)
	}
	mmListUserRoles.t.Fatalf("Unexpected call to AuthServiceMock.ListUserRoles. %v %v", ctx, userID)
	return
}

// ListUserRolesAfterCounter returns a count of finished AuthServiceMock.ListUserRoles invocations
func (mmListUserRoles *AuthServiceMock) ListUserRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserRoles.afterListUserRolesCounter)
}

// ListUserRolesBeforeCounter returns a count of AuthServiceMock.ListUserRoles invocations
func (mmListUserRoles *AuthServiceMock) ListUserRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserRoles.beforeListUserRolesCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.ListUserRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserRoles *mAuthServiceMockListUserRoles) Calls() []*AuthServiceMockListUserRolesParams {
	mmListUserRoles.mutex.RLock()

	argCopy := make([]*AuthServiceMockListUserRolesParams, len(mmListUserRoles.callArgs))
	copy(argCopy, mmListUserRoles.callArgs)

	mmListUserRoles.mutex.RUnlock()

	return argCopy
}

// MinimockListUserRolesDone returns true if the count of the ListUserRoles invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockListUserRolesDone() bool {
	if m.ListUserRolesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListUserRolesMock.invocationsDone()
}

// MinimockListUserRolesInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockListUserRolesInspect() {
	for _, e := range m.ListUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.ListUserRoles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListUserRolesCounter := mm_atomic.LoadUint64(&m.afterListUserRolesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListUserRolesMock.defaultExpectation != nil && afterListUserRolesCounter < 1 {
		if m.ListUserRolesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.ListUserRoles at\n%s", m.ListUserRolesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.ListUserRoles at\n%s with params: %#v", m.ListUserRolesMock.defaultExpectation.expectationOrigins.origin, *m.ListUserRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUserRoles != nil && afterListUserRolesCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.ListUserRoles at\n%s", m.funcListUserRolesOrigin)
	}

	if !m.ListUserRolesMock.invocationsDone() && afterListUserRolesCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.ListUserRoles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListUserRolesMock.expectedInvocations), m.ListUserRolesMock.expectedInvocationsOrigin, afterListUserRolesCounter)
	}
}

type mAuthServiceMockLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginExpectation
	expectations       []*AuthServiceMockLoginExpectation

	callArgs []*AuthServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockLoginExpectation specifies expectation struct of the AuthService.Login
type AuthServiceMockLoginExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockLoginParams
	paramPtrs          *AuthServiceMockLoginParamPtrs
	expectationOrigins AuthServiceMockLoginExpectationOrigins
	results            *AuthServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockLoginParams contains parameters of the AuthService.Login
type AuthServiceMockLoginParams struct {
	ctx context.Context
	req usecase.LoginCmd
}

// AuthServiceMockLoginParamPtrs contains pointers to parameters of the AuthService.Login
type AuthServiceMockLoginParamPtrs struct {
	ctx *context.Context
	req *usecase.LoginCmd
}

// AuthServiceMockLoginResults contains results of the AuthService.Login
type AuthServiceMockLoginResults struct {
	t1  auth.Tokens
	err error
}

// AuthServiceMockLoginOrigins contains origins of expectations of the AuthService.Login
type AuthServiceMockLoginExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mAuthServiceMockLogin) Optional() *mAuthServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Expect(ctx context.Context, req usecase.LoginCmd) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &AuthServiceMockLoginParams{ctx, req}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectReqParam2 sets up expected param req for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectReqParam2(req usecase.LoginCmd) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.req = &req
	mmLogin.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Inspect(f func(ctx context.Context, req usecase.LoginCmd)) *mAuthServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Return(t1 auth.Tokens, err error) *AuthServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &AuthServiceMockLoginResults{t1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the AuthService.Login method
func (mmLogin *mAuthServiceMockLogin) Set(f func(ctx context.Context, req usecase.LoginCmd) (t1 auth.Tokens, err error)) *AuthServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the AuthService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mAuthServiceMockLogin) When(ctx context.Context, req usecase.LoginCmd) *AuthServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &AuthServiceMockLoginParams{ctx, req},
		expectationOrigins: AuthServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Login return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginExpectation) Then(t1 auth.Tokens, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginResults{t1, err}
	return e.mock
}

// Times sets number of times AuthService.Login should be invoked
func (mmLogin *mAuthServiceMockLogin) Times(n uint64) *mAuthServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of AuthServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mAuthServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_http.AuthService
func (mmLogin *AuthServiceMock) Login(ctx context.Context, req usecase.LoginCmd) (t1 auth.Tokens, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, req)
	}

	mm_params := AuthServiceMockLoginParams{ctx, req}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the AuthServiceMock.Login")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, req)
	}
	mmLogin.t.Fatalf("Unexpected call to AuthServiceMock.Login. %v %v", ctx, req)
	return
}

// LoginAfterCounter returns a count of finished AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mAuthServiceMockLogin) Calls() []*AuthServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mAuthServiceMockRefreshTokens struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockRefreshTokensExpectation
	expectations       []*AuthServiceMockRefreshTokensExpectation

	callArgs []*AuthServiceMockRefreshTokensParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockRefreshTokensExpectation specifies expectation struct of the AuthService.RefreshTokens
type AuthServiceMockRefreshTokensExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockRefreshTokensParams
	paramPtrs          *AuthServiceMockRefreshTokensParamPtrs
	expectationOrigins AuthServiceMockRefreshTokensExpectationOrigins
	results            *AuthServiceMockRefreshTokensResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockRefreshTokensParams contains parameters of the AuthService.RefreshTokens
type AuthServiceMockRefreshTokensParams struct {
	ctx          context.Context
	refreshToken auth.RefreshToken
}

// AuthServiceMockRefreshTokensParamPtrs contains pointers to parameters of the AuthService.RefreshTokens
type AuthServiceMockRefreshTokensParamPtrs struct {
	ctx          *context.Context
	refreshToken *auth.RefreshToken
}

// AuthServiceMockRefreshTokensResults contains results of the AuthService.RefreshTokens
type AuthServiceMockRefreshTokensResults struct {
	t1  auth.Tokens
	err error
}

// AuthServiceMockRefreshTokensOrigins contains origins of expectations of the AuthService.RefreshTokens
type AuthServiceMockRefreshTokensExpectationOrigins struct {
	origin             string
	originCtx          string
	originRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Optional() *mAuthServiceMockRefreshTokens {
	mmRefreshTokens.optional = true
	return mmRefreshTokens
}

// Expect sets up expected params for AuthService.RefreshTokens
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Expect(ctx context.Context, refreshToken auth.RefreshToken) *mAuthServiceMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &AuthServiceMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by ExpectParams functions")
	}

	mmRefreshTokens.defaultExpectation.params = &AuthServiceMockRefreshTokensParams{ctx, refreshToken}
	mmRefreshTokens.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefreshTokens.expectations {
		if minimock.Equal(e.params, mmRefreshTokens.defaultExpectation.params) {
			mmRefreshTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefreshTokens.defaultExpectation.params)
		}
	}

	return mmRefreshTokens
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.RefreshTokens
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &AuthServiceMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.params != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Expect")
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs == nil {
		mmRefreshTokens.defaultExpectation.paramPtrs = &AuthServiceMockRefreshTokensParamPtrs{}
	}
	mmRefreshTokens.defaultExpectation.paramPtrs.ctx = &ctx
	mmRefreshTokens.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRefreshTokens
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for AuthService.RefreshTokens
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) ExpectRefreshTokenParam2(refreshToken auth.RefreshToken) *mAuthServiceMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &AuthServiceMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.params != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Expect")
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs == nil {
		mmRefreshTokens.defaultExpectation.paramPtrs = &AuthServiceMockRefreshTokensParamPtrs{}
	}
	mmRefreshTokens.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmRefreshTokens.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmRefreshTokens
}

// Inspect accepts an inspector function that has same arguments as the AuthService.RefreshTokens
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Inspect(f func(ctx context.Context, refreshToken auth.RefreshToken)) *mAuthServiceMockRefreshTokens {
	if mmRefreshTokens.mock.inspectFuncRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.RefreshTokens")
	}

	mmRefreshTokens.mock.inspectFuncRefreshTokens = f

	return mmRefreshTokens
}

// Return sets up results that will be returned by AuthService.RefreshTokens
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Return(t1 auth.Tokens, err error) *AuthServiceMock {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &AuthServiceMockRefreshTokensExpectation{mock: mmRefreshTokens.mock}
	}
	mmRefreshTokens.defaultExpectation.results = &AuthServiceMockRefreshTokensResults{t1, err}
	mmRefreshTokens.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefreshTokens.mock
}

// Set uses given function f to mock the AuthService.RefreshTokens method
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Set(f func(ctx context.Context, refreshToken auth.RefreshToken) (t1 auth.Tokens, err error)) *AuthServiceMock {
	if mmRefreshTokens.defaultExpectation != nil {
		mmRefreshTokens.mock.t.Fatalf("Default expectation is already set for the AuthService.RefreshTokens method")
	}

	if len(mmRefreshTokens.expectations) > 0 {
		mmRefreshTokens.mock.t.Fatalf("Some expectations are already set for the AuthService.RefreshTokens method")
	}

	mmRefreshTokens.mock.funcRefreshTokens = f
	mmRefreshTokens.mock.funcRefreshTokensOrigin = minimock.CallerInfo(1)
	return mmRefreshTokens.mock
}

// When sets expectation for the AuthService.RefreshTokens which will trigger the result defined by the following
// Then helper
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) When(ctx context.Context, refreshToken auth.RefreshToken) *AuthServiceMockRefreshTokensExpectation {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("AuthServiceMock.RefreshTokens mock is already set by Set")
	}

	expectation := &AuthServiceMockRefreshTokensExpectation{
		mock:               mmRefreshTokens.mock,
		params:             &AuthServiceMockRefreshTokensParams{ctx, refreshToken},
		expectationOrigins: AuthServiceMockRefreshTokensExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefreshTokens.expectations = append(mmRefreshTokens.expectations, expectation)
	return expectation
}

// Then sets up AuthService.RefreshTokens return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockRefreshTokensExpectation) Then(t1 auth.Tokens, err error) *AuthServiceMock {
	e.results = &AuthServiceMockRefreshTokensResults{t1, err}
	return e.mock
}

// Times sets number of times AuthService.RefreshTokens should be invoked
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Times(n uint64) *mAuthServiceMockRefreshTokens {
	if n == 0 {
		mmRefreshTokens.mock.t.Fatalf("Times of AuthServiceMock.RefreshTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshTokens.expectedInvocations, n)
	mmRefreshTokens.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefreshTokens
}

func (mmRefreshTokens *mAuthServiceMockRefreshTokens) invocationsDone() bool {
	if len(mmRefreshTokens.expectations) == 0 && mmRefreshTokens.defaultExpectation == nil && mmRefreshTokens.mock.funcRefreshTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshTokens.mock.afterRefreshTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshTokens implements mm_http.AuthService
func (mmRefreshTokens *AuthServiceMock) RefreshTokens(ctx context.Context, refreshToken auth.RefreshToken) (t1 auth.Tokens, err error) {
	mm_atomic.AddUint64(&mmRefreshTokens.beforeRefreshTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshTokens.afterRefreshTokensCounter, 1)

	mmRefreshTokens.t.Helper()

	if mmRefreshTokens.inspectFuncRefreshTokens != nil {
		mmRefreshTokens.inspectFuncRefreshTokens(ctx, refreshToken)
	}

	mm_params := AuthServiceMockRefreshTokensParams{ctx, refreshToken}

	// Record call args
	mmRefreshTokens.RefreshTokensMock.mutex.Lock()
	mmRefreshTokens.RefreshTokensMock.callArgs = append(mmRefreshTokens.RefreshTokensMock.callArgs, &mm_params)
	mmRefreshTokens.RefreshTokensMock.mutex.Unlock()

	for _, e := range mmRefreshTokens.RefreshTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmRefreshTokens.RefreshTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshTokens.RefreshTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmRefreshTokens.RefreshTokensMock.defaultExpectation.params
		mm_want_ptrs := mmRefreshTokens.RefreshTokensMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockRefreshTokensParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRefreshTokens.t.Errorf("AuthServiceMock.RefreshTokens got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmRefreshTokens.t.Errorf("AuthServiceMock.RefreshTokens got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefreshTokens.t.Errorf("AuthServiceMock.RefreshTokens got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefreshTokens.RefreshTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshTokens.t.Fatal("No results are set for the AuthServiceMock.RefreshTokens")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmRefreshTokens.funcRefreshTokens != nil {
		return mmRefreshTokens.funcRefreshTokens(ctx, refreshToken)
	}
	mmRefreshTokens.t.Fatalf("Unexpected call to AuthServiceMock.RefreshTokens. %v %v", ctx, refreshToken)
	return
}

// RefreshTokensAfterCounter returns a count of finished AuthServiceMock.RefreshTokens invocations
func (mmRefreshTokens *AuthServiceMock) RefreshTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokens.afterRefreshTokensCounter)
}

// RefreshTokensBeforeCounter returns a count of AuthServiceMock.RefreshTokens invocations
func (mmRefreshTokens *AuthServiceMock) RefreshTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokens.beforeRefreshTokensCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.RefreshTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefreshTokens *mAuthServiceMockRefreshTokens) Calls() []*AuthServiceMockRefreshTokensParams {
	mmRefreshTokens.mutex.RLock()

	argCopy := make([]*AuthServiceMockRefreshTokensParams, len(mmRefreshTokens.callArgs))
	copy(argCopy, mmRefreshTokens.callArgs)

	mmRefreshTokens.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshTokensDone returns true if the count of the RefreshTokens invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockRefreshTokensDone() bool {
	if m.RefreshTokensMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTokensMock.invocationsDone()
}

// MinimockRefreshTokensInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockRefreshTokensInspect() {
	for _, e := range m.RefreshTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.RefreshTokens at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefreshTokensCounter := mm_atomic.LoadUint64(&m.afterRefreshTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokensMock.defaultExpectation != nil && afterRefreshTokensCounter < 1 {
		if m.RefreshTokensMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.RefreshTokens at\n%s", m.RefreshTokensMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.RefreshTokens at\n%s with params: %#v", m.RefreshTokensMock.defaultExpectation.expectationOrigins.origin, *m.RefreshTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshTokens != nil && afterRefreshTokensCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.RefreshTokens at\n%s", m.funcRefreshTokensOrigin)
	}

	if !m.RefreshTokensMock.invocationsDone() && afterRefreshTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.RefreshTokens at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTokensMock.expectedInvocations), m.RefreshTokensMock.expectedInvocationsOrigin, afterRefreshTokensCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUserRoleInspect()

			m.MinimockDeleteSessionInspect()

			m.MinimockDeleteSessionsByUserIDInspect()

			m.MinimockDeleteUserRoleInspect()

			m.MinimockGetSessionsByUserIDInspect()

			m.MinimockListUserRolesInspect()

			m.MinimockLoginInspect()

			m.MinimockRefreshTokensInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUserRoleDone() &&
		m.MinimockDeleteSessionDone() &&
		m.MinimockDeleteSessionsByUserIDDone() &&
		m.MinimockDeleteUserRoleDone() &&
		m.MinimockGetSessionsByUserIDDone() &&
		m.MinimockListUserRolesDone() &&
		m.MinimockLoginDone() &&
		m.MinimockRefreshTokensDone()
}
