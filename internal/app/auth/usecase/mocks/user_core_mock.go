// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/auth/usecase.UserCore -o user_core_mock.go -n UserCoreMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/user"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// UserCoreMock implements mm_usecase.UserCore
type UserCoreMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetUser          func(ctx context.Context, id uuid.UUID) (u1 user.User, s1 string, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id uuid.UUID)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserCoreMockGetUser

	funcGetUserByEmail          func(ctx context.Context, email string) (u1 user.User, s1 string, err error)
	funcGetUserByEmailOrigin    string
	inspectFuncGetUserByEmail   func(ctx context.Context, email string)
	afterGetUserByEmailCounter  uint64
	beforeGetUserByEmailCounter uint64
	GetUserByEmailMock          mUserCoreMockGetUserByEmail
}

// NewUserCoreMock returns a mock for mm_usecase.UserCore
func NewUserCoreMock(t minimock.Tester) *UserCoreMock {
	m := &UserCoreMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserMock = mUserCoreMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserCoreMockGetUserParams{}

	m.GetUserByEmailMock = mUserCoreMockGetUserByEmail{mock: m}
	m.GetUserByEmailMock.callArgs = []*UserCoreMockGetUserByEmailParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCoreMockGetUser struct {
	optional           bool
	mock               *UserCoreMock
	defaultExpectation *UserCoreMockGetUserExpectation
	expectations       []*UserCoreMockGetUserExpectation

	callArgs []*UserCoreMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCoreMockGetUserExpectation specifies expectation struct of the UserCore.GetUser
type UserCoreMockGetUserExpectation struct {
	mock               *UserCoreMock
	params             *UserCoreMockGetUserParams
	paramPtrs          *UserCoreMockGetUserParamPtrs
	expectationOrigins UserCoreMockGetUserExpectationOrigins
	results            *UserCoreMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserCoreMockGetUserParams contains parameters of the UserCore.GetUser
type UserCoreMockGetUserParams struct {
	ctx context.Context
	id  uuid.UUID
}

// UserCoreMockGetUserParamPtrs contains pointers to parameters of the UserCore.GetUser
type UserCoreMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// UserCoreMockGetUserResults contains results of the UserCore.GetUser
type UserCoreMockGetUserResults struct {
	u1  user.User
	s1  string
	err error
}

// UserCoreMockGetUserOrigins contains origins of expectations of the UserCore.GetUser
type UserCoreMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserCoreMockGetUser) Optional() *mUserCoreMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserCore.GetUser
func (mmGetUser *mUserCoreMockGetUser) Expect(ctx context.Context, id uuid.UUID) *mUserCoreMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCoreMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserCoreMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserCore.GetUser
func (mmGetUser *mUserCoreMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserCoreMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCoreMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserCoreMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for UserCore.GetUser
func (mmGetUser *mUserCoreMockGetUser) ExpectIdParam2(id uuid.UUID) *mUserCoreMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCoreMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserCoreMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserCore.GetUser
func (mmGetUser *mUserCoreMockGetUser) Inspect(f func(ctx context.Context, id uuid.UUID)) *mUserCoreMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserCoreMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserCore.GetUser
func (mmGetUser *mUserCoreMockGetUser) Return(u1 user.User, s1 string, err error) *UserCoreMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserCoreMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserCoreMockGetUserResults{u1, s1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the UserCore.GetUser method
func (mmGetUser *mUserCoreMockGetUser) Set(f func(ctx context.Context, id uuid.UUID) (u1 user.User, s1 string, err error)) *UserCoreMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserCore.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserCore.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the UserCore.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserCoreMockGetUser) When(ctx context.Context, id uuid.UUID) *UserCoreMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserCoreMock.GetUser mock is already set by Set")
	}

	expectation := &UserCoreMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserCoreMockGetUserParams{ctx, id},
		expectationOrigins: UserCoreMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserCore.GetUser return parameters for the expectation previously defined by the When method
func (e *UserCoreMockGetUserExpectation) Then(u1 user.User, s1 string, err error) *UserCoreMock {
	e.results = &UserCoreMockGetUserResults{u1, s1, err}
	return e.mock
}

// Times sets number of times UserCore.GetUser should be invoked
func (mmGetUser *mUserCoreMockGetUser) Times(n uint64) *mUserCoreMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserCoreMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserCoreMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_usecase.UserCore
func (mmGetUser *UserCoreMock) GetUser(ctx context.Context, id uuid.UUID) (u1 user.User, s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := UserCoreMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.s1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserCoreMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserCoreMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("UserCoreMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserCoreMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserCoreMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).s1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserCoreMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished UserCoreMock.GetUser invocations
func (mmGetUser *UserCoreMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserCoreMock.GetUser invocations
func (mmGetUser *UserCoreMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserCoreMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserCoreMockGetUser) Calls() []*UserCoreMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserCoreMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserCoreMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserCoreMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCoreMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCoreMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCoreMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserCoreMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCoreMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserCoreMockGetUserByEmail struct {
	optional           bool
	mock               *UserCoreMock
	defaultExpectation *UserCoreMockGetUserByEmailExpectation
	expectations       []*UserCoreMockGetUserByEmailExpectation

	callArgs []*UserCoreMockGetUserByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCoreMockGetUserByEmailExpectation specifies expectation struct of the UserCore.GetUserByEmail
type UserCoreMockGetUserByEmailExpectation struct {
	mock               *UserCoreMock
	params             *UserCoreMockGetUserByEmailParams
	paramPtrs          *UserCoreMockGetUserByEmailParamPtrs
	expectationOrigins UserCoreMockGetUserByEmailExpectationOrigins
	results            *UserCoreMockGetUserByEmailResults
	returnOrigin       string
	Counter            uint64
}

// UserCoreMockGetUserByEmailParams contains parameters of the UserCore.GetUserByEmail
type UserCoreMockGetUserByEmailParams struct {
	ctx   context.Context
	email string
}

// UserCoreMockGetUserByEmailParamPtrs contains pointers to parameters of the UserCore.GetUserByEmail
type UserCoreMockGetUserByEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// UserCoreMockGetUserByEmailResults contains results of the UserCore.GetUserByEmail
type UserCoreMockGetUserByEmailResults struct {
	u1  user.User
	s1  string
	err error
}

// UserCoreMockGetUserByEmailOrigins contains origins of expectations of the UserCore.GetUserByEmail
type UserCoreMockGetUserByEmailExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Optional() *mUserCoreMockGetUserByEmail {
	mmGetUserByEmail.optional = true
	return mmGetUserByEmail
}

// Expect sets up expected params for UserCore.GetUserByEmail
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Expect(ctx context.Context, email string) *mUserCoreMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserCoreMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by ExpectParams functions")
	}

	mmGetUserByEmail.defaultExpectation.params = &UserCoreMockGetUserByEmailParams{ctx, email}
	mmGetUserByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByEmail.expectations {
		if minimock.Equal(e.params, mmGetUserByEmail.defaultExpectation.params) {
			mmGetUserByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByEmail.defaultExpectation.params)
		}
	}

	return mmGetUserByEmail
}

// ExpectCtxParam1 sets up expected param ctx for UserCore.GetUserByEmail
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) ExpectCtxParam1(ctx context.Context) *mUserCoreMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserCoreMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UserCoreMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// ExpectEmailParam2 sets up expected param email for UserCore.GetUserByEmail
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) ExpectEmailParam2(email string) *mUserCoreMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserCoreMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UserCoreMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.email = &email
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// Inspect accepts an inspector function that has same arguments as the UserCore.GetUserByEmail
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Inspect(f func(ctx context.Context, email string)) *mUserCoreMockGetUserByEmail {
	if mmGetUserByEmail.mock.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("Inspect function is already set for UserCoreMock.GetUserByEmail")
	}

	mmGetUserByEmail.mock.inspectFuncGetUserByEmail = f

	return mmGetUserByEmail
}

// Return sets up results that will be returned by UserCore.GetUserByEmail
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Return(u1 user.User, s1 string, err error) *UserCoreMock {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserCoreMockGetUserByEmailExpectation{mock: mmGetUserByEmail.mock}
	}
	mmGetUserByEmail.defaultExpectation.results = &UserCoreMockGetUserByEmailResults{u1, s1, err}
	mmGetUserByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// Set uses given function f to mock the UserCore.GetUserByEmail method
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Set(f func(ctx context.Context, email string) (u1 user.User, s1 string, err error)) *UserCoreMock {
	if mmGetUserByEmail.defaultExpectation != nil {
		mmGetUserByEmail.mock.t.Fatalf("Default expectation is already set for the UserCore.GetUserByEmail method")
	}

	if len(mmGetUserByEmail.expectations) > 0 {
		mmGetUserByEmail.mock.t.Fatalf("Some expectations are already set for the UserCore.GetUserByEmail method")
	}

	mmGetUserByEmail.mock.funcGetUserByEmail = f
	mmGetUserByEmail.mock.funcGetUserByEmailOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// When sets expectation for the UserCore.GetUserByEmail which will trigger the result defined by the following
// Then helper
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) When(ctx context.Context, email string) *UserCoreMockGetUserByEmailExpectation {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserCoreMock.GetUserByEmail mock is already set by Set")
	}

	expectation := &UserCoreMockGetUserByEmailExpectation{
		mock:               mmGetUserByEmail.mock,
		params:             &UserCoreMockGetUserByEmailParams{ctx, email},
		expectationOrigins: UserCoreMockGetUserByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByEmail.expectations = append(mmGetUserByEmail.expectations, expectation)
	return expectation
}

// Then sets up UserCore.GetUserByEmail return parameters for the expectation previously defined by the When method
func (e *UserCoreMockGetUserByEmailExpectation) Then(u1 user.User, s1 string, err error) *UserCoreMock {
	e.results = &UserCoreMockGetUserByEmailResults{u1, s1, err}
	return e.mock
}

// Times sets number of times UserCore.GetUserByEmail should be invoked
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Times(n uint64) *mUserCoreMockGetUserByEmail {
	if n == 0 {
		mmGetUserByEmail.mock.t.Fatalf("Times of UserCoreMock.GetUserByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByEmail.expectedInvocations, n)
	mmGetUserByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail
}

func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) invocationsDone() bool {
	if len(mmGetUserByEmail.expectations) == 0 && mmGetUserByEmail.defaultExpectation == nil && mmGetUserByEmail.mock.funcGetUserByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.mock.afterGetUserByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByEmail implements mm_usecase.UserCore
func (mmGetUserByEmail *UserCoreMock) GetUserByEmail(ctx context.Context, email string) (u1 user.User, s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByEmail.afterGetUserByEmailCounter, 1)

	mmGetUserByEmail.t.Helper()

	if mmGetUserByEmail.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.inspectFuncGetUserByEmail(ctx, email)
	}

	mm_params := UserCoreMockGetUserByEmailParams{ctx, email}

	// Record call args
	mmGetUserByEmail.GetUserByEmailMock.mutex.Lock()
	mmGetUserByEmail.GetUserByEmailMock.callArgs = append(mmGetUserByEmail.GetUserByEmailMock.callArgs, &mm_params)
	mmGetUserByEmail.GetUserByEmailMock.mutex.Unlock()

	for _, e := range mmGetUserByEmail.GetUserByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.s1, e.results.err
		}
	}

	if mmGetUserByEmail.GetUserByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.paramPtrs

		mm_got := UserCoreMockGetUserByEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByEmail.t.Errorf("UserCoreMock.GetUserByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetUserByEmail.t.Errorf("UserCoreMock.GetUserByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByEmail.t.Errorf("UserCoreMock.GetUserByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByEmail.t.Fatal("No results are set for the UserCoreMock.GetUserByEmail")
		}
		return (*mm_results).u1, (*mm_results).s1, (*mm_results).err
	}
	if mmGetUserByEmail.funcGetUserByEmail != nil {
		return mmGetUserByEmail.funcGetUserByEmail(ctx, email)
	}
	mmGetUserByEmail.t.Fatalf("Unexpected call to UserCoreMock.GetUserByEmail. %v %v", ctx, email)
	return
}

// GetUserByEmailAfterCounter returns a count of finished UserCoreMock.GetUserByEmail invocations
func (mmGetUserByEmail *UserCoreMock) GetUserByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.afterGetUserByEmailCounter)
}

// GetUserByEmailBeforeCounter returns a count of UserCoreMock.GetUserByEmail invocations
func (mmGetUserByEmail *UserCoreMock) GetUserByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter)
}

// Calls returns a list of arguments used in each call to UserCoreMock.GetUserByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByEmail *mUserCoreMockGetUserByEmail) Calls() []*UserCoreMockGetUserByEmailParams {
	mmGetUserByEmail.mutex.RLock()

	argCopy := make([]*UserCoreMockGetUserByEmailParams, len(mmGetUserByEmail.callArgs))
	copy(argCopy, mmGetUserByEmail.callArgs)

	mmGetUserByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByEmailDone returns true if the count of the GetUserByEmail invocations corresponds
// the number of defined expectations
func (m *UserCoreMock) MinimockGetUserByEmailDone() bool {
	if m.GetUserByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByEmailMock.invocationsDone()
}

// MinimockGetUserByEmailInspect logs each unmet expectation
func (m *UserCoreMock) MinimockGetUserByEmailInspect() {
	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCoreMock.GetUserByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByEmailCounter := mm_atomic.LoadUint64(&m.afterGetUserByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByEmailMock.defaultExpectation != nil && afterGetUserByEmailCounter < 1 {
		if m.GetUserByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCoreMock.GetUserByEmail at\n%s", m.GetUserByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCoreMock.GetUserByEmail at\n%s with params: %#v", m.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByEmail != nil && afterGetUserByEmailCounter < 1 {
		m.t.Errorf("Expected call to UserCoreMock.GetUserByEmail at\n%s", m.funcGetUserByEmailOrigin)
	}

	if !m.GetUserByEmailMock.invocationsDone() && afterGetUserByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCoreMock.GetUserByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByEmailMock.expectedInvocations), m.GetUserByEmailMock.expectedInvocationsOrigin, afterGetUserByEmailCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCoreMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetUserInspect()

			m.MinimockGetUserByEmailInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserDone() &&
		m.MinimockGetUserByEmailDone()
}
