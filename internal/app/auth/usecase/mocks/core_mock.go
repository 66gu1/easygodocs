// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/auth/usecase.Core -o core_mock.go -n CoreMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/auth"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// CoreMock implements mm_usecase.Core
type CoreMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUserRole          func(ctx context.Context, role auth.UserRole) (err error)
	funcAddUserRoleOrigin    string
	inspectFuncAddUserRole   func(ctx context.Context, role auth.UserRole)
	afterAddUserRoleCounter  uint64
	beforeAddUserRoleCounter uint64
	AddUserRoleMock          mCoreMockAddUserRole

	funcCheckIsAdmin          func(ctx context.Context) (err error)
	funcCheckIsAdminOrigin    string
	inspectFuncCheckIsAdmin   func(ctx context.Context)
	afterCheckIsAdminCounter  uint64
	beforeCheckIsAdminCounter uint64
	CheckIsAdminMock          mCoreMockCheckIsAdmin

	funcCheckSelfOrAdmin          func(ctx context.Context, targetUserID uuid.UUID) (err error)
	funcCheckSelfOrAdminOrigin    string
	inspectFuncCheckSelfOrAdmin   func(ctx context.Context, targetUserID uuid.UUID)
	afterCheckSelfOrAdminCounter  uint64
	beforeCheckSelfOrAdminCounter uint64
	CheckSelfOrAdminMock          mCoreMockCheckSelfOrAdmin

	funcDeleteSession          func(ctx context.Context, id uuid.UUID, userID uuid.UUID) (err error)
	funcDeleteSessionOrigin    string
	inspectFuncDeleteSession   func(ctx context.Context, id uuid.UUID, userID uuid.UUID)
	afterDeleteSessionCounter  uint64
	beforeDeleteSessionCounter uint64
	DeleteSessionMock          mCoreMockDeleteSession

	funcDeleteSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (err error)
	funcDeleteSessionsByUserIDOrigin    string
	inspectFuncDeleteSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterDeleteSessionsByUserIDCounter  uint64
	beforeDeleteSessionsByUserIDCounter uint64
	DeleteSessionsByUserIDMock          mCoreMockDeleteSessionsByUserID

	funcDeleteUserRole          func(ctx context.Context, role auth.UserRole) (err error)
	funcDeleteUserRoleOrigin    string
	inspectFuncDeleteUserRole   func(ctx context.Context, role auth.UserRole)
	afterDeleteUserRoleCounter  uint64
	beforeDeleteUserRoleCounter uint64
	DeleteUserRoleMock          mCoreMockDeleteUserRole

	funcGetSessionByID          func(ctx context.Context, id uuid.UUID) (s1 auth.Session, s2 string, err error)
	funcGetSessionByIDOrigin    string
	inspectFuncGetSessionByID   func(ctx context.Context, id uuid.UUID)
	afterGetSessionByIDCounter  uint64
	beforeGetSessionByIDCounter uint64
	GetSessionByIDMock          mCoreMockGetSessionByID

	funcGetSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (sa1 []auth.Session, err error)
	funcGetSessionsByUserIDOrigin    string
	inspectFuncGetSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterGetSessionsByUserIDCounter  uint64
	beforeGetSessionsByUserIDCounter uint64
	GetSessionsByUserIDMock          mCoreMockGetSessionsByUserID

	funcIsAdmin          func(ctx context.Context) (b1 bool, err error)
	funcIsAdminOrigin    string
	inspectFuncIsAdmin   func(ctx context.Context)
	afterIsAdminCounter  uint64
	beforeIsAdminCounter uint64
	IsAdminMock          mCoreMockIsAdmin

	funcIssueTokens          func(ctx context.Context, userID uuid.UUID, sessionVersion int) (t1 auth.Tokens, err error)
	funcIssueTokensOrigin    string
	inspectFuncIssueTokens   func(ctx context.Context, userID uuid.UUID, sessionVersion int)
	afterIssueTokensCounter  uint64
	beforeIssueTokensCounter uint64
	IssueTokensMock          mCoreMockIssueTokens

	funcListUserRoles          func(ctx context.Context, userID uuid.UUID) (ua1 []auth.UserRole, err error)
	funcListUserRolesOrigin    string
	inspectFuncListUserRoles   func(ctx context.Context, userID uuid.UUID)
	afterListUserRolesCounter  uint64
	beforeListUserRolesCounter uint64
	ListUserRolesMock          mCoreMockListUserRoles

	funcRefreshTokens          func(ctx context.Context, session auth.Session, refreshToken string, rtHash string) (t1 auth.Tokens, err error)
	funcRefreshTokensOrigin    string
	inspectFuncRefreshTokens   func(ctx context.Context, session auth.Session, refreshToken string, rtHash string)
	afterRefreshTokensCounter  uint64
	beforeRefreshTokensCounter uint64
	RefreshTokensMock          mCoreMockRefreshTokens
}

// NewCoreMock returns a mock for mm_usecase.Core
func NewCoreMock(t minimock.Tester) *CoreMock {
	m := &CoreMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUserRoleMock = mCoreMockAddUserRole{mock: m}
	m.AddUserRoleMock.callArgs = []*CoreMockAddUserRoleParams{}

	m.CheckIsAdminMock = mCoreMockCheckIsAdmin{mock: m}
	m.CheckIsAdminMock.callArgs = []*CoreMockCheckIsAdminParams{}

	m.CheckSelfOrAdminMock = mCoreMockCheckSelfOrAdmin{mock: m}
	m.CheckSelfOrAdminMock.callArgs = []*CoreMockCheckSelfOrAdminParams{}

	m.DeleteSessionMock = mCoreMockDeleteSession{mock: m}
	m.DeleteSessionMock.callArgs = []*CoreMockDeleteSessionParams{}

	m.DeleteSessionsByUserIDMock = mCoreMockDeleteSessionsByUserID{mock: m}
	m.DeleteSessionsByUserIDMock.callArgs = []*CoreMockDeleteSessionsByUserIDParams{}

	m.DeleteUserRoleMock = mCoreMockDeleteUserRole{mock: m}
	m.DeleteUserRoleMock.callArgs = []*CoreMockDeleteUserRoleParams{}

	m.GetSessionByIDMock = mCoreMockGetSessionByID{mock: m}
	m.GetSessionByIDMock.callArgs = []*CoreMockGetSessionByIDParams{}

	m.GetSessionsByUserIDMock = mCoreMockGetSessionsByUserID{mock: m}
	m.GetSessionsByUserIDMock.callArgs = []*CoreMockGetSessionsByUserIDParams{}

	m.IsAdminMock = mCoreMockIsAdmin{mock: m}
	m.IsAdminMock.callArgs = []*CoreMockIsAdminParams{}

	m.IssueTokensMock = mCoreMockIssueTokens{mock: m}
	m.IssueTokensMock.callArgs = []*CoreMockIssueTokensParams{}

	m.ListUserRolesMock = mCoreMockListUserRoles{mock: m}
	m.ListUserRolesMock.callArgs = []*CoreMockListUserRolesParams{}

	m.RefreshTokensMock = mCoreMockRefreshTokens{mock: m}
	m.RefreshTokensMock.callArgs = []*CoreMockRefreshTokensParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCoreMockAddUserRole struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockAddUserRoleExpectation
	expectations       []*CoreMockAddUserRoleExpectation

	callArgs []*CoreMockAddUserRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockAddUserRoleExpectation specifies expectation struct of the Core.AddUserRole
type CoreMockAddUserRoleExpectation struct {
	mock               *CoreMock
	params             *CoreMockAddUserRoleParams
	paramPtrs          *CoreMockAddUserRoleParamPtrs
	expectationOrigins CoreMockAddUserRoleExpectationOrigins
	results            *CoreMockAddUserRoleResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockAddUserRoleParams contains parameters of the Core.AddUserRole
type CoreMockAddUserRoleParams struct {
	ctx  context.Context
	role auth.UserRole
}

// CoreMockAddUserRoleParamPtrs contains pointers to parameters of the Core.AddUserRole
type CoreMockAddUserRoleParamPtrs struct {
	ctx  *context.Context
	role *auth.UserRole
}

// CoreMockAddUserRoleResults contains results of the Core.AddUserRole
type CoreMockAddUserRoleResults struct {
	err error
}

// CoreMockAddUserRoleOrigins contains origins of expectations of the Core.AddUserRole
type CoreMockAddUserRoleExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUserRole *mCoreMockAddUserRole) Optional() *mCoreMockAddUserRole {
	mmAddUserRole.optional = true
	return mmAddUserRole
}

// Expect sets up expected params for Core.AddUserRole
func (mmAddUserRole *mCoreMockAddUserRole) Expect(ctx context.Context, role auth.UserRole) *mCoreMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &CoreMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.paramPtrs != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by ExpectParams functions")
	}

	mmAddUserRole.defaultExpectation.params = &CoreMockAddUserRoleParams{ctx, role}
	mmAddUserRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUserRole.expectations {
		if minimock.Equal(e.params, mmAddUserRole.defaultExpectation.params) {
			mmAddUserRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUserRole.defaultExpectation.params)
		}
	}

	return mmAddUserRole
}

// ExpectCtxParam1 sets up expected param ctx for Core.AddUserRole
func (mmAddUserRole *mCoreMockAddUserRole) ExpectCtxParam1(ctx context.Context) *mCoreMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &CoreMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.params != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Expect")
	}

	if mmAddUserRole.defaultExpectation.paramPtrs == nil {
		mmAddUserRole.defaultExpectation.paramPtrs = &CoreMockAddUserRoleParamPtrs{}
	}
	mmAddUserRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddUserRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddUserRole
}

// ExpectRoleParam2 sets up expected param role for Core.AddUserRole
func (mmAddUserRole *mCoreMockAddUserRole) ExpectRoleParam2(role auth.UserRole) *mCoreMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &CoreMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.params != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Expect")
	}

	if mmAddUserRole.defaultExpectation.paramPtrs == nil {
		mmAddUserRole.defaultExpectation.paramPtrs = &CoreMockAddUserRoleParamPtrs{}
	}
	mmAddUserRole.defaultExpectation.paramPtrs.role = &role
	mmAddUserRole.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmAddUserRole
}

// Inspect accepts an inspector function that has same arguments as the Core.AddUserRole
func (mmAddUserRole *mCoreMockAddUserRole) Inspect(f func(ctx context.Context, role auth.UserRole)) *mCoreMockAddUserRole {
	if mmAddUserRole.mock.inspectFuncAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("Inspect function is already set for CoreMock.AddUserRole")
	}

	mmAddUserRole.mock.inspectFuncAddUserRole = f

	return mmAddUserRole
}

// Return sets up results that will be returned by Core.AddUserRole
func (mmAddUserRole *mCoreMockAddUserRole) Return(err error) *CoreMock {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &CoreMockAddUserRoleExpectation{mock: mmAddUserRole.mock}
	}
	mmAddUserRole.defaultExpectation.results = &CoreMockAddUserRoleResults{err}
	mmAddUserRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUserRole.mock
}

// Set uses given function f to mock the Core.AddUserRole method
func (mmAddUserRole *mCoreMockAddUserRole) Set(f func(ctx context.Context, role auth.UserRole) (err error)) *CoreMock {
	if mmAddUserRole.defaultExpectation != nil {
		mmAddUserRole.mock.t.Fatalf("Default expectation is already set for the Core.AddUserRole method")
	}

	if len(mmAddUserRole.expectations) > 0 {
		mmAddUserRole.mock.t.Fatalf("Some expectations are already set for the Core.AddUserRole method")
	}

	mmAddUserRole.mock.funcAddUserRole = f
	mmAddUserRole.mock.funcAddUserRoleOrigin = minimock.CallerInfo(1)
	return mmAddUserRole.mock
}

// When sets expectation for the Core.AddUserRole which will trigger the result defined by the following
// Then helper
func (mmAddUserRole *mCoreMockAddUserRole) When(ctx context.Context, role auth.UserRole) *CoreMockAddUserRoleExpectation {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("CoreMock.AddUserRole mock is already set by Set")
	}

	expectation := &CoreMockAddUserRoleExpectation{
		mock:               mmAddUserRole.mock,
		params:             &CoreMockAddUserRoleParams{ctx, role},
		expectationOrigins: CoreMockAddUserRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddUserRole.expectations = append(mmAddUserRole.expectations, expectation)
	return expectation
}

// Then sets up Core.AddUserRole return parameters for the expectation previously defined by the When method
func (e *CoreMockAddUserRoleExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockAddUserRoleResults{err}
	return e.mock
}

// Times sets number of times Core.AddUserRole should be invoked
func (mmAddUserRole *mCoreMockAddUserRole) Times(n uint64) *mCoreMockAddUserRole {
	if n == 0 {
		mmAddUserRole.mock.t.Fatalf("Times of CoreMock.AddUserRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUserRole.expectedInvocations, n)
	mmAddUserRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUserRole
}

func (mmAddUserRole *mCoreMockAddUserRole) invocationsDone() bool {
	if len(mmAddUserRole.expectations) == 0 && mmAddUserRole.defaultExpectation == nil && mmAddUserRole.mock.funcAddUserRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUserRole.mock.afterAddUserRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUserRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUserRole implements mm_usecase.Core
func (mmAddUserRole *CoreMock) AddUserRole(ctx context.Context, role auth.UserRole) (err error) {
	mm_atomic.AddUint64(&mmAddUserRole.beforeAddUserRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUserRole.afterAddUserRoleCounter, 1)

	mmAddUserRole.t.Helper()

	if mmAddUserRole.inspectFuncAddUserRole != nil {
		mmAddUserRole.inspectFuncAddUserRole(ctx, role)
	}

	mm_params := CoreMockAddUserRoleParams{ctx, role}

	// Record call args
	mmAddUserRole.AddUserRoleMock.mutex.Lock()
	mmAddUserRole.AddUserRoleMock.callArgs = append(mmAddUserRole.AddUserRoleMock.callArgs, &mm_params)
	mmAddUserRole.AddUserRoleMock.mutex.Unlock()

	for _, e := range mmAddUserRole.AddUserRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUserRole.AddUserRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUserRole.AddUserRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUserRole.AddUserRoleMock.defaultExpectation.params
		mm_want_ptrs := mmAddUserRole.AddUserRoleMock.defaultExpectation.paramPtrs

		mm_got := CoreMockAddUserRoleParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUserRole.t.Errorf("CoreMock.AddUserRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmAddUserRole.t.Errorf("CoreMock.AddUserRole got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUserRole.t.Errorf("CoreMock.AddUserRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUserRole.AddUserRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUserRole.t.Fatal("No results are set for the CoreMock.AddUserRole")
		}
		return (*mm_results).err
	}
	if mmAddUserRole.funcAddUserRole != nil {
		return mmAddUserRole.funcAddUserRole(ctx, role)
	}
	mmAddUserRole.t.Fatalf("Unexpected call to CoreMock.AddUserRole. %v %v", ctx, role)
	return
}

// AddUserRoleAfterCounter returns a count of finished CoreMock.AddUserRole invocations
func (mmAddUserRole *CoreMock) AddUserRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUserRole.afterAddUserRoleCounter)
}

// AddUserRoleBeforeCounter returns a count of CoreMock.AddUserRole invocations
func (mmAddUserRole *CoreMock) AddUserRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUserRole.beforeAddUserRoleCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.AddUserRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUserRole *mCoreMockAddUserRole) Calls() []*CoreMockAddUserRoleParams {
	mmAddUserRole.mutex.RLock()

	argCopy := make([]*CoreMockAddUserRoleParams, len(mmAddUserRole.callArgs))
	copy(argCopy, mmAddUserRole.callArgs)

	mmAddUserRole.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserRoleDone returns true if the count of the AddUserRole invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockAddUserRoleDone() bool {
	if m.AddUserRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUserRoleMock.invocationsDone()
}

// MinimockAddUserRoleInspect logs each unmet expectation
func (m *CoreMock) MinimockAddUserRoleInspect() {
	for _, e := range m.AddUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.AddUserRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUserRoleCounter := mm_atomic.LoadUint64(&m.afterAddUserRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserRoleMock.defaultExpectation != nil && afterAddUserRoleCounter < 1 {
		if m.AddUserRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.AddUserRole at\n%s", m.AddUserRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.AddUserRole at\n%s with params: %#v", m.AddUserRoleMock.defaultExpectation.expectationOrigins.origin, *m.AddUserRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUserRole != nil && afterAddUserRoleCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.AddUserRole at\n%s", m.funcAddUserRoleOrigin)
	}

	if !m.AddUserRoleMock.invocationsDone() && afterAddUserRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.AddUserRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUserRoleMock.expectedInvocations), m.AddUserRoleMock.expectedInvocationsOrigin, afterAddUserRoleCounter)
	}
}

type mCoreMockCheckIsAdmin struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockCheckIsAdminExpectation
	expectations       []*CoreMockCheckIsAdminExpectation

	callArgs []*CoreMockCheckIsAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockCheckIsAdminExpectation specifies expectation struct of the Core.CheckIsAdmin
type CoreMockCheckIsAdminExpectation struct {
	mock               *CoreMock
	params             *CoreMockCheckIsAdminParams
	paramPtrs          *CoreMockCheckIsAdminParamPtrs
	expectationOrigins CoreMockCheckIsAdminExpectationOrigins
	results            *CoreMockCheckIsAdminResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockCheckIsAdminParams contains parameters of the Core.CheckIsAdmin
type CoreMockCheckIsAdminParams struct {
	ctx context.Context
}

// CoreMockCheckIsAdminParamPtrs contains pointers to parameters of the Core.CheckIsAdmin
type CoreMockCheckIsAdminParamPtrs struct {
	ctx *context.Context
}

// CoreMockCheckIsAdminResults contains results of the Core.CheckIsAdmin
type CoreMockCheckIsAdminResults struct {
	err error
}

// CoreMockCheckIsAdminOrigins contains origins of expectations of the Core.CheckIsAdmin
type CoreMockCheckIsAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Optional() *mCoreMockCheckIsAdmin {
	mmCheckIsAdmin.optional = true
	return mmCheckIsAdmin
}

// Expect sets up expected params for Core.CheckIsAdmin
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Expect(ctx context.Context) *mCoreMockCheckIsAdmin {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("CoreMock.CheckIsAdmin mock is already set by Set")
	}

	if mmCheckIsAdmin.defaultExpectation == nil {
		mmCheckIsAdmin.defaultExpectation = &CoreMockCheckIsAdminExpectation{}
	}

	if mmCheckIsAdmin.defaultExpectation.paramPtrs != nil {
		mmCheckIsAdmin.mock.t.Fatalf("CoreMock.CheckIsAdmin mock is already set by ExpectParams functions")
	}

	mmCheckIsAdmin.defaultExpectation.params = &CoreMockCheckIsAdminParams{ctx}
	mmCheckIsAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckIsAdmin.expectations {
		if minimock.Equal(e.params, mmCheckIsAdmin.defaultExpectation.params) {
			mmCheckIsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckIsAdmin.defaultExpectation.params)
		}
	}

	return mmCheckIsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Core.CheckIsAdmin
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) ExpectCtxParam1(ctx context.Context) *mCoreMockCheckIsAdmin {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("CoreMock.CheckIsAdmin mock is already set by Set")
	}

	if mmCheckIsAdmin.defaultExpectation == nil {
		mmCheckIsAdmin.defaultExpectation = &CoreMockCheckIsAdminExpectation{}
	}

	if mmCheckIsAdmin.defaultExpectation.params != nil {
		mmCheckIsAdmin.mock.t.Fatalf("CoreMock.CheckIsAdmin mock is already set by Expect")
	}

	if mmCheckIsAdmin.defaultExpectation.paramPtrs == nil {
		mmCheckIsAdmin.defaultExpectation.paramPtrs = &CoreMockCheckIsAdminParamPtrs{}
	}
	mmCheckIsAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckIsAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckIsAdmin
}

// Inspect accepts an inspector function that has same arguments as the Core.CheckIsAdmin
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Inspect(f func(ctx context.Context)) *mCoreMockCheckIsAdmin {
	if mmCheckIsAdmin.mock.inspectFuncCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("Inspect function is already set for CoreMock.CheckIsAdmin")
	}

	mmCheckIsAdmin.mock.inspectFuncCheckIsAdmin = f

	return mmCheckIsAdmin
}

// Return sets up results that will be returned by Core.CheckIsAdmin
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Return(err error) *CoreMock {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("CoreMock.CheckIsAdmin mock is already set by Set")
	}

	if mmCheckIsAdmin.defaultExpectation == nil {
		mmCheckIsAdmin.defaultExpectation = &CoreMockCheckIsAdminExpectation{mock: mmCheckIsAdmin.mock}
	}
	mmCheckIsAdmin.defaultExpectation.results = &CoreMockCheckIsAdminResults{err}
	mmCheckIsAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckIsAdmin.mock
}

// Set uses given function f to mock the Core.CheckIsAdmin method
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Set(f func(ctx context.Context) (err error)) *CoreMock {
	if mmCheckIsAdmin.defaultExpectation != nil {
		mmCheckIsAdmin.mock.t.Fatalf("Default expectation is already set for the Core.CheckIsAdmin method")
	}

	if len(mmCheckIsAdmin.expectations) > 0 {
		mmCheckIsAdmin.mock.t.Fatalf("Some expectations are already set for the Core.CheckIsAdmin method")
	}

	mmCheckIsAdmin.mock.funcCheckIsAdmin = f
	mmCheckIsAdmin.mock.funcCheckIsAdminOrigin = minimock.CallerInfo(1)
	return mmCheckIsAdmin.mock
}

// When sets expectation for the Core.CheckIsAdmin which will trigger the result defined by the following
// Then helper
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) When(ctx context.Context) *CoreMockCheckIsAdminExpectation {
	if mmCheckIsAdmin.mock.funcCheckIsAdmin != nil {
		mmCheckIsAdmin.mock.t.Fatalf("CoreMock.CheckIsAdmin mock is already set by Set")
	}

	expectation := &CoreMockCheckIsAdminExpectation{
		mock:               mmCheckIsAdmin.mock,
		params:             &CoreMockCheckIsAdminParams{ctx},
		expectationOrigins: CoreMockCheckIsAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckIsAdmin.expectations = append(mmCheckIsAdmin.expectations, expectation)
	return expectation
}

// Then sets up Core.CheckIsAdmin return parameters for the expectation previously defined by the When method
func (e *CoreMockCheckIsAdminExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockCheckIsAdminResults{err}
	return e.mock
}

// Times sets number of times Core.CheckIsAdmin should be invoked
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Times(n uint64) *mCoreMockCheckIsAdmin {
	if n == 0 {
		mmCheckIsAdmin.mock.t.Fatalf("Times of CoreMock.CheckIsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckIsAdmin.expectedInvocations, n)
	mmCheckIsAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckIsAdmin
}

func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) invocationsDone() bool {
	if len(mmCheckIsAdmin.expectations) == 0 && mmCheckIsAdmin.defaultExpectation == nil && mmCheckIsAdmin.mock.funcCheckIsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckIsAdmin.mock.afterCheckIsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckIsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckIsAdmin implements mm_usecase.Core
func (mmCheckIsAdmin *CoreMock) CheckIsAdmin(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCheckIsAdmin.beforeCheckIsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckIsAdmin.afterCheckIsAdminCounter, 1)

	mmCheckIsAdmin.t.Helper()

	if mmCheckIsAdmin.inspectFuncCheckIsAdmin != nil {
		mmCheckIsAdmin.inspectFuncCheckIsAdmin(ctx)
	}

	mm_params := CoreMockCheckIsAdminParams{ctx}

	// Record call args
	mmCheckIsAdmin.CheckIsAdminMock.mutex.Lock()
	mmCheckIsAdmin.CheckIsAdminMock.callArgs = append(mmCheckIsAdmin.CheckIsAdminMock.callArgs, &mm_params)
	mmCheckIsAdmin.CheckIsAdminMock.mutex.Unlock()

	for _, e := range mmCheckIsAdmin.CheckIsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.paramPtrs

		mm_got := CoreMockCheckIsAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckIsAdmin.t.Errorf("CoreMock.CheckIsAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckIsAdmin.t.Errorf("CoreMock.CheckIsAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckIsAdmin.CheckIsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckIsAdmin.t.Fatal("No results are set for the CoreMock.CheckIsAdmin")
		}
		return (*mm_results).err
	}
	if mmCheckIsAdmin.funcCheckIsAdmin != nil {
		return mmCheckIsAdmin.funcCheckIsAdmin(ctx)
	}
	mmCheckIsAdmin.t.Fatalf("Unexpected call to CoreMock.CheckIsAdmin. %v", ctx)
	return
}

// CheckIsAdminAfterCounter returns a count of finished CoreMock.CheckIsAdmin invocations
func (mmCheckIsAdmin *CoreMock) CheckIsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIsAdmin.afterCheckIsAdminCounter)
}

// CheckIsAdminBeforeCounter returns a count of CoreMock.CheckIsAdmin invocations
func (mmCheckIsAdmin *CoreMock) CheckIsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIsAdmin.beforeCheckIsAdminCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.CheckIsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckIsAdmin *mCoreMockCheckIsAdmin) Calls() []*CoreMockCheckIsAdminParams {
	mmCheckIsAdmin.mutex.RLock()

	argCopy := make([]*CoreMockCheckIsAdminParams, len(mmCheckIsAdmin.callArgs))
	copy(argCopy, mmCheckIsAdmin.callArgs)

	mmCheckIsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockCheckIsAdminDone returns true if the count of the CheckIsAdmin invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockCheckIsAdminDone() bool {
	if m.CheckIsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckIsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckIsAdminMock.invocationsDone()
}

// MinimockCheckIsAdminInspect logs each unmet expectation
func (m *CoreMock) MinimockCheckIsAdminInspect() {
	for _, e := range m.CheckIsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.CheckIsAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckIsAdminCounter := mm_atomic.LoadUint64(&m.afterCheckIsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckIsAdminMock.defaultExpectation != nil && afterCheckIsAdminCounter < 1 {
		if m.CheckIsAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.CheckIsAdmin at\n%s", m.CheckIsAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.CheckIsAdmin at\n%s with params: %#v", m.CheckIsAdminMock.defaultExpectation.expectationOrigins.origin, *m.CheckIsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckIsAdmin != nil && afterCheckIsAdminCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.CheckIsAdmin at\n%s", m.funcCheckIsAdminOrigin)
	}

	if !m.CheckIsAdminMock.invocationsDone() && afterCheckIsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.CheckIsAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckIsAdminMock.expectedInvocations), m.CheckIsAdminMock.expectedInvocationsOrigin, afterCheckIsAdminCounter)
	}
}

type mCoreMockCheckSelfOrAdmin struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockCheckSelfOrAdminExpectation
	expectations       []*CoreMockCheckSelfOrAdminExpectation

	callArgs []*CoreMockCheckSelfOrAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockCheckSelfOrAdminExpectation specifies expectation struct of the Core.CheckSelfOrAdmin
type CoreMockCheckSelfOrAdminExpectation struct {
	mock               *CoreMock
	params             *CoreMockCheckSelfOrAdminParams
	paramPtrs          *CoreMockCheckSelfOrAdminParamPtrs
	expectationOrigins CoreMockCheckSelfOrAdminExpectationOrigins
	results            *CoreMockCheckSelfOrAdminResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockCheckSelfOrAdminParams contains parameters of the Core.CheckSelfOrAdmin
type CoreMockCheckSelfOrAdminParams struct {
	ctx          context.Context
	targetUserID uuid.UUID
}

// CoreMockCheckSelfOrAdminParamPtrs contains pointers to parameters of the Core.CheckSelfOrAdmin
type CoreMockCheckSelfOrAdminParamPtrs struct {
	ctx          *context.Context
	targetUserID *uuid.UUID
}

// CoreMockCheckSelfOrAdminResults contains results of the Core.CheckSelfOrAdmin
type CoreMockCheckSelfOrAdminResults struct {
	err error
}

// CoreMockCheckSelfOrAdminOrigins contains origins of expectations of the Core.CheckSelfOrAdmin
type CoreMockCheckSelfOrAdminExpectationOrigins struct {
	origin             string
	originCtx          string
	originTargetUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Optional() *mCoreMockCheckSelfOrAdmin {
	mmCheckSelfOrAdmin.optional = true
	return mmCheckSelfOrAdmin
}

// Expect sets up expected params for Core.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Expect(ctx context.Context, targetUserID uuid.UUID) *mCoreMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &CoreMockCheckSelfOrAdminExpectation{}
	}

	if mmCheckSelfOrAdmin.defaultExpectation.paramPtrs != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by ExpectParams functions")
	}

	mmCheckSelfOrAdmin.defaultExpectation.params = &CoreMockCheckSelfOrAdminParams{ctx, targetUserID}
	mmCheckSelfOrAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckSelfOrAdmin.expectations {
		if minimock.Equal(e.params, mmCheckSelfOrAdmin.defaultExpectation.params) {
			mmCheckSelfOrAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckSelfOrAdmin.defaultExpectation.params)
		}
	}

	return mmCheckSelfOrAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Core.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) ExpectCtxParam1(ctx context.Context) *mCoreMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &CoreMockCheckSelfOrAdminExpectation{}
	}

	if mmCheckSelfOrAdmin.defaultExpectation.params != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Expect")
	}

	if mmCheckSelfOrAdmin.defaultExpectation.paramPtrs == nil {
		mmCheckSelfOrAdmin.defaultExpectation.paramPtrs = &CoreMockCheckSelfOrAdminParamPtrs{}
	}
	mmCheckSelfOrAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckSelfOrAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckSelfOrAdmin
}

// ExpectTargetUserIDParam2 sets up expected param targetUserID for Core.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) ExpectTargetUserIDParam2(targetUserID uuid.UUID) *mCoreMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &CoreMockCheckSelfOrAdminExpectation{}
	}

	if mmCheckSelfOrAdmin.defaultExpectation.params != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Expect")
	}

	if mmCheckSelfOrAdmin.defaultExpectation.paramPtrs == nil {
		mmCheckSelfOrAdmin.defaultExpectation.paramPtrs = &CoreMockCheckSelfOrAdminParamPtrs{}
	}
	mmCheckSelfOrAdmin.defaultExpectation.paramPtrs.targetUserID = &targetUserID
	mmCheckSelfOrAdmin.defaultExpectation.expectationOrigins.originTargetUserID = minimock.CallerInfo(1)

	return mmCheckSelfOrAdmin
}

// Inspect accepts an inspector function that has same arguments as the Core.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Inspect(f func(ctx context.Context, targetUserID uuid.UUID)) *mCoreMockCheckSelfOrAdmin {
	if mmCheckSelfOrAdmin.mock.inspectFuncCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Inspect function is already set for CoreMock.CheckSelfOrAdmin")
	}

	mmCheckSelfOrAdmin.mock.inspectFuncCheckSelfOrAdmin = f

	return mmCheckSelfOrAdmin
}

// Return sets up results that will be returned by Core.CheckSelfOrAdmin
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Return(err error) *CoreMock {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Set")
	}

	if mmCheckSelfOrAdmin.defaultExpectation == nil {
		mmCheckSelfOrAdmin.defaultExpectation = &CoreMockCheckSelfOrAdminExpectation{mock: mmCheckSelfOrAdmin.mock}
	}
	mmCheckSelfOrAdmin.defaultExpectation.results = &CoreMockCheckSelfOrAdminResults{err}
	mmCheckSelfOrAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckSelfOrAdmin.mock
}

// Set uses given function f to mock the Core.CheckSelfOrAdmin method
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Set(f func(ctx context.Context, targetUserID uuid.UUID) (err error)) *CoreMock {
	if mmCheckSelfOrAdmin.defaultExpectation != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Default expectation is already set for the Core.CheckSelfOrAdmin method")
	}

	if len(mmCheckSelfOrAdmin.expectations) > 0 {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Some expectations are already set for the Core.CheckSelfOrAdmin method")
	}

	mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin = f
	mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdminOrigin = minimock.CallerInfo(1)
	return mmCheckSelfOrAdmin.mock
}

// When sets expectation for the Core.CheckSelfOrAdmin which will trigger the result defined by the following
// Then helper
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) When(ctx context.Context, targetUserID uuid.UUID) *CoreMockCheckSelfOrAdminExpectation {
	if mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.mock.t.Fatalf("CoreMock.CheckSelfOrAdmin mock is already set by Set")
	}

	expectation := &CoreMockCheckSelfOrAdminExpectation{
		mock:               mmCheckSelfOrAdmin.mock,
		params:             &CoreMockCheckSelfOrAdminParams{ctx, targetUserID},
		expectationOrigins: CoreMockCheckSelfOrAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckSelfOrAdmin.expectations = append(mmCheckSelfOrAdmin.expectations, expectation)
	return expectation
}

// Then sets up Core.CheckSelfOrAdmin return parameters for the expectation previously defined by the When method
func (e *CoreMockCheckSelfOrAdminExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockCheckSelfOrAdminResults{err}
	return e.mock
}

// Times sets number of times Core.CheckSelfOrAdmin should be invoked
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Times(n uint64) *mCoreMockCheckSelfOrAdmin {
	if n == 0 {
		mmCheckSelfOrAdmin.mock.t.Fatalf("Times of CoreMock.CheckSelfOrAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckSelfOrAdmin.expectedInvocations, n)
	mmCheckSelfOrAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckSelfOrAdmin
}

func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) invocationsDone() bool {
	if len(mmCheckSelfOrAdmin.expectations) == 0 && mmCheckSelfOrAdmin.defaultExpectation == nil && mmCheckSelfOrAdmin.mock.funcCheckSelfOrAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.mock.afterCheckSelfOrAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckSelfOrAdmin implements mm_usecase.Core
func (mmCheckSelfOrAdmin *CoreMock) CheckSelfOrAdmin(ctx context.Context, targetUserID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCheckSelfOrAdmin.beforeCheckSelfOrAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckSelfOrAdmin.afterCheckSelfOrAdminCounter, 1)

	mmCheckSelfOrAdmin.t.Helper()

	if mmCheckSelfOrAdmin.inspectFuncCheckSelfOrAdmin != nil {
		mmCheckSelfOrAdmin.inspectFuncCheckSelfOrAdmin(ctx, targetUserID)
	}

	mm_params := CoreMockCheckSelfOrAdminParams{ctx, targetUserID}

	// Record call args
	mmCheckSelfOrAdmin.CheckSelfOrAdminMock.mutex.Lock()
	mmCheckSelfOrAdmin.CheckSelfOrAdminMock.callArgs = append(mmCheckSelfOrAdmin.CheckSelfOrAdminMock.callArgs, &mm_params)
	mmCheckSelfOrAdmin.CheckSelfOrAdminMock.mutex.Unlock()

	for _, e := range mmCheckSelfOrAdmin.CheckSelfOrAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.params
		mm_want_ptrs := mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.paramPtrs

		mm_got := CoreMockCheckSelfOrAdminParams{ctx, targetUserID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckSelfOrAdmin.t.Errorf("CoreMock.CheckSelfOrAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.targetUserID != nil && !minimock.Equal(*mm_want_ptrs.targetUserID, mm_got.targetUserID) {
				mmCheckSelfOrAdmin.t.Errorf("CoreMock.CheckSelfOrAdmin got unexpected parameter targetUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.originTargetUserID, *mm_want_ptrs.targetUserID, mm_got.targetUserID, minimock.Diff(*mm_want_ptrs.targetUserID, mm_got.targetUserID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckSelfOrAdmin.t.Errorf("CoreMock.CheckSelfOrAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckSelfOrAdmin.CheckSelfOrAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckSelfOrAdmin.t.Fatal("No results are set for the CoreMock.CheckSelfOrAdmin")
		}
		return (*mm_results).err
	}
	if mmCheckSelfOrAdmin.funcCheckSelfOrAdmin != nil {
		return mmCheckSelfOrAdmin.funcCheckSelfOrAdmin(ctx, targetUserID)
	}
	mmCheckSelfOrAdmin.t.Fatalf("Unexpected call to CoreMock.CheckSelfOrAdmin. %v %v", ctx, targetUserID)
	return
}

// CheckSelfOrAdminAfterCounter returns a count of finished CoreMock.CheckSelfOrAdmin invocations
func (mmCheckSelfOrAdmin *CoreMock) CheckSelfOrAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.afterCheckSelfOrAdminCounter)
}

// CheckSelfOrAdminBeforeCounter returns a count of CoreMock.CheckSelfOrAdmin invocations
func (mmCheckSelfOrAdmin *CoreMock) CheckSelfOrAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckSelfOrAdmin.beforeCheckSelfOrAdminCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.CheckSelfOrAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckSelfOrAdmin *mCoreMockCheckSelfOrAdmin) Calls() []*CoreMockCheckSelfOrAdminParams {
	mmCheckSelfOrAdmin.mutex.RLock()

	argCopy := make([]*CoreMockCheckSelfOrAdminParams, len(mmCheckSelfOrAdmin.callArgs))
	copy(argCopy, mmCheckSelfOrAdmin.callArgs)

	mmCheckSelfOrAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockCheckSelfOrAdminDone returns true if the count of the CheckSelfOrAdmin invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockCheckSelfOrAdminDone() bool {
	if m.CheckSelfOrAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckSelfOrAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckSelfOrAdminMock.invocationsDone()
}

// MinimockCheckSelfOrAdminInspect logs each unmet expectation
func (m *CoreMock) MinimockCheckSelfOrAdminInspect() {
	for _, e := range m.CheckSelfOrAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.CheckSelfOrAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckSelfOrAdminCounter := mm_atomic.LoadUint64(&m.afterCheckSelfOrAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckSelfOrAdminMock.defaultExpectation != nil && afterCheckSelfOrAdminCounter < 1 {
		if m.CheckSelfOrAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.CheckSelfOrAdmin at\n%s", m.CheckSelfOrAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.CheckSelfOrAdmin at\n%s with params: %#v", m.CheckSelfOrAdminMock.defaultExpectation.expectationOrigins.origin, *m.CheckSelfOrAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckSelfOrAdmin != nil && afterCheckSelfOrAdminCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.CheckSelfOrAdmin at\n%s", m.funcCheckSelfOrAdminOrigin)
	}

	if !m.CheckSelfOrAdminMock.invocationsDone() && afterCheckSelfOrAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.CheckSelfOrAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckSelfOrAdminMock.expectedInvocations), m.CheckSelfOrAdminMock.expectedInvocationsOrigin, afterCheckSelfOrAdminCounter)
	}
}

type mCoreMockDeleteSession struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockDeleteSessionExpectation
	expectations       []*CoreMockDeleteSessionExpectation

	callArgs []*CoreMockDeleteSessionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockDeleteSessionExpectation specifies expectation struct of the Core.DeleteSession
type CoreMockDeleteSessionExpectation struct {
	mock               *CoreMock
	params             *CoreMockDeleteSessionParams
	paramPtrs          *CoreMockDeleteSessionParamPtrs
	expectationOrigins CoreMockDeleteSessionExpectationOrigins
	results            *CoreMockDeleteSessionResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockDeleteSessionParams contains parameters of the Core.DeleteSession
type CoreMockDeleteSessionParams struct {
	ctx    context.Context
	id     uuid.UUID
	userID uuid.UUID
}

// CoreMockDeleteSessionParamPtrs contains pointers to parameters of the Core.DeleteSession
type CoreMockDeleteSessionParamPtrs struct {
	ctx    *context.Context
	id     *uuid.UUID
	userID *uuid.UUID
}

// CoreMockDeleteSessionResults contains results of the Core.DeleteSession
type CoreMockDeleteSessionResults struct {
	err error
}

// CoreMockDeleteSessionOrigins contains origins of expectations of the Core.DeleteSession
type CoreMockDeleteSessionExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSession *mCoreMockDeleteSession) Optional() *mCoreMockDeleteSession {
	mmDeleteSession.optional = true
	return mmDeleteSession
}

// Expect sets up expected params for Core.DeleteSession
func (mmDeleteSession *mCoreMockDeleteSession) Expect(ctx context.Context, id uuid.UUID, userID uuid.UUID) *mCoreMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &CoreMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.paramPtrs != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by ExpectParams functions")
	}

	mmDeleteSession.defaultExpectation.params = &CoreMockDeleteSessionParams{ctx, id, userID}
	mmDeleteSession.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSession.expectations {
		if minimock.Equal(e.params, mmDeleteSession.defaultExpectation.params) {
			mmDeleteSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSession.defaultExpectation.params)
		}
	}

	return mmDeleteSession
}

// ExpectCtxParam1 sets up expected param ctx for Core.DeleteSession
func (mmDeleteSession *mCoreMockDeleteSession) ExpectCtxParam1(ctx context.Context) *mCoreMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &CoreMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.params != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Expect")
	}

	if mmDeleteSession.defaultExpectation.paramPtrs == nil {
		mmDeleteSession.defaultExpectation.paramPtrs = &CoreMockDeleteSessionParamPtrs{}
	}
	mmDeleteSession.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSession.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSession
}

// ExpectIdParam2 sets up expected param id for Core.DeleteSession
func (mmDeleteSession *mCoreMockDeleteSession) ExpectIdParam2(id uuid.UUID) *mCoreMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &CoreMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.params != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Expect")
	}

	if mmDeleteSession.defaultExpectation.paramPtrs == nil {
		mmDeleteSession.defaultExpectation.paramPtrs = &CoreMockDeleteSessionParamPtrs{}
	}
	mmDeleteSession.defaultExpectation.paramPtrs.id = &id
	mmDeleteSession.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteSession
}

// ExpectUserIDParam3 sets up expected param userID for Core.DeleteSession
func (mmDeleteSession *mCoreMockDeleteSession) ExpectUserIDParam3(userID uuid.UUID) *mCoreMockDeleteSession {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &CoreMockDeleteSessionExpectation{}
	}

	if mmDeleteSession.defaultExpectation.params != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Expect")
	}

	if mmDeleteSession.defaultExpectation.paramPtrs == nil {
		mmDeleteSession.defaultExpectation.paramPtrs = &CoreMockDeleteSessionParamPtrs{}
	}
	mmDeleteSession.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSession.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSession
}

// Inspect accepts an inspector function that has same arguments as the Core.DeleteSession
func (mmDeleteSession *mCoreMockDeleteSession) Inspect(f func(ctx context.Context, id uuid.UUID, userID uuid.UUID)) *mCoreMockDeleteSession {
	if mmDeleteSession.mock.inspectFuncDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("Inspect function is already set for CoreMock.DeleteSession")
	}

	mmDeleteSession.mock.inspectFuncDeleteSession = f

	return mmDeleteSession
}

// Return sets up results that will be returned by Core.DeleteSession
func (mmDeleteSession *mCoreMockDeleteSession) Return(err error) *CoreMock {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Set")
	}

	if mmDeleteSession.defaultExpectation == nil {
		mmDeleteSession.defaultExpectation = &CoreMockDeleteSessionExpectation{mock: mmDeleteSession.mock}
	}
	mmDeleteSession.defaultExpectation.results = &CoreMockDeleteSessionResults{err}
	mmDeleteSession.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSession.mock
}

// Set uses given function f to mock the Core.DeleteSession method
func (mmDeleteSession *mCoreMockDeleteSession) Set(f func(ctx context.Context, id uuid.UUID, userID uuid.UUID) (err error)) *CoreMock {
	if mmDeleteSession.defaultExpectation != nil {
		mmDeleteSession.mock.t.Fatalf("Default expectation is already set for the Core.DeleteSession method")
	}

	if len(mmDeleteSession.expectations) > 0 {
		mmDeleteSession.mock.t.Fatalf("Some expectations are already set for the Core.DeleteSession method")
	}

	mmDeleteSession.mock.funcDeleteSession = f
	mmDeleteSession.mock.funcDeleteSessionOrigin = minimock.CallerInfo(1)
	return mmDeleteSession.mock
}

// When sets expectation for the Core.DeleteSession which will trigger the result defined by the following
// Then helper
func (mmDeleteSession *mCoreMockDeleteSession) When(ctx context.Context, id uuid.UUID, userID uuid.UUID) *CoreMockDeleteSessionExpectation {
	if mmDeleteSession.mock.funcDeleteSession != nil {
		mmDeleteSession.mock.t.Fatalf("CoreMock.DeleteSession mock is already set by Set")
	}

	expectation := &CoreMockDeleteSessionExpectation{
		mock:               mmDeleteSession.mock,
		params:             &CoreMockDeleteSessionParams{ctx, id, userID},
		expectationOrigins: CoreMockDeleteSessionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSession.expectations = append(mmDeleteSession.expectations, expectation)
	return expectation
}

// Then sets up Core.DeleteSession return parameters for the expectation previously defined by the When method
func (e *CoreMockDeleteSessionExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockDeleteSessionResults{err}
	return e.mock
}

// Times sets number of times Core.DeleteSession should be invoked
func (mmDeleteSession *mCoreMockDeleteSession) Times(n uint64) *mCoreMockDeleteSession {
	if n == 0 {
		mmDeleteSession.mock.t.Fatalf("Times of CoreMock.DeleteSession mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSession.expectedInvocations, n)
	mmDeleteSession.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSession
}

func (mmDeleteSession *mCoreMockDeleteSession) invocationsDone() bool {
	if len(mmDeleteSession.expectations) == 0 && mmDeleteSession.defaultExpectation == nil && mmDeleteSession.mock.funcDeleteSession == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSession.mock.afterDeleteSessionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSession.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSession implements mm_usecase.Core
func (mmDeleteSession *CoreMock) DeleteSession(ctx context.Context, id uuid.UUID, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSession.beforeDeleteSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSession.afterDeleteSessionCounter, 1)

	mmDeleteSession.t.Helper()

	if mmDeleteSession.inspectFuncDeleteSession != nil {
		mmDeleteSession.inspectFuncDeleteSession(ctx, id, userID)
	}

	mm_params := CoreMockDeleteSessionParams{ctx, id, userID}

	// Record call args
	mmDeleteSession.DeleteSessionMock.mutex.Lock()
	mmDeleteSession.DeleteSessionMock.callArgs = append(mmDeleteSession.DeleteSessionMock.callArgs, &mm_params)
	mmDeleteSession.DeleteSessionMock.mutex.Unlock()

	for _, e := range mmDeleteSession.DeleteSessionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSession.DeleteSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSession.DeleteSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSession.DeleteSessionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSession.DeleteSessionMock.defaultExpectation.paramPtrs

		mm_got := CoreMockDeleteSessionParams{ctx, id, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSession.t.Errorf("CoreMock.DeleteSession got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteSession.t.Errorf("CoreMock.DeleteSession got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSession.t.Errorf("CoreMock.DeleteSession got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSession.t.Errorf("CoreMock.DeleteSession got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSession.DeleteSessionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSession.DeleteSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSession.t.Fatal("No results are set for the CoreMock.DeleteSession")
		}
		return (*mm_results).err
	}
	if mmDeleteSession.funcDeleteSession != nil {
		return mmDeleteSession.funcDeleteSession(ctx, id, userID)
	}
	mmDeleteSession.t.Fatalf("Unexpected call to CoreMock.DeleteSession. %v %v %v", ctx, id, userID)
	return
}

// DeleteSessionAfterCounter returns a count of finished CoreMock.DeleteSession invocations
func (mmDeleteSession *CoreMock) DeleteSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.afterDeleteSessionCounter)
}

// DeleteSessionBeforeCounter returns a count of CoreMock.DeleteSession invocations
func (mmDeleteSession *CoreMock) DeleteSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSession.beforeDeleteSessionCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.DeleteSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSession *mCoreMockDeleteSession) Calls() []*CoreMockDeleteSessionParams {
	mmDeleteSession.mutex.RLock()

	argCopy := make([]*CoreMockDeleteSessionParams, len(mmDeleteSession.callArgs))
	copy(argCopy, mmDeleteSession.callArgs)

	mmDeleteSession.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionDone returns true if the count of the DeleteSession invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockDeleteSessionDone() bool {
	if m.DeleteSessionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionMock.invocationsDone()
}

// MinimockDeleteSessionInspect logs each unmet expectation
func (m *CoreMock) MinimockDeleteSessionInspect() {
	for _, e := range m.DeleteSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.DeleteSession at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionMock.defaultExpectation != nil && afterDeleteSessionCounter < 1 {
		if m.DeleteSessionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.DeleteSession at\n%s", m.DeleteSessionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.DeleteSession at\n%s with params: %#v", m.DeleteSessionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSession != nil && afterDeleteSessionCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.DeleteSession at\n%s", m.funcDeleteSessionOrigin)
	}

	if !m.DeleteSessionMock.invocationsDone() && afterDeleteSessionCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.DeleteSession at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionMock.expectedInvocations), m.DeleteSessionMock.expectedInvocationsOrigin, afterDeleteSessionCounter)
	}
}

type mCoreMockDeleteSessionsByUserID struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockDeleteSessionsByUserIDExpectation
	expectations       []*CoreMockDeleteSessionsByUserIDExpectation

	callArgs []*CoreMockDeleteSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockDeleteSessionsByUserIDExpectation specifies expectation struct of the Core.DeleteSessionsByUserID
type CoreMockDeleteSessionsByUserIDExpectation struct {
	mock               *CoreMock
	params             *CoreMockDeleteSessionsByUserIDParams
	paramPtrs          *CoreMockDeleteSessionsByUserIDParamPtrs
	expectationOrigins CoreMockDeleteSessionsByUserIDExpectationOrigins
	results            *CoreMockDeleteSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockDeleteSessionsByUserIDParams contains parameters of the Core.DeleteSessionsByUserID
type CoreMockDeleteSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// CoreMockDeleteSessionsByUserIDParamPtrs contains pointers to parameters of the Core.DeleteSessionsByUserID
type CoreMockDeleteSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// CoreMockDeleteSessionsByUserIDResults contains results of the Core.DeleteSessionsByUserID
type CoreMockDeleteSessionsByUserIDResults struct {
	err error
}

// CoreMockDeleteSessionsByUserIDOrigins contains origins of expectations of the Core.DeleteSessionsByUserID
type CoreMockDeleteSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Optional() *mCoreMockDeleteSessionsByUserID {
	mmDeleteSessionsByUserID.optional = true
	return mmDeleteSessionsByUserID
}

// Expect sets up expected params for Core.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mCoreMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &CoreMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteSessionsByUserID.defaultExpectation.params = &CoreMockDeleteSessionsByUserIDParams{ctx, userID}
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteSessionsByUserID.defaultExpectation.params) {
			mmDeleteSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Core.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mCoreMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &CoreMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &CoreMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for Core.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mCoreMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &CoreMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &CoreMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Core.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mCoreMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Inspect function is already set for CoreMock.DeleteSessionsByUserID")
	}

	mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID = f

	return mmDeleteSessionsByUserID
}

// Return sets up results that will be returned by Core.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Return(err error) *CoreMock {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &CoreMockDeleteSessionsByUserIDExpectation{mock: mmDeleteSessionsByUserID.mock}
	}
	mmDeleteSessionsByUserID.defaultExpectation.results = &CoreMockDeleteSessionsByUserIDResults{err}
	mmDeleteSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// Set uses given function f to mock the Core.DeleteSessionsByUserID method
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (err error)) *CoreMock {
	if mmDeleteSessionsByUserID.defaultExpectation != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the Core.DeleteSessionsByUserID method")
	}

	if len(mmDeleteSessionsByUserID.expectations) > 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the Core.DeleteSessionsByUserID method")
	}

	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID = f
	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// When sets expectation for the Core.DeleteSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *CoreMockDeleteSessionsByUserIDExpectation {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("CoreMock.DeleteSessionsByUserID mock is already set by Set")
	}

	expectation := &CoreMockDeleteSessionsByUserIDExpectation{
		mock:               mmDeleteSessionsByUserID.mock,
		params:             &CoreMockDeleteSessionsByUserIDParams{ctx, userID},
		expectationOrigins: CoreMockDeleteSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSessionsByUserID.expectations = append(mmDeleteSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Core.DeleteSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *CoreMockDeleteSessionsByUserIDExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockDeleteSessionsByUserIDResults{err}
	return e.mock
}

// Times sets number of times Core.DeleteSessionsByUserID should be invoked
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Times(n uint64) *mCoreMockDeleteSessionsByUserID {
	if n == 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Times of CoreMock.DeleteSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSessionsByUserID.expectedInvocations, n)
	mmDeleteSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID
}

func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) invocationsDone() bool {
	if len(mmDeleteSessionsByUserID.expectations) == 0 && mmDeleteSessionsByUserID.defaultExpectation == nil && mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.mock.afterDeleteSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSessionsByUserID implements mm_usecase.Core
func (mmDeleteSessionsByUserID *CoreMock) DeleteSessionsByUserID(ctx context.Context, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter, 1)

	mmDeleteSessionsByUserID.t.Helper()

	if mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID(ctx, userID)
	}

	mm_params := CoreMockDeleteSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Lock()
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs = append(mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs, &mm_params)
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CoreMockDeleteSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSessionsByUserID.t.Errorf("CoreMock.DeleteSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSessionsByUserID.t.Errorf("CoreMock.DeleteSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSessionsByUserID.t.Errorf("CoreMock.DeleteSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSessionsByUserID.t.Fatal("No results are set for the CoreMock.DeleteSessionsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteSessionsByUserID.funcDeleteSessionsByUserID != nil {
		return mmDeleteSessionsByUserID.funcDeleteSessionsByUserID(ctx, userID)
	}
	mmDeleteSessionsByUserID.t.Fatalf("Unexpected call to CoreMock.DeleteSessionsByUserID. %v %v", ctx, userID)
	return
}

// DeleteSessionsByUserIDAfterCounter returns a count of finished CoreMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *CoreMock) DeleteSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter)
}

// DeleteSessionsByUserIDBeforeCounter returns a count of CoreMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *CoreMock) DeleteSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.DeleteSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSessionsByUserID *mCoreMockDeleteSessionsByUserID) Calls() []*CoreMockDeleteSessionsByUserIDParams {
	mmDeleteSessionsByUserID.mutex.RLock()

	argCopy := make([]*CoreMockDeleteSessionsByUserIDParams, len(mmDeleteSessionsByUserID.callArgs))
	copy(argCopy, mmDeleteSessionsByUserID.callArgs)

	mmDeleteSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionsByUserIDDone returns true if the count of the DeleteSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockDeleteSessionsByUserIDDone() bool {
	if m.DeleteSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionsByUserIDMock.invocationsDone()
}

// MinimockDeleteSessionsByUserIDInspect logs each unmet expectation
func (m *CoreMock) MinimockDeleteSessionsByUserIDInspect() {
	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.DeleteSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionsByUserIDMock.defaultExpectation != nil && afterDeleteSessionsByUserIDCounter < 1 {
		if m.DeleteSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.DeleteSessionsByUserID at\n%s", m.DeleteSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.DeleteSessionsByUserID at\n%s with params: %#v", m.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSessionsByUserID != nil && afterDeleteSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.DeleteSessionsByUserID at\n%s", m.funcDeleteSessionsByUserIDOrigin)
	}

	if !m.DeleteSessionsByUserIDMock.invocationsDone() && afterDeleteSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.DeleteSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionsByUserIDMock.expectedInvocations), m.DeleteSessionsByUserIDMock.expectedInvocationsOrigin, afterDeleteSessionsByUserIDCounter)
	}
}

type mCoreMockDeleteUserRole struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockDeleteUserRoleExpectation
	expectations       []*CoreMockDeleteUserRoleExpectation

	callArgs []*CoreMockDeleteUserRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockDeleteUserRoleExpectation specifies expectation struct of the Core.DeleteUserRole
type CoreMockDeleteUserRoleExpectation struct {
	mock               *CoreMock
	params             *CoreMockDeleteUserRoleParams
	paramPtrs          *CoreMockDeleteUserRoleParamPtrs
	expectationOrigins CoreMockDeleteUserRoleExpectationOrigins
	results            *CoreMockDeleteUserRoleResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockDeleteUserRoleParams contains parameters of the Core.DeleteUserRole
type CoreMockDeleteUserRoleParams struct {
	ctx  context.Context
	role auth.UserRole
}

// CoreMockDeleteUserRoleParamPtrs contains pointers to parameters of the Core.DeleteUserRole
type CoreMockDeleteUserRoleParamPtrs struct {
	ctx  *context.Context
	role *auth.UserRole
}

// CoreMockDeleteUserRoleResults contains results of the Core.DeleteUserRole
type CoreMockDeleteUserRoleResults struct {
	err error
}

// CoreMockDeleteUserRoleOrigins contains origins of expectations of the Core.DeleteUserRole
type CoreMockDeleteUserRoleExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Optional() *mCoreMockDeleteUserRole {
	mmDeleteUserRole.optional = true
	return mmDeleteUserRole
}

// Expect sets up expected params for Core.DeleteUserRole
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Expect(ctx context.Context, role auth.UserRole) *mCoreMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &CoreMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by ExpectParams functions")
	}

	mmDeleteUserRole.defaultExpectation.params = &CoreMockDeleteUserRoleParams{ctx, role}
	mmDeleteUserRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUserRole.expectations {
		if minimock.Equal(e.params, mmDeleteUserRole.defaultExpectation.params) {
			mmDeleteUserRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserRole.defaultExpectation.params)
		}
	}

	return mmDeleteUserRole
}

// ExpectCtxParam1 sets up expected param ctx for Core.DeleteUserRole
func (mmDeleteUserRole *mCoreMockDeleteUserRole) ExpectCtxParam1(ctx context.Context) *mCoreMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &CoreMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.params != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Expect")
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs == nil {
		mmDeleteUserRole.defaultExpectation.paramPtrs = &CoreMockDeleteUserRoleParamPtrs{}
	}
	mmDeleteUserRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUserRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUserRole
}

// ExpectRoleParam2 sets up expected param role for Core.DeleteUserRole
func (mmDeleteUserRole *mCoreMockDeleteUserRole) ExpectRoleParam2(role auth.UserRole) *mCoreMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &CoreMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.params != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Expect")
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs == nil {
		mmDeleteUserRole.defaultExpectation.paramPtrs = &CoreMockDeleteUserRoleParamPtrs{}
	}
	mmDeleteUserRole.defaultExpectation.paramPtrs.role = &role
	mmDeleteUserRole.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmDeleteUserRole
}

// Inspect accepts an inspector function that has same arguments as the Core.DeleteUserRole
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Inspect(f func(ctx context.Context, role auth.UserRole)) *mCoreMockDeleteUserRole {
	if mmDeleteUserRole.mock.inspectFuncDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("Inspect function is already set for CoreMock.DeleteUserRole")
	}

	mmDeleteUserRole.mock.inspectFuncDeleteUserRole = f

	return mmDeleteUserRole
}

// Return sets up results that will be returned by Core.DeleteUserRole
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Return(err error) *CoreMock {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &CoreMockDeleteUserRoleExpectation{mock: mmDeleteUserRole.mock}
	}
	mmDeleteUserRole.defaultExpectation.results = &CoreMockDeleteUserRoleResults{err}
	mmDeleteUserRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole.mock
}

// Set uses given function f to mock the Core.DeleteUserRole method
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Set(f func(ctx context.Context, role auth.UserRole) (err error)) *CoreMock {
	if mmDeleteUserRole.defaultExpectation != nil {
		mmDeleteUserRole.mock.t.Fatalf("Default expectation is already set for the Core.DeleteUserRole method")
	}

	if len(mmDeleteUserRole.expectations) > 0 {
		mmDeleteUserRole.mock.t.Fatalf("Some expectations are already set for the Core.DeleteUserRole method")
	}

	mmDeleteUserRole.mock.funcDeleteUserRole = f
	mmDeleteUserRole.mock.funcDeleteUserRoleOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole.mock
}

// When sets expectation for the Core.DeleteUserRole which will trigger the result defined by the following
// Then helper
func (mmDeleteUserRole *mCoreMockDeleteUserRole) When(ctx context.Context, role auth.UserRole) *CoreMockDeleteUserRoleExpectation {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("CoreMock.DeleteUserRole mock is already set by Set")
	}

	expectation := &CoreMockDeleteUserRoleExpectation{
		mock:               mmDeleteUserRole.mock,
		params:             &CoreMockDeleteUserRoleParams{ctx, role},
		expectationOrigins: CoreMockDeleteUserRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUserRole.expectations = append(mmDeleteUserRole.expectations, expectation)
	return expectation
}

// Then sets up Core.DeleteUserRole return parameters for the expectation previously defined by the When method
func (e *CoreMockDeleteUserRoleExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockDeleteUserRoleResults{err}
	return e.mock
}

// Times sets number of times Core.DeleteUserRole should be invoked
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Times(n uint64) *mCoreMockDeleteUserRole {
	if n == 0 {
		mmDeleteUserRole.mock.t.Fatalf("Times of CoreMock.DeleteUserRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUserRole.expectedInvocations, n)
	mmDeleteUserRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole
}

func (mmDeleteUserRole *mCoreMockDeleteUserRole) invocationsDone() bool {
	if len(mmDeleteUserRole.expectations) == 0 && mmDeleteUserRole.defaultExpectation == nil && mmDeleteUserRole.mock.funcDeleteUserRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUserRole.mock.afterDeleteUserRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUserRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUserRole implements mm_usecase.Core
func (mmDeleteUserRole *CoreMock) DeleteUserRole(ctx context.Context, role auth.UserRole) (err error) {
	mm_atomic.AddUint64(&mmDeleteUserRole.beforeDeleteUserRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserRole.afterDeleteUserRoleCounter, 1)

	mmDeleteUserRole.t.Helper()

	if mmDeleteUserRole.inspectFuncDeleteUserRole != nil {
		mmDeleteUserRole.inspectFuncDeleteUserRole(ctx, role)
	}

	mm_params := CoreMockDeleteUserRoleParams{ctx, role}

	// Record call args
	mmDeleteUserRole.DeleteUserRoleMock.mutex.Lock()
	mmDeleteUserRole.DeleteUserRoleMock.callArgs = append(mmDeleteUserRole.DeleteUserRoleMock.callArgs, &mm_params)
	mmDeleteUserRole.DeleteUserRoleMock.mutex.Unlock()

	for _, e := range mmDeleteUserRole.DeleteUserRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.paramPtrs

		mm_got := CoreMockDeleteUserRoleParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUserRole.t.Errorf("CoreMock.DeleteUserRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmDeleteUserRole.t.Errorf("CoreMock.DeleteUserRole got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserRole.t.Errorf("CoreMock.DeleteUserRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserRole.t.Fatal("No results are set for the CoreMock.DeleteUserRole")
		}
		return (*mm_results).err
	}
	if mmDeleteUserRole.funcDeleteUserRole != nil {
		return mmDeleteUserRole.funcDeleteUserRole(ctx, role)
	}
	mmDeleteUserRole.t.Fatalf("Unexpected call to CoreMock.DeleteUserRole. %v %v", ctx, role)
	return
}

// DeleteUserRoleAfterCounter returns a count of finished CoreMock.DeleteUserRole invocations
func (mmDeleteUserRole *CoreMock) DeleteUserRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserRole.afterDeleteUserRoleCounter)
}

// DeleteUserRoleBeforeCounter returns a count of CoreMock.DeleteUserRole invocations
func (mmDeleteUserRole *CoreMock) DeleteUserRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserRole.beforeDeleteUserRoleCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.DeleteUserRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserRole *mCoreMockDeleteUserRole) Calls() []*CoreMockDeleteUserRoleParams {
	mmDeleteUserRole.mutex.RLock()

	argCopy := make([]*CoreMockDeleteUserRoleParams, len(mmDeleteUserRole.callArgs))
	copy(argCopy, mmDeleteUserRole.callArgs)

	mmDeleteUserRole.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserRoleDone returns true if the count of the DeleteUserRole invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockDeleteUserRoleDone() bool {
	if m.DeleteUserRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserRoleMock.invocationsDone()
}

// MinimockDeleteUserRoleInspect logs each unmet expectation
func (m *CoreMock) MinimockDeleteUserRoleInspect() {
	for _, e := range m.DeleteUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.DeleteUserRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserRoleCounter := mm_atomic.LoadUint64(&m.afterDeleteUserRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserRoleMock.defaultExpectation != nil && afterDeleteUserRoleCounter < 1 {
		if m.DeleteUserRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.DeleteUserRole at\n%s", m.DeleteUserRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.DeleteUserRole at\n%s with params: %#v", m.DeleteUserRoleMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserRole != nil && afterDeleteUserRoleCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.DeleteUserRole at\n%s", m.funcDeleteUserRoleOrigin)
	}

	if !m.DeleteUserRoleMock.invocationsDone() && afterDeleteUserRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.DeleteUserRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserRoleMock.expectedInvocations), m.DeleteUserRoleMock.expectedInvocationsOrigin, afterDeleteUserRoleCounter)
	}
}

type mCoreMockGetSessionByID struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetSessionByIDExpectation
	expectations       []*CoreMockGetSessionByIDExpectation

	callArgs []*CoreMockGetSessionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetSessionByIDExpectation specifies expectation struct of the Core.GetSessionByID
type CoreMockGetSessionByIDExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetSessionByIDParams
	paramPtrs          *CoreMockGetSessionByIDParamPtrs
	expectationOrigins CoreMockGetSessionByIDExpectationOrigins
	results            *CoreMockGetSessionByIDResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetSessionByIDParams contains parameters of the Core.GetSessionByID
type CoreMockGetSessionByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockGetSessionByIDParamPtrs contains pointers to parameters of the Core.GetSessionByID
type CoreMockGetSessionByIDParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockGetSessionByIDResults contains results of the Core.GetSessionByID
type CoreMockGetSessionByIDResults struct {
	s1  auth.Session
	s2  string
	err error
}

// CoreMockGetSessionByIDOrigins contains origins of expectations of the Core.GetSessionByID
type CoreMockGetSessionByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSessionByID *mCoreMockGetSessionByID) Optional() *mCoreMockGetSessionByID {
	mmGetSessionByID.optional = true
	return mmGetSessionByID
}

// Expect sets up expected params for Core.GetSessionByID
func (mmGetSessionByID *mCoreMockGetSessionByID) Expect(ctx context.Context, id uuid.UUID) *mCoreMockGetSessionByID {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &CoreMockGetSessionByIDExpectation{}
	}

	if mmGetSessionByID.defaultExpectation.paramPtrs != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by ExpectParams functions")
	}

	mmGetSessionByID.defaultExpectation.params = &CoreMockGetSessionByIDParams{ctx, id}
	mmGetSessionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSessionByID.expectations {
		if minimock.Equal(e.params, mmGetSessionByID.defaultExpectation.params) {
			mmGetSessionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSessionByID.defaultExpectation.params)
		}
	}

	return mmGetSessionByID
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetSessionByID
func (mmGetSessionByID *mCoreMockGetSessionByID) ExpectCtxParam1(ctx context.Context) *mCoreMockGetSessionByID {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &CoreMockGetSessionByIDExpectation{}
	}

	if mmGetSessionByID.defaultExpectation.params != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Expect")
	}

	if mmGetSessionByID.defaultExpectation.paramPtrs == nil {
		mmGetSessionByID.defaultExpectation.paramPtrs = &CoreMockGetSessionByIDParamPtrs{}
	}
	mmGetSessionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSessionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSessionByID
}

// ExpectIdParam2 sets up expected param id for Core.GetSessionByID
func (mmGetSessionByID *mCoreMockGetSessionByID) ExpectIdParam2(id uuid.UUID) *mCoreMockGetSessionByID {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &CoreMockGetSessionByIDExpectation{}
	}

	if mmGetSessionByID.defaultExpectation.params != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Expect")
	}

	if mmGetSessionByID.defaultExpectation.paramPtrs == nil {
		mmGetSessionByID.defaultExpectation.paramPtrs = &CoreMockGetSessionByIDParamPtrs{}
	}
	mmGetSessionByID.defaultExpectation.paramPtrs.id = &id
	mmGetSessionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetSessionByID
}

// Inspect accepts an inspector function that has same arguments as the Core.GetSessionByID
func (mmGetSessionByID *mCoreMockGetSessionByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockGetSessionByID {
	if mmGetSessionByID.mock.inspectFuncGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("Inspect function is already set for CoreMock.GetSessionByID")
	}

	mmGetSessionByID.mock.inspectFuncGetSessionByID = f

	return mmGetSessionByID
}

// Return sets up results that will be returned by Core.GetSessionByID
func (mmGetSessionByID *mCoreMockGetSessionByID) Return(s1 auth.Session, s2 string, err error) *CoreMock {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &CoreMockGetSessionByIDExpectation{mock: mmGetSessionByID.mock}
	}
	mmGetSessionByID.defaultExpectation.results = &CoreMockGetSessionByIDResults{s1, s2, err}
	mmGetSessionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSessionByID.mock
}

// Set uses given function f to mock the Core.GetSessionByID method
func (mmGetSessionByID *mCoreMockGetSessionByID) Set(f func(ctx context.Context, id uuid.UUID) (s1 auth.Session, s2 string, err error)) *CoreMock {
	if mmGetSessionByID.defaultExpectation != nil {
		mmGetSessionByID.mock.t.Fatalf("Default expectation is already set for the Core.GetSessionByID method")
	}

	if len(mmGetSessionByID.expectations) > 0 {
		mmGetSessionByID.mock.t.Fatalf("Some expectations are already set for the Core.GetSessionByID method")
	}

	mmGetSessionByID.mock.funcGetSessionByID = f
	mmGetSessionByID.mock.funcGetSessionByIDOrigin = minimock.CallerInfo(1)
	return mmGetSessionByID.mock
}

// When sets expectation for the Core.GetSessionByID which will trigger the result defined by the following
// Then helper
func (mmGetSessionByID *mCoreMockGetSessionByID) When(ctx context.Context, id uuid.UUID) *CoreMockGetSessionByIDExpectation {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("CoreMock.GetSessionByID mock is already set by Set")
	}

	expectation := &CoreMockGetSessionByIDExpectation{
		mock:               mmGetSessionByID.mock,
		params:             &CoreMockGetSessionByIDParams{ctx, id},
		expectationOrigins: CoreMockGetSessionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSessionByID.expectations = append(mmGetSessionByID.expectations, expectation)
	return expectation
}

// Then sets up Core.GetSessionByID return parameters for the expectation previously defined by the When method
func (e *CoreMockGetSessionByIDExpectation) Then(s1 auth.Session, s2 string, err error) *CoreMock {
	e.results = &CoreMockGetSessionByIDResults{s1, s2, err}
	return e.mock
}

// Times sets number of times Core.GetSessionByID should be invoked
func (mmGetSessionByID *mCoreMockGetSessionByID) Times(n uint64) *mCoreMockGetSessionByID {
	if n == 0 {
		mmGetSessionByID.mock.t.Fatalf("Times of CoreMock.GetSessionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSessionByID.expectedInvocations, n)
	mmGetSessionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSessionByID
}

func (mmGetSessionByID *mCoreMockGetSessionByID) invocationsDone() bool {
	if len(mmGetSessionByID.expectations) == 0 && mmGetSessionByID.defaultExpectation == nil && mmGetSessionByID.mock.funcGetSessionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSessionByID.mock.afterGetSessionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSessionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSessionByID implements mm_usecase.Core
func (mmGetSessionByID *CoreMock) GetSessionByID(ctx context.Context, id uuid.UUID) (s1 auth.Session, s2 string, err error) {
	mm_atomic.AddUint64(&mmGetSessionByID.beforeGetSessionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSessionByID.afterGetSessionByIDCounter, 1)

	mmGetSessionByID.t.Helper()

	if mmGetSessionByID.inspectFuncGetSessionByID != nil {
		mmGetSessionByID.inspectFuncGetSessionByID(ctx, id)
	}

	mm_params := CoreMockGetSessionByIDParams{ctx, id}

	// Record call args
	mmGetSessionByID.GetSessionByIDMock.mutex.Lock()
	mmGetSessionByID.GetSessionByIDMock.callArgs = append(mmGetSessionByID.GetSessionByIDMock.callArgs, &mm_params)
	mmGetSessionByID.GetSessionByIDMock.mutex.Unlock()

	for _, e := range mmGetSessionByID.GetSessionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.s2, e.results.err
		}
	}

	if mmGetSessionByID.GetSessionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSessionByID.GetSessionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSessionByID.GetSessionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSessionByID.GetSessionByIDMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetSessionByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSessionByID.t.Errorf("CoreMock.GetSessionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionByID.GetSessionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetSessionByID.t.Errorf("CoreMock.GetSessionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionByID.GetSessionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSessionByID.t.Errorf("CoreMock.GetSessionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSessionByID.GetSessionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSessionByID.GetSessionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSessionByID.t.Fatal("No results are set for the CoreMock.GetSessionByID")
		}
		return (*mm_results).s1, (*mm_results).s2, (*mm_results).err
	}
	if mmGetSessionByID.funcGetSessionByID != nil {
		return mmGetSessionByID.funcGetSessionByID(ctx, id)
	}
	mmGetSessionByID.t.Fatalf("Unexpected call to CoreMock.GetSessionByID. %v %v", ctx, id)
	return
}

// GetSessionByIDAfterCounter returns a count of finished CoreMock.GetSessionByID invocations
func (mmGetSessionByID *CoreMock) GetSessionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionByID.afterGetSessionByIDCounter)
}

// GetSessionByIDBeforeCounter returns a count of CoreMock.GetSessionByID invocations
func (mmGetSessionByID *CoreMock) GetSessionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionByID.beforeGetSessionByIDCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetSessionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSessionByID *mCoreMockGetSessionByID) Calls() []*CoreMockGetSessionByIDParams {
	mmGetSessionByID.mutex.RLock()

	argCopy := make([]*CoreMockGetSessionByIDParams, len(mmGetSessionByID.callArgs))
	copy(argCopy, mmGetSessionByID.callArgs)

	mmGetSessionByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSessionByIDDone returns true if the count of the GetSessionByID invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetSessionByIDDone() bool {
	if m.GetSessionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSessionByIDMock.invocationsDone()
}

// MinimockGetSessionByIDInspect logs each unmet expectation
func (m *CoreMock) MinimockGetSessionByIDInspect() {
	for _, e := range m.GetSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetSessionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSessionByIDCounter := mm_atomic.LoadUint64(&m.afterGetSessionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSessionByIDMock.defaultExpectation != nil && afterGetSessionByIDCounter < 1 {
		if m.GetSessionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetSessionByID at\n%s", m.GetSessionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetSessionByID at\n%s with params: %#v", m.GetSessionByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSessionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSessionByID != nil && afterGetSessionByIDCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetSessionByID at\n%s", m.funcGetSessionByIDOrigin)
	}

	if !m.GetSessionByIDMock.invocationsDone() && afterGetSessionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetSessionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSessionByIDMock.expectedInvocations), m.GetSessionByIDMock.expectedInvocationsOrigin, afterGetSessionByIDCounter)
	}
}

type mCoreMockGetSessionsByUserID struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetSessionsByUserIDExpectation
	expectations       []*CoreMockGetSessionsByUserIDExpectation

	callArgs []*CoreMockGetSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetSessionsByUserIDExpectation specifies expectation struct of the Core.GetSessionsByUserID
type CoreMockGetSessionsByUserIDExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetSessionsByUserIDParams
	paramPtrs          *CoreMockGetSessionsByUserIDParamPtrs
	expectationOrigins CoreMockGetSessionsByUserIDExpectationOrigins
	results            *CoreMockGetSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetSessionsByUserIDParams contains parameters of the Core.GetSessionsByUserID
type CoreMockGetSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// CoreMockGetSessionsByUserIDParamPtrs contains pointers to parameters of the Core.GetSessionsByUserID
type CoreMockGetSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// CoreMockGetSessionsByUserIDResults contains results of the Core.GetSessionsByUserID
type CoreMockGetSessionsByUserIDResults struct {
	sa1 []auth.Session
	err error
}

// CoreMockGetSessionsByUserIDOrigins contains origins of expectations of the Core.GetSessionsByUserID
type CoreMockGetSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Optional() *mCoreMockGetSessionsByUserID {
	mmGetSessionsByUserID.optional = true
	return mmGetSessionsByUserID
}

// Expect sets up expected params for Core.GetSessionsByUserID
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mCoreMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &CoreMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmGetSessionsByUserID.defaultExpectation.params = &CoreMockGetSessionsByUserIDParams{ctx, userID}
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmGetSessionsByUserID.defaultExpectation.params) {
			mmGetSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmGetSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetSessionsByUserID
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mCoreMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &CoreMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.params != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Expect")
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetSessionsByUserID.defaultExpectation.paramPtrs = &CoreMockGetSessionsByUserIDParamPtrs{}
	}
	mmGetSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for Core.GetSessionsByUserID
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mCoreMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &CoreMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.params != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Expect")
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetSessionsByUserID.defaultExpectation.paramPtrs = &CoreMockGetSessionsByUserIDParamPtrs{}
	}
	mmGetSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Core.GetSessionsByUserID
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mCoreMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.inspectFuncGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("Inspect function is already set for CoreMock.GetSessionsByUserID")
	}

	mmGetSessionsByUserID.mock.inspectFuncGetSessionsByUserID = f

	return mmGetSessionsByUserID
}

// Return sets up results that will be returned by Core.GetSessionsByUserID
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Return(sa1 []auth.Session, err error) *CoreMock {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &CoreMockGetSessionsByUserIDExpectation{mock: mmGetSessionsByUserID.mock}
	}
	mmGetSessionsByUserID.defaultExpectation.results = &CoreMockGetSessionsByUserIDResults{sa1, err}
	mmGetSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID.mock
}

// Set uses given function f to mock the Core.GetSessionsByUserID method
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (sa1 []auth.Session, err error)) *CoreMock {
	if mmGetSessionsByUserID.defaultExpectation != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the Core.GetSessionsByUserID method")
	}

	if len(mmGetSessionsByUserID.expectations) > 0 {
		mmGetSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the Core.GetSessionsByUserID method")
	}

	mmGetSessionsByUserID.mock.funcGetSessionsByUserID = f
	mmGetSessionsByUserID.mock.funcGetSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID.mock
}

// When sets expectation for the Core.GetSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *CoreMockGetSessionsByUserIDExpectation {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("CoreMock.GetSessionsByUserID mock is already set by Set")
	}

	expectation := &CoreMockGetSessionsByUserIDExpectation{
		mock:               mmGetSessionsByUserID.mock,
		params:             &CoreMockGetSessionsByUserIDParams{ctx, userID},
		expectationOrigins: CoreMockGetSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSessionsByUserID.expectations = append(mmGetSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Core.GetSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *CoreMockGetSessionsByUserIDExpectation) Then(sa1 []auth.Session, err error) *CoreMock {
	e.results = &CoreMockGetSessionsByUserIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Core.GetSessionsByUserID should be invoked
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Times(n uint64) *mCoreMockGetSessionsByUserID {
	if n == 0 {
		mmGetSessionsByUserID.mock.t.Fatalf("Times of CoreMock.GetSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSessionsByUserID.expectedInvocations, n)
	mmGetSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID
}

func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) invocationsDone() bool {
	if len(mmGetSessionsByUserID.expectations) == 0 && mmGetSessionsByUserID.defaultExpectation == nil && mmGetSessionsByUserID.mock.funcGetSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSessionsByUserID.mock.afterGetSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSessionsByUserID implements mm_usecase.Core
func (mmGetSessionsByUserID *CoreMock) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) (sa1 []auth.Session, err error) {
	mm_atomic.AddUint64(&mmGetSessionsByUserID.beforeGetSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSessionsByUserID.afterGetSessionsByUserIDCounter, 1)

	mmGetSessionsByUserID.t.Helper()

	if mmGetSessionsByUserID.inspectFuncGetSessionsByUserID != nil {
		mmGetSessionsByUserID.inspectFuncGetSessionsByUserID(ctx, userID)
	}

	mm_params := CoreMockGetSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmGetSessionsByUserID.GetSessionsByUserIDMock.mutex.Lock()
	mmGetSessionsByUserID.GetSessionsByUserIDMock.callArgs = append(mmGetSessionsByUserID.GetSessionsByUserIDMock.callArgs, &mm_params)
	mmGetSessionsByUserID.GetSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetSessionsByUserID.GetSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSessionsByUserID.t.Errorf("CoreMock.GetSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetSessionsByUserID.t.Errorf("CoreMock.GetSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSessionsByUserID.t.Errorf("CoreMock.GetSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSessionsByUserID.t.Fatal("No results are set for the CoreMock.GetSessionsByUserID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSessionsByUserID.funcGetSessionsByUserID != nil {
		return mmGetSessionsByUserID.funcGetSessionsByUserID(ctx, userID)
	}
	mmGetSessionsByUserID.t.Fatalf("Unexpected call to CoreMock.GetSessionsByUserID. %v %v", ctx, userID)
	return
}

// GetSessionsByUserIDAfterCounter returns a count of finished CoreMock.GetSessionsByUserID invocations
func (mmGetSessionsByUserID *CoreMock) GetSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionsByUserID.afterGetSessionsByUserIDCounter)
}

// GetSessionsByUserIDBeforeCounter returns a count of CoreMock.GetSessionsByUserID invocations
func (mmGetSessionsByUserID *CoreMock) GetSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionsByUserID.beforeGetSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSessionsByUserID *mCoreMockGetSessionsByUserID) Calls() []*CoreMockGetSessionsByUserIDParams {
	mmGetSessionsByUserID.mutex.RLock()

	argCopy := make([]*CoreMockGetSessionsByUserIDParams, len(mmGetSessionsByUserID.callArgs))
	copy(argCopy, mmGetSessionsByUserID.callArgs)

	mmGetSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSessionsByUserIDDone returns true if the count of the GetSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetSessionsByUserIDDone() bool {
	if m.GetSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSessionsByUserIDMock.invocationsDone()
}

// MinimockGetSessionsByUserIDInspect logs each unmet expectation
func (m *CoreMock) MinimockGetSessionsByUserIDInspect() {
	for _, e := range m.GetSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSessionsByUserIDMock.defaultExpectation != nil && afterGetSessionsByUserIDCounter < 1 {
		if m.GetSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetSessionsByUserID at\n%s", m.GetSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetSessionsByUserID at\n%s with params: %#v", m.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSessionsByUserID != nil && afterGetSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetSessionsByUserID at\n%s", m.funcGetSessionsByUserIDOrigin)
	}

	if !m.GetSessionsByUserIDMock.invocationsDone() && afterGetSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSessionsByUserIDMock.expectedInvocations), m.GetSessionsByUserIDMock.expectedInvocationsOrigin, afterGetSessionsByUserIDCounter)
	}
}

type mCoreMockIsAdmin struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockIsAdminExpectation
	expectations       []*CoreMockIsAdminExpectation

	callArgs []*CoreMockIsAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockIsAdminExpectation specifies expectation struct of the Core.IsAdmin
type CoreMockIsAdminExpectation struct {
	mock               *CoreMock
	params             *CoreMockIsAdminParams
	paramPtrs          *CoreMockIsAdminParamPtrs
	expectationOrigins CoreMockIsAdminExpectationOrigins
	results            *CoreMockIsAdminResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockIsAdminParams contains parameters of the Core.IsAdmin
type CoreMockIsAdminParams struct {
	ctx context.Context
}

// CoreMockIsAdminParamPtrs contains pointers to parameters of the Core.IsAdmin
type CoreMockIsAdminParamPtrs struct {
	ctx *context.Context
}

// CoreMockIsAdminResults contains results of the Core.IsAdmin
type CoreMockIsAdminResults struct {
	b1  bool
	err error
}

// CoreMockIsAdminOrigins contains origins of expectations of the Core.IsAdmin
type CoreMockIsAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAdmin *mCoreMockIsAdmin) Optional() *mCoreMockIsAdmin {
	mmIsAdmin.optional = true
	return mmIsAdmin
}

// Expect sets up expected params for Core.IsAdmin
func (mmIsAdmin *mCoreMockIsAdmin) Expect(ctx context.Context) *mCoreMockIsAdmin {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("CoreMock.IsAdmin mock is already set by Set")
	}

	if mmIsAdmin.defaultExpectation == nil {
		mmIsAdmin.defaultExpectation = &CoreMockIsAdminExpectation{}
	}

	if mmIsAdmin.defaultExpectation.paramPtrs != nil {
		mmIsAdmin.mock.t.Fatalf("CoreMock.IsAdmin mock is already set by ExpectParams functions")
	}

	mmIsAdmin.defaultExpectation.params = &CoreMockIsAdminParams{ctx}
	mmIsAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsAdmin.expectations {
		if minimock.Equal(e.params, mmIsAdmin.defaultExpectation.params) {
			mmIsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsAdmin.defaultExpectation.params)
		}
	}

	return mmIsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Core.IsAdmin
func (mmIsAdmin *mCoreMockIsAdmin) ExpectCtxParam1(ctx context.Context) *mCoreMockIsAdmin {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("CoreMock.IsAdmin mock is already set by Set")
	}

	if mmIsAdmin.defaultExpectation == nil {
		mmIsAdmin.defaultExpectation = &CoreMockIsAdminExpectation{}
	}

	if mmIsAdmin.defaultExpectation.params != nil {
		mmIsAdmin.mock.t.Fatalf("CoreMock.IsAdmin mock is already set by Expect")
	}

	if mmIsAdmin.defaultExpectation.paramPtrs == nil {
		mmIsAdmin.defaultExpectation.paramPtrs = &CoreMockIsAdminParamPtrs{}
	}
	mmIsAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsAdmin
}

// Inspect accepts an inspector function that has same arguments as the Core.IsAdmin
func (mmIsAdmin *mCoreMockIsAdmin) Inspect(f func(ctx context.Context)) *mCoreMockIsAdmin {
	if mmIsAdmin.mock.inspectFuncIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("Inspect function is already set for CoreMock.IsAdmin")
	}

	mmIsAdmin.mock.inspectFuncIsAdmin = f

	return mmIsAdmin
}

// Return sets up results that will be returned by Core.IsAdmin
func (mmIsAdmin *mCoreMockIsAdmin) Return(b1 bool, err error) *CoreMock {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("CoreMock.IsAdmin mock is already set by Set")
	}

	if mmIsAdmin.defaultExpectation == nil {
		mmIsAdmin.defaultExpectation = &CoreMockIsAdminExpectation{mock: mmIsAdmin.mock}
	}
	mmIsAdmin.defaultExpectation.results = &CoreMockIsAdminResults{b1, err}
	mmIsAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAdmin.mock
}

// Set uses given function f to mock the Core.IsAdmin method
func (mmIsAdmin *mCoreMockIsAdmin) Set(f func(ctx context.Context) (b1 bool, err error)) *CoreMock {
	if mmIsAdmin.defaultExpectation != nil {
		mmIsAdmin.mock.t.Fatalf("Default expectation is already set for the Core.IsAdmin method")
	}

	if len(mmIsAdmin.expectations) > 0 {
		mmIsAdmin.mock.t.Fatalf("Some expectations are already set for the Core.IsAdmin method")
	}

	mmIsAdmin.mock.funcIsAdmin = f
	mmIsAdmin.mock.funcIsAdminOrigin = minimock.CallerInfo(1)
	return mmIsAdmin.mock
}

// When sets expectation for the Core.IsAdmin which will trigger the result defined by the following
// Then helper
func (mmIsAdmin *mCoreMockIsAdmin) When(ctx context.Context) *CoreMockIsAdminExpectation {
	if mmIsAdmin.mock.funcIsAdmin != nil {
		mmIsAdmin.mock.t.Fatalf("CoreMock.IsAdmin mock is already set by Set")
	}

	expectation := &CoreMockIsAdminExpectation{
		mock:               mmIsAdmin.mock,
		params:             &CoreMockIsAdminParams{ctx},
		expectationOrigins: CoreMockIsAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsAdmin.expectations = append(mmIsAdmin.expectations, expectation)
	return expectation
}

// Then sets up Core.IsAdmin return parameters for the expectation previously defined by the When method
func (e *CoreMockIsAdminExpectation) Then(b1 bool, err error) *CoreMock {
	e.results = &CoreMockIsAdminResults{b1, err}
	return e.mock
}

// Times sets number of times Core.IsAdmin should be invoked
func (mmIsAdmin *mCoreMockIsAdmin) Times(n uint64) *mCoreMockIsAdmin {
	if n == 0 {
		mmIsAdmin.mock.t.Fatalf("Times of CoreMock.IsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAdmin.expectedInvocations, n)
	mmIsAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAdmin
}

func (mmIsAdmin *mCoreMockIsAdmin) invocationsDone() bool {
	if len(mmIsAdmin.expectations) == 0 && mmIsAdmin.defaultExpectation == nil && mmIsAdmin.mock.funcIsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAdmin.mock.afterIsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAdmin implements mm_usecase.Core
func (mmIsAdmin *CoreMock) IsAdmin(ctx context.Context) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsAdmin.beforeIsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAdmin.afterIsAdminCounter, 1)

	mmIsAdmin.t.Helper()

	if mmIsAdmin.inspectFuncIsAdmin != nil {
		mmIsAdmin.inspectFuncIsAdmin(ctx)
	}

	mm_params := CoreMockIsAdminParams{ctx}

	// Record call args
	mmIsAdmin.IsAdminMock.mutex.Lock()
	mmIsAdmin.IsAdminMock.callArgs = append(mmIsAdmin.IsAdminMock.callArgs, &mm_params)
	mmIsAdmin.IsAdminMock.mutex.Unlock()

	for _, e := range mmIsAdmin.IsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsAdmin.IsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAdmin.IsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmIsAdmin.IsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmIsAdmin.IsAdminMock.defaultExpectation.paramPtrs

		mm_got := CoreMockIsAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsAdmin.t.Errorf("CoreMock.IsAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAdmin.IsAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsAdmin.t.Errorf("CoreMock.IsAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsAdmin.IsAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsAdmin.IsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAdmin.t.Fatal("No results are set for the CoreMock.IsAdmin")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsAdmin.funcIsAdmin != nil {
		return mmIsAdmin.funcIsAdmin(ctx)
	}
	mmIsAdmin.t.Fatalf("Unexpected call to CoreMock.IsAdmin. %v", ctx)
	return
}

// IsAdminAfterCounter returns a count of finished CoreMock.IsAdmin invocations
func (mmIsAdmin *CoreMock) IsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAdmin.afterIsAdminCounter)
}

// IsAdminBeforeCounter returns a count of CoreMock.IsAdmin invocations
func (mmIsAdmin *CoreMock) IsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAdmin.beforeIsAdminCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.IsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsAdmin *mCoreMockIsAdmin) Calls() []*CoreMockIsAdminParams {
	mmIsAdmin.mutex.RLock()

	argCopy := make([]*CoreMockIsAdminParams, len(mmIsAdmin.callArgs))
	copy(argCopy, mmIsAdmin.callArgs)

	mmIsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockIsAdminDone returns true if the count of the IsAdmin invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockIsAdminDone() bool {
	if m.IsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAdminMock.invocationsDone()
}

// MinimockIsAdminInspect logs each unmet expectation
func (m *CoreMock) MinimockIsAdminInspect() {
	for _, e := range m.IsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.IsAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsAdminCounter := mm_atomic.LoadUint64(&m.afterIsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAdminMock.defaultExpectation != nil && afterIsAdminCounter < 1 {
		if m.IsAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.IsAdmin at\n%s", m.IsAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.IsAdmin at\n%s with params: %#v", m.IsAdminMock.defaultExpectation.expectationOrigins.origin, *m.IsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAdmin != nil && afterIsAdminCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.IsAdmin at\n%s", m.funcIsAdminOrigin)
	}

	if !m.IsAdminMock.invocationsDone() && afterIsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.IsAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAdminMock.expectedInvocations), m.IsAdminMock.expectedInvocationsOrigin, afterIsAdminCounter)
	}
}

type mCoreMockIssueTokens struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockIssueTokensExpectation
	expectations       []*CoreMockIssueTokensExpectation

	callArgs []*CoreMockIssueTokensParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockIssueTokensExpectation specifies expectation struct of the Core.IssueTokens
type CoreMockIssueTokensExpectation struct {
	mock               *CoreMock
	params             *CoreMockIssueTokensParams
	paramPtrs          *CoreMockIssueTokensParamPtrs
	expectationOrigins CoreMockIssueTokensExpectationOrigins
	results            *CoreMockIssueTokensResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockIssueTokensParams contains parameters of the Core.IssueTokens
type CoreMockIssueTokensParams struct {
	ctx            context.Context
	userID         uuid.UUID
	sessionVersion int
}

// CoreMockIssueTokensParamPtrs contains pointers to parameters of the Core.IssueTokens
type CoreMockIssueTokensParamPtrs struct {
	ctx            *context.Context
	userID         *uuid.UUID
	sessionVersion *int
}

// CoreMockIssueTokensResults contains results of the Core.IssueTokens
type CoreMockIssueTokensResults struct {
	t1  auth.Tokens
	err error
}

// CoreMockIssueTokensOrigins contains origins of expectations of the Core.IssueTokens
type CoreMockIssueTokensExpectationOrigins struct {
	origin               string
	originCtx            string
	originUserID         string
	originSessionVersion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueTokens *mCoreMockIssueTokens) Optional() *mCoreMockIssueTokens {
	mmIssueTokens.optional = true
	return mmIssueTokens
}

// Expect sets up expected params for Core.IssueTokens
func (mmIssueTokens *mCoreMockIssueTokens) Expect(ctx context.Context, userID uuid.UUID, sessionVersion int) *mCoreMockIssueTokens {
	if mmIssueTokens.mock.funcIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Set")
	}

	if mmIssueTokens.defaultExpectation == nil {
		mmIssueTokens.defaultExpectation = &CoreMockIssueTokensExpectation{}
	}

	if mmIssueTokens.defaultExpectation.paramPtrs != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by ExpectParams functions")
	}

	mmIssueTokens.defaultExpectation.params = &CoreMockIssueTokensParams{ctx, userID, sessionVersion}
	mmIssueTokens.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIssueTokens.expectations {
		if minimock.Equal(e.params, mmIssueTokens.defaultExpectation.params) {
			mmIssueTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueTokens.defaultExpectation.params)
		}
	}

	return mmIssueTokens
}

// ExpectCtxParam1 sets up expected param ctx for Core.IssueTokens
func (mmIssueTokens *mCoreMockIssueTokens) ExpectCtxParam1(ctx context.Context) *mCoreMockIssueTokens {
	if mmIssueTokens.mock.funcIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Set")
	}

	if mmIssueTokens.defaultExpectation == nil {
		mmIssueTokens.defaultExpectation = &CoreMockIssueTokensExpectation{}
	}

	if mmIssueTokens.defaultExpectation.params != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Expect")
	}

	if mmIssueTokens.defaultExpectation.paramPtrs == nil {
		mmIssueTokens.defaultExpectation.paramPtrs = &CoreMockIssueTokensParamPtrs{}
	}
	mmIssueTokens.defaultExpectation.paramPtrs.ctx = &ctx
	mmIssueTokens.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIssueTokens
}

// ExpectUserIDParam2 sets up expected param userID for Core.IssueTokens
func (mmIssueTokens *mCoreMockIssueTokens) ExpectUserIDParam2(userID uuid.UUID) *mCoreMockIssueTokens {
	if mmIssueTokens.mock.funcIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Set")
	}

	if mmIssueTokens.defaultExpectation == nil {
		mmIssueTokens.defaultExpectation = &CoreMockIssueTokensExpectation{}
	}

	if mmIssueTokens.defaultExpectation.params != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Expect")
	}

	if mmIssueTokens.defaultExpectation.paramPtrs == nil {
		mmIssueTokens.defaultExpectation.paramPtrs = &CoreMockIssueTokensParamPtrs{}
	}
	mmIssueTokens.defaultExpectation.paramPtrs.userID = &userID
	mmIssueTokens.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmIssueTokens
}

// ExpectSessionVersionParam3 sets up expected param sessionVersion for Core.IssueTokens
func (mmIssueTokens *mCoreMockIssueTokens) ExpectSessionVersionParam3(sessionVersion int) *mCoreMockIssueTokens {
	if mmIssueTokens.mock.funcIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Set")
	}

	if mmIssueTokens.defaultExpectation == nil {
		mmIssueTokens.defaultExpectation = &CoreMockIssueTokensExpectation{}
	}

	if mmIssueTokens.defaultExpectation.params != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Expect")
	}

	if mmIssueTokens.defaultExpectation.paramPtrs == nil {
		mmIssueTokens.defaultExpectation.paramPtrs = &CoreMockIssueTokensParamPtrs{}
	}
	mmIssueTokens.defaultExpectation.paramPtrs.sessionVersion = &sessionVersion
	mmIssueTokens.defaultExpectation.expectationOrigins.originSessionVersion = minimock.CallerInfo(1)

	return mmIssueTokens
}

// Inspect accepts an inspector function that has same arguments as the Core.IssueTokens
func (mmIssueTokens *mCoreMockIssueTokens) Inspect(f func(ctx context.Context, userID uuid.UUID, sessionVersion int)) *mCoreMockIssueTokens {
	if mmIssueTokens.mock.inspectFuncIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("Inspect function is already set for CoreMock.IssueTokens")
	}

	mmIssueTokens.mock.inspectFuncIssueTokens = f

	return mmIssueTokens
}

// Return sets up results that will be returned by Core.IssueTokens
func (mmIssueTokens *mCoreMockIssueTokens) Return(t1 auth.Tokens, err error) *CoreMock {
	if mmIssueTokens.mock.funcIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Set")
	}

	if mmIssueTokens.defaultExpectation == nil {
		mmIssueTokens.defaultExpectation = &CoreMockIssueTokensExpectation{mock: mmIssueTokens.mock}
	}
	mmIssueTokens.defaultExpectation.results = &CoreMockIssueTokensResults{t1, err}
	mmIssueTokens.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIssueTokens.mock
}

// Set uses given function f to mock the Core.IssueTokens method
func (mmIssueTokens *mCoreMockIssueTokens) Set(f func(ctx context.Context, userID uuid.UUID, sessionVersion int) (t1 auth.Tokens, err error)) *CoreMock {
	if mmIssueTokens.defaultExpectation != nil {
		mmIssueTokens.mock.t.Fatalf("Default expectation is already set for the Core.IssueTokens method")
	}

	if len(mmIssueTokens.expectations) > 0 {
		mmIssueTokens.mock.t.Fatalf("Some expectations are already set for the Core.IssueTokens method")
	}

	mmIssueTokens.mock.funcIssueTokens = f
	mmIssueTokens.mock.funcIssueTokensOrigin = minimock.CallerInfo(1)
	return mmIssueTokens.mock
}

// When sets expectation for the Core.IssueTokens which will trigger the result defined by the following
// Then helper
func (mmIssueTokens *mCoreMockIssueTokens) When(ctx context.Context, userID uuid.UUID, sessionVersion int) *CoreMockIssueTokensExpectation {
	if mmIssueTokens.mock.funcIssueTokens != nil {
		mmIssueTokens.mock.t.Fatalf("CoreMock.IssueTokens mock is already set by Set")
	}

	expectation := &CoreMockIssueTokensExpectation{
		mock:               mmIssueTokens.mock,
		params:             &CoreMockIssueTokensParams{ctx, userID, sessionVersion},
		expectationOrigins: CoreMockIssueTokensExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIssueTokens.expectations = append(mmIssueTokens.expectations, expectation)
	return expectation
}

// Then sets up Core.IssueTokens return parameters for the expectation previously defined by the When method
func (e *CoreMockIssueTokensExpectation) Then(t1 auth.Tokens, err error) *CoreMock {
	e.results = &CoreMockIssueTokensResults{t1, err}
	return e.mock
}

// Times sets number of times Core.IssueTokens should be invoked
func (mmIssueTokens *mCoreMockIssueTokens) Times(n uint64) *mCoreMockIssueTokens {
	if n == 0 {
		mmIssueTokens.mock.t.Fatalf("Times of CoreMock.IssueTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIssueTokens.expectedInvocations, n)
	mmIssueTokens.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIssueTokens
}

func (mmIssueTokens *mCoreMockIssueTokens) invocationsDone() bool {
	if len(mmIssueTokens.expectations) == 0 && mmIssueTokens.defaultExpectation == nil && mmIssueTokens.mock.funcIssueTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIssueTokens.mock.afterIssueTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIssueTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IssueTokens implements mm_usecase.Core
func (mmIssueTokens *CoreMock) IssueTokens(ctx context.Context, userID uuid.UUID, sessionVersion int) (t1 auth.Tokens, err error) {
	mm_atomic.AddUint64(&mmIssueTokens.beforeIssueTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmIssueTokens.afterIssueTokensCounter, 1)

	mmIssueTokens.t.Helper()

	if mmIssueTokens.inspectFuncIssueTokens != nil {
		mmIssueTokens.inspectFuncIssueTokens(ctx, userID, sessionVersion)
	}

	mm_params := CoreMockIssueTokensParams{ctx, userID, sessionVersion}

	// Record call args
	mmIssueTokens.IssueTokensMock.mutex.Lock()
	mmIssueTokens.IssueTokensMock.callArgs = append(mmIssueTokens.IssueTokensMock.callArgs, &mm_params)
	mmIssueTokens.IssueTokensMock.mutex.Unlock()

	for _, e := range mmIssueTokens.IssueTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmIssueTokens.IssueTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIssueTokens.IssueTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmIssueTokens.IssueTokensMock.defaultExpectation.params
		mm_want_ptrs := mmIssueTokens.IssueTokensMock.defaultExpectation.paramPtrs

		mm_got := CoreMockIssueTokensParams{ctx, userID, sessionVersion}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIssueTokens.t.Errorf("CoreMock.IssueTokens got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueTokens.IssueTokensMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmIssueTokens.t.Errorf("CoreMock.IssueTokens got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueTokens.IssueTokensMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sessionVersion != nil && !minimock.Equal(*mm_want_ptrs.sessionVersion, mm_got.sessionVersion) {
				mmIssueTokens.t.Errorf("CoreMock.IssueTokens got unexpected parameter sessionVersion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueTokens.IssueTokensMock.defaultExpectation.expectationOrigins.originSessionVersion, *mm_want_ptrs.sessionVersion, mm_got.sessionVersion, minimock.Diff(*mm_want_ptrs.sessionVersion, mm_got.sessionVersion))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIssueTokens.t.Errorf("CoreMock.IssueTokens got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIssueTokens.IssueTokensMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIssueTokens.IssueTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmIssueTokens.t.Fatal("No results are set for the CoreMock.IssueTokens")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmIssueTokens.funcIssueTokens != nil {
		return mmIssueTokens.funcIssueTokens(ctx, userID, sessionVersion)
	}
	mmIssueTokens.t.Fatalf("Unexpected call to CoreMock.IssueTokens. %v %v %v", ctx, userID, sessionVersion)
	return
}

// IssueTokensAfterCounter returns a count of finished CoreMock.IssueTokens invocations
func (mmIssueTokens *CoreMock) IssueTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueTokens.afterIssueTokensCounter)
}

// IssueTokensBeforeCounter returns a count of CoreMock.IssueTokens invocations
func (mmIssueTokens *CoreMock) IssueTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueTokens.beforeIssueTokensCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.IssueTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueTokens *mCoreMockIssueTokens) Calls() []*CoreMockIssueTokensParams {
	mmIssueTokens.mutex.RLock()

	argCopy := make([]*CoreMockIssueTokensParams, len(mmIssueTokens.callArgs))
	copy(argCopy, mmIssueTokens.callArgs)

	mmIssueTokens.mutex.RUnlock()

	return argCopy
}

// MinimockIssueTokensDone returns true if the count of the IssueTokens invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockIssueTokensDone() bool {
	if m.IssueTokensMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IssueTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IssueTokensMock.invocationsDone()
}

// MinimockIssueTokensInspect logs each unmet expectation
func (m *CoreMock) MinimockIssueTokensInspect() {
	for _, e := range m.IssueTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.IssueTokens at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIssueTokensCounter := mm_atomic.LoadUint64(&m.afterIssueTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IssueTokensMock.defaultExpectation != nil && afterIssueTokensCounter < 1 {
		if m.IssueTokensMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.IssueTokens at\n%s", m.IssueTokensMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.IssueTokens at\n%s with params: %#v", m.IssueTokensMock.defaultExpectation.expectationOrigins.origin, *m.IssueTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueTokens != nil && afterIssueTokensCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.IssueTokens at\n%s", m.funcIssueTokensOrigin)
	}

	if !m.IssueTokensMock.invocationsDone() && afterIssueTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.IssueTokens at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IssueTokensMock.expectedInvocations), m.IssueTokensMock.expectedInvocationsOrigin, afterIssueTokensCounter)
	}
}

type mCoreMockListUserRoles struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockListUserRolesExpectation
	expectations       []*CoreMockListUserRolesExpectation

	callArgs []*CoreMockListUserRolesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockListUserRolesExpectation specifies expectation struct of the Core.ListUserRoles
type CoreMockListUserRolesExpectation struct {
	mock               *CoreMock
	params             *CoreMockListUserRolesParams
	paramPtrs          *CoreMockListUserRolesParamPtrs
	expectationOrigins CoreMockListUserRolesExpectationOrigins
	results            *CoreMockListUserRolesResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockListUserRolesParams contains parameters of the Core.ListUserRoles
type CoreMockListUserRolesParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// CoreMockListUserRolesParamPtrs contains pointers to parameters of the Core.ListUserRoles
type CoreMockListUserRolesParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// CoreMockListUserRolesResults contains results of the Core.ListUserRoles
type CoreMockListUserRolesResults struct {
	ua1 []auth.UserRole
	err error
}

// CoreMockListUserRolesOrigins contains origins of expectations of the Core.ListUserRoles
type CoreMockListUserRolesExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserRoles *mCoreMockListUserRoles) Optional() *mCoreMockListUserRoles {
	mmListUserRoles.optional = true
	return mmListUserRoles
}

// Expect sets up expected params for Core.ListUserRoles
func (mmListUserRoles *mCoreMockListUserRoles) Expect(ctx context.Context, userID uuid.UUID) *mCoreMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &CoreMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.paramPtrs != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by ExpectParams functions")
	}

	mmListUserRoles.defaultExpectation.params = &CoreMockListUserRolesParams{ctx, userID}
	mmListUserRoles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListUserRoles.expectations {
		if minimock.Equal(e.params, mmListUserRoles.defaultExpectation.params) {
			mmListUserRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserRoles.defaultExpectation.params)
		}
	}

	return mmListUserRoles
}

// ExpectCtxParam1 sets up expected param ctx for Core.ListUserRoles
func (mmListUserRoles *mCoreMockListUserRoles) ExpectCtxParam1(ctx context.Context) *mCoreMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &CoreMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.params != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Expect")
	}

	if mmListUserRoles.defaultExpectation.paramPtrs == nil {
		mmListUserRoles.defaultExpectation.paramPtrs = &CoreMockListUserRolesParamPtrs{}
	}
	mmListUserRoles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListUserRoles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListUserRoles
}

// ExpectUserIDParam2 sets up expected param userID for Core.ListUserRoles
func (mmListUserRoles *mCoreMockListUserRoles) ExpectUserIDParam2(userID uuid.UUID) *mCoreMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &CoreMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.params != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Expect")
	}

	if mmListUserRoles.defaultExpectation.paramPtrs == nil {
		mmListUserRoles.defaultExpectation.paramPtrs = &CoreMockListUserRolesParamPtrs{}
	}
	mmListUserRoles.defaultExpectation.paramPtrs.userID = &userID
	mmListUserRoles.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListUserRoles
}

// Inspect accepts an inspector function that has same arguments as the Core.ListUserRoles
func (mmListUserRoles *mCoreMockListUserRoles) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mCoreMockListUserRoles {
	if mmListUserRoles.mock.inspectFuncListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("Inspect function is already set for CoreMock.ListUserRoles")
	}

	mmListUserRoles.mock.inspectFuncListUserRoles = f

	return mmListUserRoles
}

// Return sets up results that will be returned by Core.ListUserRoles
func (mmListUserRoles *mCoreMockListUserRoles) Return(ua1 []auth.UserRole, err error) *CoreMock {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &CoreMockListUserRolesExpectation{mock: mmListUserRoles.mock}
	}
	mmListUserRoles.defaultExpectation.results = &CoreMockListUserRolesResults{ua1, err}
	mmListUserRoles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListUserRoles.mock
}

// Set uses given function f to mock the Core.ListUserRoles method
func (mmListUserRoles *mCoreMockListUserRoles) Set(f func(ctx context.Context, userID uuid.UUID) (ua1 []auth.UserRole, err error)) *CoreMock {
	if mmListUserRoles.defaultExpectation != nil {
		mmListUserRoles.mock.t.Fatalf("Default expectation is already set for the Core.ListUserRoles method")
	}

	if len(mmListUserRoles.expectations) > 0 {
		mmListUserRoles.mock.t.Fatalf("Some expectations are already set for the Core.ListUserRoles method")
	}

	mmListUserRoles.mock.funcListUserRoles = f
	mmListUserRoles.mock.funcListUserRolesOrigin = minimock.CallerInfo(1)
	return mmListUserRoles.mock
}

// When sets expectation for the Core.ListUserRoles which will trigger the result defined by the following
// Then helper
func (mmListUserRoles *mCoreMockListUserRoles) When(ctx context.Context, userID uuid.UUID) *CoreMockListUserRolesExpectation {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("CoreMock.ListUserRoles mock is already set by Set")
	}

	expectation := &CoreMockListUserRolesExpectation{
		mock:               mmListUserRoles.mock,
		params:             &CoreMockListUserRolesParams{ctx, userID},
		expectationOrigins: CoreMockListUserRolesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListUserRoles.expectations = append(mmListUserRoles.expectations, expectation)
	return expectation
}

// Then sets up Core.ListUserRoles return parameters for the expectation previously defined by the When method
func (e *CoreMockListUserRolesExpectation) Then(ua1 []auth.UserRole, err error) *CoreMock {
	e.results = &CoreMockListUserRolesResults{ua1, err}
	return e.mock
}

// Times sets number of times Core.ListUserRoles should be invoked
func (mmListUserRoles *mCoreMockListUserRoles) Times(n uint64) *mCoreMockListUserRoles {
	if n == 0 {
		mmListUserRoles.mock.t.Fatalf("Times of CoreMock.ListUserRoles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListUserRoles.expectedInvocations, n)
	mmListUserRoles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListUserRoles
}

func (mmListUserRoles *mCoreMockListUserRoles) invocationsDone() bool {
	if len(mmListUserRoles.expectations) == 0 && mmListUserRoles.defaultExpectation == nil && mmListUserRoles.mock.funcListUserRoles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListUserRoles.mock.afterListUserRolesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListUserRoles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListUserRoles implements mm_usecase.Core
func (mmListUserRoles *CoreMock) ListUserRoles(ctx context.Context, userID uuid.UUID) (ua1 []auth.UserRole, err error) {
	mm_atomic.AddUint64(&mmListUserRoles.beforeListUserRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmListUserRoles.afterListUserRolesCounter, 1)

	mmListUserRoles.t.Helper()

	if mmListUserRoles.inspectFuncListUserRoles != nil {
		mmListUserRoles.inspectFuncListUserRoles(ctx, userID)
	}

	mm_params := CoreMockListUserRolesParams{ctx, userID}

	// Record call args
	mmListUserRoles.ListUserRolesMock.mutex.Lock()
	mmListUserRoles.ListUserRolesMock.callArgs = append(mmListUserRoles.ListUserRolesMock.callArgs, &mm_params)
	mmListUserRoles.ListUserRolesMock.mutex.Unlock()

	for _, e := range mmListUserRoles.ListUserRolesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListUserRoles.ListUserRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUserRoles.ListUserRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmListUserRoles.ListUserRolesMock.defaultExpectation.params
		mm_want_ptrs := mmListUserRoles.ListUserRolesMock.defaultExpectation.paramPtrs

		mm_got := CoreMockListUserRolesParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListUserRoles.t.Errorf("CoreMock.ListUserRoles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListUserRoles.t.Errorf("CoreMock.ListUserRoles got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUserRoles.t.Errorf("CoreMock.ListUserRoles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUserRoles.ListUserRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmListUserRoles.t.Fatal("No results are set for the CoreMock.ListUserRoles")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListUserRoles.funcListUserRoles != nil {
		return mmListUserRoles.funcListUserRoles(ctx, userID)
	}
	mmListUserRoles.t.Fatalf("Unexpected call to CoreMock.ListUserRoles. %v %v", ctx, userID)
	return
}

// ListUserRolesAfterCounter returns a count of finished CoreMock.ListUserRoles invocations
func (mmListUserRoles *CoreMock) ListUserRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserRoles.afterListUserRolesCounter)
}

// ListUserRolesBeforeCounter returns a count of CoreMock.ListUserRoles invocations
func (mmListUserRoles *CoreMock) ListUserRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserRoles.beforeListUserRolesCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.ListUserRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserRoles *mCoreMockListUserRoles) Calls() []*CoreMockListUserRolesParams {
	mmListUserRoles.mutex.RLock()

	argCopy := make([]*CoreMockListUserRolesParams, len(mmListUserRoles.callArgs))
	copy(argCopy, mmListUserRoles.callArgs)

	mmListUserRoles.mutex.RUnlock()

	return argCopy
}

// MinimockListUserRolesDone returns true if the count of the ListUserRoles invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockListUserRolesDone() bool {
	if m.ListUserRolesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListUserRolesMock.invocationsDone()
}

// MinimockListUserRolesInspect logs each unmet expectation
func (m *CoreMock) MinimockListUserRolesInspect() {
	for _, e := range m.ListUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.ListUserRoles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListUserRolesCounter := mm_atomic.LoadUint64(&m.afterListUserRolesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListUserRolesMock.defaultExpectation != nil && afterListUserRolesCounter < 1 {
		if m.ListUserRolesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.ListUserRoles at\n%s", m.ListUserRolesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.ListUserRoles at\n%s with params: %#v", m.ListUserRolesMock.defaultExpectation.expectationOrigins.origin, *m.ListUserRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUserRoles != nil && afterListUserRolesCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.ListUserRoles at\n%s", m.funcListUserRolesOrigin)
	}

	if !m.ListUserRolesMock.invocationsDone() && afterListUserRolesCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.ListUserRoles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListUserRolesMock.expectedInvocations), m.ListUserRolesMock.expectedInvocationsOrigin, afterListUserRolesCounter)
	}
}

type mCoreMockRefreshTokens struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockRefreshTokensExpectation
	expectations       []*CoreMockRefreshTokensExpectation

	callArgs []*CoreMockRefreshTokensParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockRefreshTokensExpectation specifies expectation struct of the Core.RefreshTokens
type CoreMockRefreshTokensExpectation struct {
	mock               *CoreMock
	params             *CoreMockRefreshTokensParams
	paramPtrs          *CoreMockRefreshTokensParamPtrs
	expectationOrigins CoreMockRefreshTokensExpectationOrigins
	results            *CoreMockRefreshTokensResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockRefreshTokensParams contains parameters of the Core.RefreshTokens
type CoreMockRefreshTokensParams struct {
	ctx          context.Context
	session      auth.Session
	refreshToken string
	rtHash       string
}

// CoreMockRefreshTokensParamPtrs contains pointers to parameters of the Core.RefreshTokens
type CoreMockRefreshTokensParamPtrs struct {
	ctx          *context.Context
	session      *auth.Session
	refreshToken *string
	rtHash       *string
}

// CoreMockRefreshTokensResults contains results of the Core.RefreshTokens
type CoreMockRefreshTokensResults struct {
	t1  auth.Tokens
	err error
}

// CoreMockRefreshTokensOrigins contains origins of expectations of the Core.RefreshTokens
type CoreMockRefreshTokensExpectationOrigins struct {
	origin             string
	originCtx          string
	originSession      string
	originRefreshToken string
	originRtHash       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshTokens *mCoreMockRefreshTokens) Optional() *mCoreMockRefreshTokens {
	mmRefreshTokens.optional = true
	return mmRefreshTokens
}

// Expect sets up expected params for Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) Expect(ctx context.Context, session auth.Session, refreshToken string, rtHash string) *mCoreMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &CoreMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by ExpectParams functions")
	}

	mmRefreshTokens.defaultExpectation.params = &CoreMockRefreshTokensParams{ctx, session, refreshToken, rtHash}
	mmRefreshTokens.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefreshTokens.expectations {
		if minimock.Equal(e.params, mmRefreshTokens.defaultExpectation.params) {
			mmRefreshTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefreshTokens.defaultExpectation.params)
		}
	}

	return mmRefreshTokens
}

// ExpectCtxParam1 sets up expected param ctx for Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) ExpectCtxParam1(ctx context.Context) *mCoreMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &CoreMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.params != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Expect")
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs == nil {
		mmRefreshTokens.defaultExpectation.paramPtrs = &CoreMockRefreshTokensParamPtrs{}
	}
	mmRefreshTokens.defaultExpectation.paramPtrs.ctx = &ctx
	mmRefreshTokens.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRefreshTokens
}

// ExpectSessionParam2 sets up expected param session for Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) ExpectSessionParam2(session auth.Session) *mCoreMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &CoreMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.params != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Expect")
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs == nil {
		mmRefreshTokens.defaultExpectation.paramPtrs = &CoreMockRefreshTokensParamPtrs{}
	}
	mmRefreshTokens.defaultExpectation.paramPtrs.session = &session
	mmRefreshTokens.defaultExpectation.expectationOrigins.originSession = minimock.CallerInfo(1)

	return mmRefreshTokens
}

// ExpectRefreshTokenParam3 sets up expected param refreshToken for Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) ExpectRefreshTokenParam3(refreshToken string) *mCoreMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &CoreMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.params != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Expect")
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs == nil {
		mmRefreshTokens.defaultExpectation.paramPtrs = &CoreMockRefreshTokensParamPtrs{}
	}
	mmRefreshTokens.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmRefreshTokens.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmRefreshTokens
}

// ExpectRtHashParam4 sets up expected param rtHash for Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) ExpectRtHashParam4(rtHash string) *mCoreMockRefreshTokens {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &CoreMockRefreshTokensExpectation{}
	}

	if mmRefreshTokens.defaultExpectation.params != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Expect")
	}

	if mmRefreshTokens.defaultExpectation.paramPtrs == nil {
		mmRefreshTokens.defaultExpectation.paramPtrs = &CoreMockRefreshTokensParamPtrs{}
	}
	mmRefreshTokens.defaultExpectation.paramPtrs.rtHash = &rtHash
	mmRefreshTokens.defaultExpectation.expectationOrigins.originRtHash = minimock.CallerInfo(1)

	return mmRefreshTokens
}

// Inspect accepts an inspector function that has same arguments as the Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) Inspect(f func(ctx context.Context, session auth.Session, refreshToken string, rtHash string)) *mCoreMockRefreshTokens {
	if mmRefreshTokens.mock.inspectFuncRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("Inspect function is already set for CoreMock.RefreshTokens")
	}

	mmRefreshTokens.mock.inspectFuncRefreshTokens = f

	return mmRefreshTokens
}

// Return sets up results that will be returned by Core.RefreshTokens
func (mmRefreshTokens *mCoreMockRefreshTokens) Return(t1 auth.Tokens, err error) *CoreMock {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	if mmRefreshTokens.defaultExpectation == nil {
		mmRefreshTokens.defaultExpectation = &CoreMockRefreshTokensExpectation{mock: mmRefreshTokens.mock}
	}
	mmRefreshTokens.defaultExpectation.results = &CoreMockRefreshTokensResults{t1, err}
	mmRefreshTokens.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefreshTokens.mock
}

// Set uses given function f to mock the Core.RefreshTokens method
func (mmRefreshTokens *mCoreMockRefreshTokens) Set(f func(ctx context.Context, session auth.Session, refreshToken string, rtHash string) (t1 auth.Tokens, err error)) *CoreMock {
	if mmRefreshTokens.defaultExpectation != nil {
		mmRefreshTokens.mock.t.Fatalf("Default expectation is already set for the Core.RefreshTokens method")
	}

	if len(mmRefreshTokens.expectations) > 0 {
		mmRefreshTokens.mock.t.Fatalf("Some expectations are already set for the Core.RefreshTokens method")
	}

	mmRefreshTokens.mock.funcRefreshTokens = f
	mmRefreshTokens.mock.funcRefreshTokensOrigin = minimock.CallerInfo(1)
	return mmRefreshTokens.mock
}

// When sets expectation for the Core.RefreshTokens which will trigger the result defined by the following
// Then helper
func (mmRefreshTokens *mCoreMockRefreshTokens) When(ctx context.Context, session auth.Session, refreshToken string, rtHash string) *CoreMockRefreshTokensExpectation {
	if mmRefreshTokens.mock.funcRefreshTokens != nil {
		mmRefreshTokens.mock.t.Fatalf("CoreMock.RefreshTokens mock is already set by Set")
	}

	expectation := &CoreMockRefreshTokensExpectation{
		mock:               mmRefreshTokens.mock,
		params:             &CoreMockRefreshTokensParams{ctx, session, refreshToken, rtHash},
		expectationOrigins: CoreMockRefreshTokensExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefreshTokens.expectations = append(mmRefreshTokens.expectations, expectation)
	return expectation
}

// Then sets up Core.RefreshTokens return parameters for the expectation previously defined by the When method
func (e *CoreMockRefreshTokensExpectation) Then(t1 auth.Tokens, err error) *CoreMock {
	e.results = &CoreMockRefreshTokensResults{t1, err}
	return e.mock
}

// Times sets number of times Core.RefreshTokens should be invoked
func (mmRefreshTokens *mCoreMockRefreshTokens) Times(n uint64) *mCoreMockRefreshTokens {
	if n == 0 {
		mmRefreshTokens.mock.t.Fatalf("Times of CoreMock.RefreshTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshTokens.expectedInvocations, n)
	mmRefreshTokens.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefreshTokens
}

func (mmRefreshTokens *mCoreMockRefreshTokens) invocationsDone() bool {
	if len(mmRefreshTokens.expectations) == 0 && mmRefreshTokens.defaultExpectation == nil && mmRefreshTokens.mock.funcRefreshTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshTokens.mock.afterRefreshTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshTokens implements mm_usecase.Core
func (mmRefreshTokens *CoreMock) RefreshTokens(ctx context.Context, session auth.Session, refreshToken string, rtHash string) (t1 auth.Tokens, err error) {
	mm_atomic.AddUint64(&mmRefreshTokens.beforeRefreshTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshTokens.afterRefreshTokensCounter, 1)

	mmRefreshTokens.t.Helper()

	if mmRefreshTokens.inspectFuncRefreshTokens != nil {
		mmRefreshTokens.inspectFuncRefreshTokens(ctx, session, refreshToken, rtHash)
	}

	mm_params := CoreMockRefreshTokensParams{ctx, session, refreshToken, rtHash}

	// Record call args
	mmRefreshTokens.RefreshTokensMock.mutex.Lock()
	mmRefreshTokens.RefreshTokensMock.callArgs = append(mmRefreshTokens.RefreshTokensMock.callArgs, &mm_params)
	mmRefreshTokens.RefreshTokensMock.mutex.Unlock()

	for _, e := range mmRefreshTokens.RefreshTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmRefreshTokens.RefreshTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshTokens.RefreshTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmRefreshTokens.RefreshTokensMock.defaultExpectation.params
		mm_want_ptrs := mmRefreshTokens.RefreshTokensMock.defaultExpectation.paramPtrs

		mm_got := CoreMockRefreshTokensParams{ctx, session, refreshToken, rtHash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRefreshTokens.t.Errorf("CoreMock.RefreshTokens got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.session != nil && !minimock.Equal(*mm_want_ptrs.session, mm_got.session) {
				mmRefreshTokens.t.Errorf("CoreMock.RefreshTokens got unexpected parameter session, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.originSession, *mm_want_ptrs.session, mm_got.session, minimock.Diff(*mm_want_ptrs.session, mm_got.session))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmRefreshTokens.t.Errorf("CoreMock.RefreshTokens got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

			if mm_want_ptrs.rtHash != nil && !minimock.Equal(*mm_want_ptrs.rtHash, mm_got.rtHash) {
				mmRefreshTokens.t.Errorf("CoreMock.RefreshTokens got unexpected parameter rtHash, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.originRtHash, *mm_want_ptrs.rtHash, mm_got.rtHash, minimock.Diff(*mm_want_ptrs.rtHash, mm_got.rtHash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefreshTokens.t.Errorf("CoreMock.RefreshTokens got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefreshTokens.RefreshTokensMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefreshTokens.RefreshTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshTokens.t.Fatal("No results are set for the CoreMock.RefreshTokens")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmRefreshTokens.funcRefreshTokens != nil {
		return mmRefreshTokens.funcRefreshTokens(ctx, session, refreshToken, rtHash)
	}
	mmRefreshTokens.t.Fatalf("Unexpected call to CoreMock.RefreshTokens. %v %v %v %v", ctx, session, refreshToken, rtHash)
	return
}

// RefreshTokensAfterCounter returns a count of finished CoreMock.RefreshTokens invocations
func (mmRefreshTokens *CoreMock) RefreshTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokens.afterRefreshTokensCounter)
}

// RefreshTokensBeforeCounter returns a count of CoreMock.RefreshTokens invocations
func (mmRefreshTokens *CoreMock) RefreshTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokens.beforeRefreshTokensCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.RefreshTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefreshTokens *mCoreMockRefreshTokens) Calls() []*CoreMockRefreshTokensParams {
	mmRefreshTokens.mutex.RLock()

	argCopy := make([]*CoreMockRefreshTokensParams, len(mmRefreshTokens.callArgs))
	copy(argCopy, mmRefreshTokens.callArgs)

	mmRefreshTokens.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshTokensDone returns true if the count of the RefreshTokens invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockRefreshTokensDone() bool {
	if m.RefreshTokensMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTokensMock.invocationsDone()
}

// MinimockRefreshTokensInspect logs each unmet expectation
func (m *CoreMock) MinimockRefreshTokensInspect() {
	for _, e := range m.RefreshTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.RefreshTokens at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefreshTokensCounter := mm_atomic.LoadUint64(&m.afterRefreshTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokensMock.defaultExpectation != nil && afterRefreshTokensCounter < 1 {
		if m.RefreshTokensMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.RefreshTokens at\n%s", m.RefreshTokensMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.RefreshTokens at\n%s with params: %#v", m.RefreshTokensMock.defaultExpectation.expectationOrigins.origin, *m.RefreshTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshTokens != nil && afterRefreshTokensCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.RefreshTokens at\n%s", m.funcRefreshTokensOrigin)
	}

	if !m.RefreshTokensMock.invocationsDone() && afterRefreshTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.RefreshTokens at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTokensMock.expectedInvocations), m.RefreshTokensMock.expectedInvocationsOrigin, afterRefreshTokensCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CoreMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUserRoleInspect()

			m.MinimockCheckIsAdminInspect()

			m.MinimockCheckSelfOrAdminInspect()

			m.MinimockDeleteSessionInspect()

			m.MinimockDeleteSessionsByUserIDInspect()

			m.MinimockDeleteUserRoleInspect()

			m.MinimockGetSessionByIDInspect()

			m.MinimockGetSessionsByUserIDInspect()

			m.MinimockIsAdminInspect()

			m.MinimockIssueTokensInspect()

			m.MinimockListUserRolesInspect()

			m.MinimockRefreshTokensInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUserRoleDone() &&
		m.MinimockCheckIsAdminDone() &&
		m.MinimockCheckSelfOrAdminDone() &&
		m.MinimockDeleteSessionDone() &&
		m.MinimockDeleteSessionsByUserIDDone() &&
		m.MinimockDeleteUserRoleDone() &&
		m.MinimockGetSessionByIDDone() &&
		m.MinimockGetSessionsByUserIDDone() &&
		m.MinimockIsAdminDone() &&
		m.MinimockIssueTokensDone() &&
		m.MinimockListUserRolesDone() &&
		m.MinimockRefreshTokensDone()
}
