// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/auth.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_auth "github.com/66gu1/easygodocs/internal/app/auth"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// RepositoryMock implements mm_auth.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUserRole          func(ctx context.Context, role mm_auth.UserRole) (err error)
	funcAddUserRoleOrigin    string
	inspectFuncAddUserRole   func(ctx context.Context, role mm_auth.UserRole)
	afterAddUserRoleCounter  uint64
	beforeAddUserRoleCounter uint64
	AddUserRoleMock          mRepositoryMockAddUserRole

	funcCreateSession          func(ctx context.Context, req mm_auth.Session, rtHash string) (err error)
	funcCreateSessionOrigin    string
	inspectFuncCreateSession   func(ctx context.Context, req mm_auth.Session, rtHash string)
	afterCreateSessionCounter  uint64
	beforeCreateSessionCounter uint64
	CreateSessionMock          mRepositoryMockCreateSession

	funcDeleteSessionByID          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteSessionByIDOrigin    string
	inspectFuncDeleteSessionByID   func(ctx context.Context, id uuid.UUID)
	afterDeleteSessionByIDCounter  uint64
	beforeDeleteSessionByIDCounter uint64
	DeleteSessionByIDMock          mRepositoryMockDeleteSessionByID

	funcDeleteSessionByIDAndUser          func(ctx context.Context, id uuid.UUID, userID uuid.UUID) (err error)
	funcDeleteSessionByIDAndUserOrigin    string
	inspectFuncDeleteSessionByIDAndUser   func(ctx context.Context, id uuid.UUID, userID uuid.UUID)
	afterDeleteSessionByIDAndUserCounter  uint64
	beforeDeleteSessionByIDAndUserCounter uint64
	DeleteSessionByIDAndUserMock          mRepositoryMockDeleteSessionByIDAndUser

	funcDeleteSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (err error)
	funcDeleteSessionsByUserIDOrigin    string
	inspectFuncDeleteSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterDeleteSessionsByUserIDCounter  uint64
	beforeDeleteSessionsByUserIDCounter uint64
	DeleteSessionsByUserIDMock          mRepositoryMockDeleteSessionsByUserID

	funcDeleteUserRole          func(ctx context.Context, role mm_auth.UserRole) (err error)
	funcDeleteUserRoleOrigin    string
	inspectFuncDeleteUserRole   func(ctx context.Context, role mm_auth.UserRole)
	afterDeleteUserRoleCounter  uint64
	beforeDeleteUserRoleCounter uint64
	DeleteUserRoleMock          mRepositoryMockDeleteUserRole

	funcGetSessionByID          func(ctx context.Context, id uuid.UUID) (s1 mm_auth.Session, s2 string, err error)
	funcGetSessionByIDOrigin    string
	inspectFuncGetSessionByID   func(ctx context.Context, id uuid.UUID)
	afterGetSessionByIDCounter  uint64
	beforeGetSessionByIDCounter uint64
	GetSessionByIDMock          mRepositoryMockGetSessionByID

	funcGetSessionsByUserID          func(ctx context.Context, userID uuid.UUID) (sa1 []mm_auth.Session, err error)
	funcGetSessionsByUserIDOrigin    string
	inspectFuncGetSessionsByUserID   func(ctx context.Context, userID uuid.UUID)
	afterGetSessionsByUserIDCounter  uint64
	beforeGetSessionsByUserIDCounter uint64
	GetSessionsByUserIDMock          mRepositoryMockGetSessionsByUserID

	funcGetUserRoles          func(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role) (ua1 []mm_auth.UserRole, err error)
	funcGetUserRolesOrigin    string
	inspectFuncGetUserRoles   func(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role)
	afterGetUserRolesCounter  uint64
	beforeGetUserRolesCounter uint64
	GetUserRolesMock          mRepositoryMockGetUserRoles

	funcListUserRoles          func(ctx context.Context, userID uuid.UUID) (ua1 []mm_auth.UserRole, err error)
	funcListUserRolesOrigin    string
	inspectFuncListUserRoles   func(ctx context.Context, userID uuid.UUID)
	afterListUserRolesCounter  uint64
	beforeListUserRolesCounter uint64
	ListUserRolesMock          mRepositoryMockListUserRoles

	funcUpdateRefreshToken          func(ctx context.Context, req mm_auth.UpdateTokenReq) (err error)
	funcUpdateRefreshTokenOrigin    string
	inspectFuncUpdateRefreshToken   func(ctx context.Context, req mm_auth.UpdateTokenReq)
	afterUpdateRefreshTokenCounter  uint64
	beforeUpdateRefreshTokenCounter uint64
	UpdateRefreshTokenMock          mRepositoryMockUpdateRefreshToken
}

// NewRepositoryMock returns a mock for mm_auth.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUserRoleMock = mRepositoryMockAddUserRole{mock: m}
	m.AddUserRoleMock.callArgs = []*RepositoryMockAddUserRoleParams{}

	m.CreateSessionMock = mRepositoryMockCreateSession{mock: m}
	m.CreateSessionMock.callArgs = []*RepositoryMockCreateSessionParams{}

	m.DeleteSessionByIDMock = mRepositoryMockDeleteSessionByID{mock: m}
	m.DeleteSessionByIDMock.callArgs = []*RepositoryMockDeleteSessionByIDParams{}

	m.DeleteSessionByIDAndUserMock = mRepositoryMockDeleteSessionByIDAndUser{mock: m}
	m.DeleteSessionByIDAndUserMock.callArgs = []*RepositoryMockDeleteSessionByIDAndUserParams{}

	m.DeleteSessionsByUserIDMock = mRepositoryMockDeleteSessionsByUserID{mock: m}
	m.DeleteSessionsByUserIDMock.callArgs = []*RepositoryMockDeleteSessionsByUserIDParams{}

	m.DeleteUserRoleMock = mRepositoryMockDeleteUserRole{mock: m}
	m.DeleteUserRoleMock.callArgs = []*RepositoryMockDeleteUserRoleParams{}

	m.GetSessionByIDMock = mRepositoryMockGetSessionByID{mock: m}
	m.GetSessionByIDMock.callArgs = []*RepositoryMockGetSessionByIDParams{}

	m.GetSessionsByUserIDMock = mRepositoryMockGetSessionsByUserID{mock: m}
	m.GetSessionsByUserIDMock.callArgs = []*RepositoryMockGetSessionsByUserIDParams{}

	m.GetUserRolesMock = mRepositoryMockGetUserRoles{mock: m}
	m.GetUserRolesMock.callArgs = []*RepositoryMockGetUserRolesParams{}

	m.ListUserRolesMock = mRepositoryMockListUserRoles{mock: m}
	m.ListUserRolesMock.callArgs = []*RepositoryMockListUserRolesParams{}

	m.UpdateRefreshTokenMock = mRepositoryMockUpdateRefreshToken{mock: m}
	m.UpdateRefreshTokenMock.callArgs = []*RepositoryMockUpdateRefreshTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddUserRole struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddUserRoleExpectation
	expectations       []*RepositoryMockAddUserRoleExpectation

	callArgs []*RepositoryMockAddUserRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddUserRoleExpectation specifies expectation struct of the Repository.AddUserRole
type RepositoryMockAddUserRoleExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddUserRoleParams
	paramPtrs          *RepositoryMockAddUserRoleParamPtrs
	expectationOrigins RepositoryMockAddUserRoleExpectationOrigins
	results            *RepositoryMockAddUserRoleResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddUserRoleParams contains parameters of the Repository.AddUserRole
type RepositoryMockAddUserRoleParams struct {
	ctx  context.Context
	role mm_auth.UserRole
}

// RepositoryMockAddUserRoleParamPtrs contains pointers to parameters of the Repository.AddUserRole
type RepositoryMockAddUserRoleParamPtrs struct {
	ctx  *context.Context
	role *mm_auth.UserRole
}

// RepositoryMockAddUserRoleResults contains results of the Repository.AddUserRole
type RepositoryMockAddUserRoleResults struct {
	err error
}

// RepositoryMockAddUserRoleOrigins contains origins of expectations of the Repository.AddUserRole
type RepositoryMockAddUserRoleExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUserRole *mRepositoryMockAddUserRole) Optional() *mRepositoryMockAddUserRole {
	mmAddUserRole.optional = true
	return mmAddUserRole
}

// Expect sets up expected params for Repository.AddUserRole
func (mmAddUserRole *mRepositoryMockAddUserRole) Expect(ctx context.Context, role mm_auth.UserRole) *mRepositoryMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &RepositoryMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.paramPtrs != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by ExpectParams functions")
	}

	mmAddUserRole.defaultExpectation.params = &RepositoryMockAddUserRoleParams{ctx, role}
	mmAddUserRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUserRole.expectations {
		if minimock.Equal(e.params, mmAddUserRole.defaultExpectation.params) {
			mmAddUserRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUserRole.defaultExpectation.params)
		}
	}

	return mmAddUserRole
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddUserRole
func (mmAddUserRole *mRepositoryMockAddUserRole) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &RepositoryMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.params != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Expect")
	}

	if mmAddUserRole.defaultExpectation.paramPtrs == nil {
		mmAddUserRole.defaultExpectation.paramPtrs = &RepositoryMockAddUserRoleParamPtrs{}
	}
	mmAddUserRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddUserRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddUserRole
}

// ExpectRoleParam2 sets up expected param role for Repository.AddUserRole
func (mmAddUserRole *mRepositoryMockAddUserRole) ExpectRoleParam2(role mm_auth.UserRole) *mRepositoryMockAddUserRole {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &RepositoryMockAddUserRoleExpectation{}
	}

	if mmAddUserRole.defaultExpectation.params != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Expect")
	}

	if mmAddUserRole.defaultExpectation.paramPtrs == nil {
		mmAddUserRole.defaultExpectation.paramPtrs = &RepositoryMockAddUserRoleParamPtrs{}
	}
	mmAddUserRole.defaultExpectation.paramPtrs.role = &role
	mmAddUserRole.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmAddUserRole
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddUserRole
func (mmAddUserRole *mRepositoryMockAddUserRole) Inspect(f func(ctx context.Context, role mm_auth.UserRole)) *mRepositoryMockAddUserRole {
	if mmAddUserRole.mock.inspectFuncAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddUserRole")
	}

	mmAddUserRole.mock.inspectFuncAddUserRole = f

	return mmAddUserRole
}

// Return sets up results that will be returned by Repository.AddUserRole
func (mmAddUserRole *mRepositoryMockAddUserRole) Return(err error) *RepositoryMock {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Set")
	}

	if mmAddUserRole.defaultExpectation == nil {
		mmAddUserRole.defaultExpectation = &RepositoryMockAddUserRoleExpectation{mock: mmAddUserRole.mock}
	}
	mmAddUserRole.defaultExpectation.results = &RepositoryMockAddUserRoleResults{err}
	mmAddUserRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUserRole.mock
}

// Set uses given function f to mock the Repository.AddUserRole method
func (mmAddUserRole *mRepositoryMockAddUserRole) Set(f func(ctx context.Context, role mm_auth.UserRole) (err error)) *RepositoryMock {
	if mmAddUserRole.defaultExpectation != nil {
		mmAddUserRole.mock.t.Fatalf("Default expectation is already set for the Repository.AddUserRole method")
	}

	if len(mmAddUserRole.expectations) > 0 {
		mmAddUserRole.mock.t.Fatalf("Some expectations are already set for the Repository.AddUserRole method")
	}

	mmAddUserRole.mock.funcAddUserRole = f
	mmAddUserRole.mock.funcAddUserRoleOrigin = minimock.CallerInfo(1)
	return mmAddUserRole.mock
}

// When sets expectation for the Repository.AddUserRole which will trigger the result defined by the following
// Then helper
func (mmAddUserRole *mRepositoryMockAddUserRole) When(ctx context.Context, role mm_auth.UserRole) *RepositoryMockAddUserRoleExpectation {
	if mmAddUserRole.mock.funcAddUserRole != nil {
		mmAddUserRole.mock.t.Fatalf("RepositoryMock.AddUserRole mock is already set by Set")
	}

	expectation := &RepositoryMockAddUserRoleExpectation{
		mock:               mmAddUserRole.mock,
		params:             &RepositoryMockAddUserRoleParams{ctx, role},
		expectationOrigins: RepositoryMockAddUserRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddUserRole.expectations = append(mmAddUserRole.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddUserRole return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddUserRoleExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddUserRoleResults{err}
	return e.mock
}

// Times sets number of times Repository.AddUserRole should be invoked
func (mmAddUserRole *mRepositoryMockAddUserRole) Times(n uint64) *mRepositoryMockAddUserRole {
	if n == 0 {
		mmAddUserRole.mock.t.Fatalf("Times of RepositoryMock.AddUserRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUserRole.expectedInvocations, n)
	mmAddUserRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUserRole
}

func (mmAddUserRole *mRepositoryMockAddUserRole) invocationsDone() bool {
	if len(mmAddUserRole.expectations) == 0 && mmAddUserRole.defaultExpectation == nil && mmAddUserRole.mock.funcAddUserRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUserRole.mock.afterAddUserRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUserRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUserRole implements mm_auth.Repository
func (mmAddUserRole *RepositoryMock) AddUserRole(ctx context.Context, role mm_auth.UserRole) (err error) {
	mm_atomic.AddUint64(&mmAddUserRole.beforeAddUserRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUserRole.afterAddUserRoleCounter, 1)

	mmAddUserRole.t.Helper()

	if mmAddUserRole.inspectFuncAddUserRole != nil {
		mmAddUserRole.inspectFuncAddUserRole(ctx, role)
	}

	mm_params := RepositoryMockAddUserRoleParams{ctx, role}

	// Record call args
	mmAddUserRole.AddUserRoleMock.mutex.Lock()
	mmAddUserRole.AddUserRoleMock.callArgs = append(mmAddUserRole.AddUserRoleMock.callArgs, &mm_params)
	mmAddUserRole.AddUserRoleMock.mutex.Unlock()

	for _, e := range mmAddUserRole.AddUserRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUserRole.AddUserRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUserRole.AddUserRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUserRole.AddUserRoleMock.defaultExpectation.params
		mm_want_ptrs := mmAddUserRole.AddUserRoleMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddUserRoleParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUserRole.t.Errorf("RepositoryMock.AddUserRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmAddUserRole.t.Errorf("RepositoryMock.AddUserRole got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUserRole.t.Errorf("RepositoryMock.AddUserRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUserRole.AddUserRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUserRole.AddUserRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUserRole.t.Fatal("No results are set for the RepositoryMock.AddUserRole")
		}
		return (*mm_results).err
	}
	if mmAddUserRole.funcAddUserRole != nil {
		return mmAddUserRole.funcAddUserRole(ctx, role)
	}
	mmAddUserRole.t.Fatalf("Unexpected call to RepositoryMock.AddUserRole. %v %v", ctx, role)
	return
}

// AddUserRoleAfterCounter returns a count of finished RepositoryMock.AddUserRole invocations
func (mmAddUserRole *RepositoryMock) AddUserRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUserRole.afterAddUserRoleCounter)
}

// AddUserRoleBeforeCounter returns a count of RepositoryMock.AddUserRole invocations
func (mmAddUserRole *RepositoryMock) AddUserRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUserRole.beforeAddUserRoleCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddUserRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUserRole *mRepositoryMockAddUserRole) Calls() []*RepositoryMockAddUserRoleParams {
	mmAddUserRole.mutex.RLock()

	argCopy := make([]*RepositoryMockAddUserRoleParams, len(mmAddUserRole.callArgs))
	copy(argCopy, mmAddUserRole.callArgs)

	mmAddUserRole.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserRoleDone returns true if the count of the AddUserRole invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddUserRoleDone() bool {
	if m.AddUserRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUserRoleMock.invocationsDone()
}

// MinimockAddUserRoleInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddUserRoleInspect() {
	for _, e := range m.AddUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddUserRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUserRoleCounter := mm_atomic.LoadUint64(&m.afterAddUserRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserRoleMock.defaultExpectation != nil && afterAddUserRoleCounter < 1 {
		if m.AddUserRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddUserRole at\n%s", m.AddUserRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddUserRole at\n%s with params: %#v", m.AddUserRoleMock.defaultExpectation.expectationOrigins.origin, *m.AddUserRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUserRole != nil && afterAddUserRoleCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddUserRole at\n%s", m.funcAddUserRoleOrigin)
	}

	if !m.AddUserRoleMock.invocationsDone() && afterAddUserRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddUserRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUserRoleMock.expectedInvocations), m.AddUserRoleMock.expectedInvocationsOrigin, afterAddUserRoleCounter)
	}
}

type mRepositoryMockCreateSession struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSessionExpectation
	expectations       []*RepositoryMockCreateSessionExpectation

	callArgs []*RepositoryMockCreateSessionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateSessionExpectation specifies expectation struct of the Repository.CreateSession
type RepositoryMockCreateSessionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateSessionParams
	paramPtrs          *RepositoryMockCreateSessionParamPtrs
	expectationOrigins RepositoryMockCreateSessionExpectationOrigins
	results            *RepositoryMockCreateSessionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateSessionParams contains parameters of the Repository.CreateSession
type RepositoryMockCreateSessionParams struct {
	ctx    context.Context
	req    mm_auth.Session
	rtHash string
}

// RepositoryMockCreateSessionParamPtrs contains pointers to parameters of the Repository.CreateSession
type RepositoryMockCreateSessionParamPtrs struct {
	ctx    *context.Context
	req    *mm_auth.Session
	rtHash *string
}

// RepositoryMockCreateSessionResults contains results of the Repository.CreateSession
type RepositoryMockCreateSessionResults struct {
	err error
}

// RepositoryMockCreateSessionOrigins contains origins of expectations of the Repository.CreateSession
type RepositoryMockCreateSessionExpectationOrigins struct {
	origin       string
	originCtx    string
	originReq    string
	originRtHash string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateSession *mRepositoryMockCreateSession) Optional() *mRepositoryMockCreateSession {
	mmCreateSession.optional = true
	return mmCreateSession
}

// Expect sets up expected params for Repository.CreateSession
func (mmCreateSession *mRepositoryMockCreateSession) Expect(ctx context.Context, req mm_auth.Session, rtHash string) *mRepositoryMockCreateSession {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &RepositoryMockCreateSessionExpectation{}
	}

	if mmCreateSession.defaultExpectation.paramPtrs != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by ExpectParams functions")
	}

	mmCreateSession.defaultExpectation.params = &RepositoryMockCreateSessionParams{ctx, req, rtHash}
	mmCreateSession.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateSession.expectations {
		if minimock.Equal(e.params, mmCreateSession.defaultExpectation.params) {
			mmCreateSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSession.defaultExpectation.params)
		}
	}

	return mmCreateSession
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateSession
func (mmCreateSession *mRepositoryMockCreateSession) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateSession {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &RepositoryMockCreateSessionExpectation{}
	}

	if mmCreateSession.defaultExpectation.params != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Expect")
	}

	if mmCreateSession.defaultExpectation.paramPtrs == nil {
		mmCreateSession.defaultExpectation.paramPtrs = &RepositoryMockCreateSessionParamPtrs{}
	}
	mmCreateSession.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateSession.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateSession
}

// ExpectReqParam2 sets up expected param req for Repository.CreateSession
func (mmCreateSession *mRepositoryMockCreateSession) ExpectReqParam2(req mm_auth.Session) *mRepositoryMockCreateSession {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &RepositoryMockCreateSessionExpectation{}
	}

	if mmCreateSession.defaultExpectation.params != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Expect")
	}

	if mmCreateSession.defaultExpectation.paramPtrs == nil {
		mmCreateSession.defaultExpectation.paramPtrs = &RepositoryMockCreateSessionParamPtrs{}
	}
	mmCreateSession.defaultExpectation.paramPtrs.req = &req
	mmCreateSession.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateSession
}

// ExpectRtHashParam3 sets up expected param rtHash for Repository.CreateSession
func (mmCreateSession *mRepositoryMockCreateSession) ExpectRtHashParam3(rtHash string) *mRepositoryMockCreateSession {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &RepositoryMockCreateSessionExpectation{}
	}

	if mmCreateSession.defaultExpectation.params != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Expect")
	}

	if mmCreateSession.defaultExpectation.paramPtrs == nil {
		mmCreateSession.defaultExpectation.paramPtrs = &RepositoryMockCreateSessionParamPtrs{}
	}
	mmCreateSession.defaultExpectation.paramPtrs.rtHash = &rtHash
	mmCreateSession.defaultExpectation.expectationOrigins.originRtHash = minimock.CallerInfo(1)

	return mmCreateSession
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSession
func (mmCreateSession *mRepositoryMockCreateSession) Inspect(f func(ctx context.Context, req mm_auth.Session, rtHash string)) *mRepositoryMockCreateSession {
	if mmCreateSession.mock.inspectFuncCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSession")
	}

	mmCreateSession.mock.inspectFuncCreateSession = f

	return mmCreateSession
}

// Return sets up results that will be returned by Repository.CreateSession
func (mmCreateSession *mRepositoryMockCreateSession) Return(err error) *RepositoryMock {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Set")
	}

	if mmCreateSession.defaultExpectation == nil {
		mmCreateSession.defaultExpectation = &RepositoryMockCreateSessionExpectation{mock: mmCreateSession.mock}
	}
	mmCreateSession.defaultExpectation.results = &RepositoryMockCreateSessionResults{err}
	mmCreateSession.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateSession.mock
}

// Set uses given function f to mock the Repository.CreateSession method
func (mmCreateSession *mRepositoryMockCreateSession) Set(f func(ctx context.Context, req mm_auth.Session, rtHash string) (err error)) *RepositoryMock {
	if mmCreateSession.defaultExpectation != nil {
		mmCreateSession.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSession method")
	}

	if len(mmCreateSession.expectations) > 0 {
		mmCreateSession.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSession method")
	}

	mmCreateSession.mock.funcCreateSession = f
	mmCreateSession.mock.funcCreateSessionOrigin = minimock.CallerInfo(1)
	return mmCreateSession.mock
}

// When sets expectation for the Repository.CreateSession which will trigger the result defined by the following
// Then helper
func (mmCreateSession *mRepositoryMockCreateSession) When(ctx context.Context, req mm_auth.Session, rtHash string) *RepositoryMockCreateSessionExpectation {
	if mmCreateSession.mock.funcCreateSession != nil {
		mmCreateSession.mock.t.Fatalf("RepositoryMock.CreateSession mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSessionExpectation{
		mock:               mmCreateSession.mock,
		params:             &RepositoryMockCreateSessionParams{ctx, req, rtHash},
		expectationOrigins: RepositoryMockCreateSessionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateSession.expectations = append(mmCreateSession.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSession return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSessionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSessionResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateSession should be invoked
func (mmCreateSession *mRepositoryMockCreateSession) Times(n uint64) *mRepositoryMockCreateSession {
	if n == 0 {
		mmCreateSession.mock.t.Fatalf("Times of RepositoryMock.CreateSession mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateSession.expectedInvocations, n)
	mmCreateSession.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateSession
}

func (mmCreateSession *mRepositoryMockCreateSession) invocationsDone() bool {
	if len(mmCreateSession.expectations) == 0 && mmCreateSession.defaultExpectation == nil && mmCreateSession.mock.funcCreateSession == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateSession.mock.afterCreateSessionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateSession.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateSession implements mm_auth.Repository
func (mmCreateSession *RepositoryMock) CreateSession(ctx context.Context, req mm_auth.Session, rtHash string) (err error) {
	mm_atomic.AddUint64(&mmCreateSession.beforeCreateSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSession.afterCreateSessionCounter, 1)

	mmCreateSession.t.Helper()

	if mmCreateSession.inspectFuncCreateSession != nil {
		mmCreateSession.inspectFuncCreateSession(ctx, req, rtHash)
	}

	mm_params := RepositoryMockCreateSessionParams{ctx, req, rtHash}

	// Record call args
	mmCreateSession.CreateSessionMock.mutex.Lock()
	mmCreateSession.CreateSessionMock.callArgs = append(mmCreateSession.CreateSessionMock.callArgs, &mm_params)
	mmCreateSession.CreateSessionMock.mutex.Unlock()

	for _, e := range mmCreateSession.CreateSessionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateSession.CreateSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSession.CreateSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSession.CreateSessionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateSession.CreateSessionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateSessionParams{ctx, req, rtHash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateSession.t.Errorf("RepositoryMock.CreateSession got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSession.CreateSessionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateSession.t.Errorf("RepositoryMock.CreateSession got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSession.CreateSessionMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.rtHash != nil && !minimock.Equal(*mm_want_ptrs.rtHash, mm_got.rtHash) {
				mmCreateSession.t.Errorf("RepositoryMock.CreateSession got unexpected parameter rtHash, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSession.CreateSessionMock.defaultExpectation.expectationOrigins.originRtHash, *mm_want_ptrs.rtHash, mm_got.rtHash, minimock.Diff(*mm_want_ptrs.rtHash, mm_got.rtHash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSession.t.Errorf("RepositoryMock.CreateSession got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateSession.CreateSessionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSession.CreateSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSession.t.Fatal("No results are set for the RepositoryMock.CreateSession")
		}
		return (*mm_results).err
	}
	if mmCreateSession.funcCreateSession != nil {
		return mmCreateSession.funcCreateSession(ctx, req, rtHash)
	}
	mmCreateSession.t.Fatalf("Unexpected call to RepositoryMock.CreateSession. %v %v %v", ctx, req, rtHash)
	return
}

// CreateSessionAfterCounter returns a count of finished RepositoryMock.CreateSession invocations
func (mmCreateSession *RepositoryMock) CreateSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSession.afterCreateSessionCounter)
}

// CreateSessionBeforeCounter returns a count of RepositoryMock.CreateSession invocations
func (mmCreateSession *RepositoryMock) CreateSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSession.beforeCreateSessionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSession *mRepositoryMockCreateSession) Calls() []*RepositoryMockCreateSessionParams {
	mmCreateSession.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSessionParams, len(mmCreateSession.callArgs))
	copy(argCopy, mmCreateSession.callArgs)

	mmCreateSession.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSessionDone returns true if the count of the CreateSession invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSessionDone() bool {
	if m.CreateSessionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateSessionMock.invocationsDone()
}

// MinimockCreateSessionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSessionInspect() {
	for _, e := range m.CreateSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSession at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateSessionCounter := mm_atomic.LoadUint64(&m.afterCreateSessionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSessionMock.defaultExpectation != nil && afterCreateSessionCounter < 1 {
		if m.CreateSessionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateSession at\n%s", m.CreateSessionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSession at\n%s with params: %#v", m.CreateSessionMock.defaultExpectation.expectationOrigins.origin, *m.CreateSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSession != nil && afterCreateSessionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateSession at\n%s", m.funcCreateSessionOrigin)
	}

	if !m.CreateSessionMock.invocationsDone() && afterCreateSessionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateSession at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateSessionMock.expectedInvocations), m.CreateSessionMock.expectedInvocationsOrigin, afterCreateSessionCounter)
	}
}

type mRepositoryMockDeleteSessionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSessionByIDExpectation
	expectations       []*RepositoryMockDeleteSessionByIDExpectation

	callArgs []*RepositoryMockDeleteSessionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteSessionByIDExpectation specifies expectation struct of the Repository.DeleteSessionByID
type RepositoryMockDeleteSessionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteSessionByIDParams
	paramPtrs          *RepositoryMockDeleteSessionByIDParamPtrs
	expectationOrigins RepositoryMockDeleteSessionByIDExpectationOrigins
	results            *RepositoryMockDeleteSessionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteSessionByIDParams contains parameters of the Repository.DeleteSessionByID
type RepositoryMockDeleteSessionByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockDeleteSessionByIDParamPtrs contains pointers to parameters of the Repository.DeleteSessionByID
type RepositoryMockDeleteSessionByIDParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockDeleteSessionByIDResults contains results of the Repository.DeleteSessionByID
type RepositoryMockDeleteSessionByIDResults struct {
	err error
}

// RepositoryMockDeleteSessionByIDOrigins contains origins of expectations of the Repository.DeleteSessionByID
type RepositoryMockDeleteSessionByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Optional() *mRepositoryMockDeleteSessionByID {
	mmDeleteSessionByID.optional = true
	return mmDeleteSessionByID
}

// Expect sets up expected params for Repository.DeleteSessionByID
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockDeleteSessionByID {
	if mmDeleteSessionByID.mock.funcDeleteSessionByID != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Set")
	}

	if mmDeleteSessionByID.defaultExpectation == nil {
		mmDeleteSessionByID.defaultExpectation = &RepositoryMockDeleteSessionByIDExpectation{}
	}

	if mmDeleteSessionByID.defaultExpectation.paramPtrs != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by ExpectParams functions")
	}

	mmDeleteSessionByID.defaultExpectation.params = &RepositoryMockDeleteSessionByIDParams{ctx, id}
	mmDeleteSessionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSessionByID.expectations {
		if minimock.Equal(e.params, mmDeleteSessionByID.defaultExpectation.params) {
			mmDeleteSessionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSessionByID.defaultExpectation.params)
		}
	}

	return mmDeleteSessionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteSessionByID
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteSessionByID {
	if mmDeleteSessionByID.mock.funcDeleteSessionByID != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Set")
	}

	if mmDeleteSessionByID.defaultExpectation == nil {
		mmDeleteSessionByID.defaultExpectation = &RepositoryMockDeleteSessionByIDExpectation{}
	}

	if mmDeleteSessionByID.defaultExpectation.params != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Expect")
	}

	if mmDeleteSessionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionByIDParamPtrs{}
	}
	mmDeleteSessionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSessionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSessionByID
}

// ExpectIdParam2 sets up expected param id for Repository.DeleteSessionByID
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) ExpectIdParam2(id uuid.UUID) *mRepositoryMockDeleteSessionByID {
	if mmDeleteSessionByID.mock.funcDeleteSessionByID != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Set")
	}

	if mmDeleteSessionByID.defaultExpectation == nil {
		mmDeleteSessionByID.defaultExpectation = &RepositoryMockDeleteSessionByIDExpectation{}
	}

	if mmDeleteSessionByID.defaultExpectation.params != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Expect")
	}

	if mmDeleteSessionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionByIDParamPtrs{}
	}
	mmDeleteSessionByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteSessionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteSessionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSessionByID
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockDeleteSessionByID {
	if mmDeleteSessionByID.mock.inspectFuncDeleteSessionByID != nil {
		mmDeleteSessionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSessionByID")
	}

	mmDeleteSessionByID.mock.inspectFuncDeleteSessionByID = f

	return mmDeleteSessionByID
}

// Return sets up results that will be returned by Repository.DeleteSessionByID
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Return(err error) *RepositoryMock {
	if mmDeleteSessionByID.mock.funcDeleteSessionByID != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Set")
	}

	if mmDeleteSessionByID.defaultExpectation == nil {
		mmDeleteSessionByID.defaultExpectation = &RepositoryMockDeleteSessionByIDExpectation{mock: mmDeleteSessionByID.mock}
	}
	mmDeleteSessionByID.defaultExpectation.results = &RepositoryMockDeleteSessionByIDResults{err}
	mmDeleteSessionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionByID.mock
}

// Set uses given function f to mock the Repository.DeleteSessionByID method
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *RepositoryMock {
	if mmDeleteSessionByID.defaultExpectation != nil {
		mmDeleteSessionByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSessionByID method")
	}

	if len(mmDeleteSessionByID.expectations) > 0 {
		mmDeleteSessionByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSessionByID method")
	}

	mmDeleteSessionByID.mock.funcDeleteSessionByID = f
	mmDeleteSessionByID.mock.funcDeleteSessionByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionByID.mock
}

// When sets expectation for the Repository.DeleteSessionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) When(ctx context.Context, id uuid.UUID) *RepositoryMockDeleteSessionByIDExpectation {
	if mmDeleteSessionByID.mock.funcDeleteSessionByID != nil {
		mmDeleteSessionByID.mock.t.Fatalf("RepositoryMock.DeleteSessionByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSessionByIDExpectation{
		mock:               mmDeleteSessionByID.mock,
		params:             &RepositoryMockDeleteSessionByIDParams{ctx, id},
		expectationOrigins: RepositoryMockDeleteSessionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSessionByID.expectations = append(mmDeleteSessionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSessionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSessionByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSessionByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteSessionByID should be invoked
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Times(n uint64) *mRepositoryMockDeleteSessionByID {
	if n == 0 {
		mmDeleteSessionByID.mock.t.Fatalf("Times of RepositoryMock.DeleteSessionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSessionByID.expectedInvocations, n)
	mmDeleteSessionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionByID
}

func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) invocationsDone() bool {
	if len(mmDeleteSessionByID.expectations) == 0 && mmDeleteSessionByID.defaultExpectation == nil && mmDeleteSessionByID.mock.funcDeleteSessionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSessionByID.mock.afterDeleteSessionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSessionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSessionByID implements mm_auth.Repository
func (mmDeleteSessionByID *RepositoryMock) DeleteSessionByID(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSessionByID.beforeDeleteSessionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSessionByID.afterDeleteSessionByIDCounter, 1)

	mmDeleteSessionByID.t.Helper()

	if mmDeleteSessionByID.inspectFuncDeleteSessionByID != nil {
		mmDeleteSessionByID.inspectFuncDeleteSessionByID(ctx, id)
	}

	mm_params := RepositoryMockDeleteSessionByIDParams{ctx, id}

	// Record call args
	mmDeleteSessionByID.DeleteSessionByIDMock.mutex.Lock()
	mmDeleteSessionByID.DeleteSessionByIDMock.callArgs = append(mmDeleteSessionByID.DeleteSessionByIDMock.callArgs, &mm_params)
	mmDeleteSessionByID.DeleteSessionByIDMock.mutex.Unlock()

	for _, e := range mmDeleteSessionByID.DeleteSessionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteSessionByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSessionByID.t.Errorf("RepositoryMock.DeleteSessionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteSessionByID.t.Errorf("RepositoryMock.DeleteSessionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSessionByID.t.Errorf("RepositoryMock.DeleteSessionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSessionByID.DeleteSessionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSessionByID.t.Fatal("No results are set for the RepositoryMock.DeleteSessionByID")
		}
		return (*mm_results).err
	}
	if mmDeleteSessionByID.funcDeleteSessionByID != nil {
		return mmDeleteSessionByID.funcDeleteSessionByID(ctx, id)
	}
	mmDeleteSessionByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteSessionByID. %v %v", ctx, id)
	return
}

// DeleteSessionByIDAfterCounter returns a count of finished RepositoryMock.DeleteSessionByID invocations
func (mmDeleteSessionByID *RepositoryMock) DeleteSessionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionByID.afterDeleteSessionByIDCounter)
}

// DeleteSessionByIDBeforeCounter returns a count of RepositoryMock.DeleteSessionByID invocations
func (mmDeleteSessionByID *RepositoryMock) DeleteSessionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionByID.beforeDeleteSessionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSessionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSessionByID *mRepositoryMockDeleteSessionByID) Calls() []*RepositoryMockDeleteSessionByIDParams {
	mmDeleteSessionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSessionByIDParams, len(mmDeleteSessionByID.callArgs))
	copy(argCopy, mmDeleteSessionByID.callArgs)

	mmDeleteSessionByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionByIDDone returns true if the count of the DeleteSessionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSessionByIDDone() bool {
	if m.DeleteSessionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionByIDMock.invocationsDone()
}

// MinimockDeleteSessionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSessionByIDInspect() {
	for _, e := range m.DeleteSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionByIDMock.defaultExpectation != nil && afterDeleteSessionByIDCounter < 1 {
		if m.DeleteSessionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByID at\n%s", m.DeleteSessionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByID at\n%s with params: %#v", m.DeleteSessionByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSessionByID != nil && afterDeleteSessionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByID at\n%s", m.funcDeleteSessionByIDOrigin)
	}

	if !m.DeleteSessionByIDMock.invocationsDone() && afterDeleteSessionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteSessionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionByIDMock.expectedInvocations), m.DeleteSessionByIDMock.expectedInvocationsOrigin, afterDeleteSessionByIDCounter)
	}
}

type mRepositoryMockDeleteSessionByIDAndUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSessionByIDAndUserExpectation
	expectations       []*RepositoryMockDeleteSessionByIDAndUserExpectation

	callArgs []*RepositoryMockDeleteSessionByIDAndUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteSessionByIDAndUserExpectation specifies expectation struct of the Repository.DeleteSessionByIDAndUser
type RepositoryMockDeleteSessionByIDAndUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteSessionByIDAndUserParams
	paramPtrs          *RepositoryMockDeleteSessionByIDAndUserParamPtrs
	expectationOrigins RepositoryMockDeleteSessionByIDAndUserExpectationOrigins
	results            *RepositoryMockDeleteSessionByIDAndUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteSessionByIDAndUserParams contains parameters of the Repository.DeleteSessionByIDAndUser
type RepositoryMockDeleteSessionByIDAndUserParams struct {
	ctx    context.Context
	id     uuid.UUID
	userID uuid.UUID
}

// RepositoryMockDeleteSessionByIDAndUserParamPtrs contains pointers to parameters of the Repository.DeleteSessionByIDAndUser
type RepositoryMockDeleteSessionByIDAndUserParamPtrs struct {
	ctx    *context.Context
	id     *uuid.UUID
	userID *uuid.UUID
}

// RepositoryMockDeleteSessionByIDAndUserResults contains results of the Repository.DeleteSessionByIDAndUser
type RepositoryMockDeleteSessionByIDAndUserResults struct {
	err error
}

// RepositoryMockDeleteSessionByIDAndUserOrigins contains origins of expectations of the Repository.DeleteSessionByIDAndUser
type RepositoryMockDeleteSessionByIDAndUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Optional() *mRepositoryMockDeleteSessionByIDAndUser {
	mmDeleteSessionByIDAndUser.optional = true
	return mmDeleteSessionByIDAndUser
}

// Expect sets up expected params for Repository.DeleteSessionByIDAndUser
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Expect(ctx context.Context, id uuid.UUID, userID uuid.UUID) *mRepositoryMockDeleteSessionByIDAndUser {
	if mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Set")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation = &RepositoryMockDeleteSessionByIDAndUserExpectation{}
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by ExpectParams functions")
	}

	mmDeleteSessionByIDAndUser.defaultExpectation.params = &RepositoryMockDeleteSessionByIDAndUserParams{ctx, id, userID}
	mmDeleteSessionByIDAndUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSessionByIDAndUser.expectations {
		if minimock.Equal(e.params, mmDeleteSessionByIDAndUser.defaultExpectation.params) {
			mmDeleteSessionByIDAndUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSessionByIDAndUser.defaultExpectation.params)
		}
	}

	return mmDeleteSessionByIDAndUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteSessionByIDAndUser
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteSessionByIDAndUser {
	if mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Set")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation = &RepositoryMockDeleteSessionByIDAndUserExpectation{}
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.params != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Expect")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionByIDAndUserParamPtrs{}
	}
	mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSessionByIDAndUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSessionByIDAndUser
}

// ExpectIdParam2 sets up expected param id for Repository.DeleteSessionByIDAndUser
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) ExpectIdParam2(id uuid.UUID) *mRepositoryMockDeleteSessionByIDAndUser {
	if mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Set")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation = &RepositoryMockDeleteSessionByIDAndUserExpectation{}
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.params != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Expect")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionByIDAndUserParamPtrs{}
	}
	mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteSessionByIDAndUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteSessionByIDAndUser
}

// ExpectUserIDParam3 sets up expected param userID for Repository.DeleteSessionByIDAndUser
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) ExpectUserIDParam3(userID uuid.UUID) *mRepositoryMockDeleteSessionByIDAndUser {
	if mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Set")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation = &RepositoryMockDeleteSessionByIDAndUserExpectation{}
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.params != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Expect")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionByIDAndUserParamPtrs{}
	}
	mmDeleteSessionByIDAndUser.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSessionByIDAndUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSessionByIDAndUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSessionByIDAndUser
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Inspect(f func(ctx context.Context, id uuid.UUID, userID uuid.UUID)) *mRepositoryMockDeleteSessionByIDAndUser {
	if mmDeleteSessionByIDAndUser.mock.inspectFuncDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSessionByIDAndUser")
	}

	mmDeleteSessionByIDAndUser.mock.inspectFuncDeleteSessionByIDAndUser = f

	return mmDeleteSessionByIDAndUser
}

// Return sets up results that will be returned by Repository.DeleteSessionByIDAndUser
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Return(err error) *RepositoryMock {
	if mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Set")
	}

	if mmDeleteSessionByIDAndUser.defaultExpectation == nil {
		mmDeleteSessionByIDAndUser.defaultExpectation = &RepositoryMockDeleteSessionByIDAndUserExpectation{mock: mmDeleteSessionByIDAndUser.mock}
	}
	mmDeleteSessionByIDAndUser.defaultExpectation.results = &RepositoryMockDeleteSessionByIDAndUserResults{err}
	mmDeleteSessionByIDAndUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionByIDAndUser.mock
}

// Set uses given function f to mock the Repository.DeleteSessionByIDAndUser method
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Set(f func(ctx context.Context, id uuid.UUID, userID uuid.UUID) (err error)) *RepositoryMock {
	if mmDeleteSessionByIDAndUser.defaultExpectation != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSessionByIDAndUser method")
	}

	if len(mmDeleteSessionByIDAndUser.expectations) > 0 {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSessionByIDAndUser method")
	}

	mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser = f
	mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUserOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionByIDAndUser.mock
}

// When sets expectation for the Repository.DeleteSessionByIDAndUser which will trigger the result defined by the following
// Then helper
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) When(ctx context.Context, id uuid.UUID, userID uuid.UUID) *RepositoryMockDeleteSessionByIDAndUserExpectation {
	if mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("RepositoryMock.DeleteSessionByIDAndUser mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSessionByIDAndUserExpectation{
		mock:               mmDeleteSessionByIDAndUser.mock,
		params:             &RepositoryMockDeleteSessionByIDAndUserParams{ctx, id, userID},
		expectationOrigins: RepositoryMockDeleteSessionByIDAndUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSessionByIDAndUser.expectations = append(mmDeleteSessionByIDAndUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSessionByIDAndUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSessionByIDAndUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSessionByIDAndUserResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteSessionByIDAndUser should be invoked
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Times(n uint64) *mRepositoryMockDeleteSessionByIDAndUser {
	if n == 0 {
		mmDeleteSessionByIDAndUser.mock.t.Fatalf("Times of RepositoryMock.DeleteSessionByIDAndUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSessionByIDAndUser.expectedInvocations, n)
	mmDeleteSessionByIDAndUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionByIDAndUser
}

func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) invocationsDone() bool {
	if len(mmDeleteSessionByIDAndUser.expectations) == 0 && mmDeleteSessionByIDAndUser.defaultExpectation == nil && mmDeleteSessionByIDAndUser.mock.funcDeleteSessionByIDAndUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSessionByIDAndUser.mock.afterDeleteSessionByIDAndUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSessionByIDAndUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSessionByIDAndUser implements mm_auth.Repository
func (mmDeleteSessionByIDAndUser *RepositoryMock) DeleteSessionByIDAndUser(ctx context.Context, id uuid.UUID, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSessionByIDAndUser.beforeDeleteSessionByIDAndUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSessionByIDAndUser.afterDeleteSessionByIDAndUserCounter, 1)

	mmDeleteSessionByIDAndUser.t.Helper()

	if mmDeleteSessionByIDAndUser.inspectFuncDeleteSessionByIDAndUser != nil {
		mmDeleteSessionByIDAndUser.inspectFuncDeleteSessionByIDAndUser(ctx, id, userID)
	}

	mm_params := RepositoryMockDeleteSessionByIDAndUserParams{ctx, id, userID}

	// Record call args
	mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.mutex.Lock()
	mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.callArgs = append(mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.callArgs, &mm_params)
	mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.mutex.Unlock()

	for _, e := range mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteSessionByIDAndUserParams{ctx, id, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSessionByIDAndUser.t.Errorf("RepositoryMock.DeleteSessionByIDAndUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteSessionByIDAndUser.t.Errorf("RepositoryMock.DeleteSessionByIDAndUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSessionByIDAndUser.t.Errorf("RepositoryMock.DeleteSessionByIDAndUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSessionByIDAndUser.t.Errorf("RepositoryMock.DeleteSessionByIDAndUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSessionByIDAndUser.DeleteSessionByIDAndUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSessionByIDAndUser.t.Fatal("No results are set for the RepositoryMock.DeleteSessionByIDAndUser")
		}
		return (*mm_results).err
	}
	if mmDeleteSessionByIDAndUser.funcDeleteSessionByIDAndUser != nil {
		return mmDeleteSessionByIDAndUser.funcDeleteSessionByIDAndUser(ctx, id, userID)
	}
	mmDeleteSessionByIDAndUser.t.Fatalf("Unexpected call to RepositoryMock.DeleteSessionByIDAndUser. %v %v %v", ctx, id, userID)
	return
}

// DeleteSessionByIDAndUserAfterCounter returns a count of finished RepositoryMock.DeleteSessionByIDAndUser invocations
func (mmDeleteSessionByIDAndUser *RepositoryMock) DeleteSessionByIDAndUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionByIDAndUser.afterDeleteSessionByIDAndUserCounter)
}

// DeleteSessionByIDAndUserBeforeCounter returns a count of RepositoryMock.DeleteSessionByIDAndUser invocations
func (mmDeleteSessionByIDAndUser *RepositoryMock) DeleteSessionByIDAndUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionByIDAndUser.beforeDeleteSessionByIDAndUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSessionByIDAndUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSessionByIDAndUser *mRepositoryMockDeleteSessionByIDAndUser) Calls() []*RepositoryMockDeleteSessionByIDAndUserParams {
	mmDeleteSessionByIDAndUser.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSessionByIDAndUserParams, len(mmDeleteSessionByIDAndUser.callArgs))
	copy(argCopy, mmDeleteSessionByIDAndUser.callArgs)

	mmDeleteSessionByIDAndUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionByIDAndUserDone returns true if the count of the DeleteSessionByIDAndUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSessionByIDAndUserDone() bool {
	if m.DeleteSessionByIDAndUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionByIDAndUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionByIDAndUserMock.invocationsDone()
}

// MinimockDeleteSessionByIDAndUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSessionByIDAndUserInspect() {
	for _, e := range m.DeleteSessionByIDAndUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByIDAndUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionByIDAndUserCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionByIDAndUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionByIDAndUserMock.defaultExpectation != nil && afterDeleteSessionByIDAndUserCounter < 1 {
		if m.DeleteSessionByIDAndUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByIDAndUser at\n%s", m.DeleteSessionByIDAndUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByIDAndUser at\n%s with params: %#v", m.DeleteSessionByIDAndUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionByIDAndUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSessionByIDAndUser != nil && afterDeleteSessionByIDAndUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteSessionByIDAndUser at\n%s", m.funcDeleteSessionByIDAndUserOrigin)
	}

	if !m.DeleteSessionByIDAndUserMock.invocationsDone() && afterDeleteSessionByIDAndUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteSessionByIDAndUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionByIDAndUserMock.expectedInvocations), m.DeleteSessionByIDAndUserMock.expectedInvocationsOrigin, afterDeleteSessionByIDAndUserCounter)
	}
}

type mRepositoryMockDeleteSessionsByUserID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSessionsByUserIDExpectation
	expectations       []*RepositoryMockDeleteSessionsByUserIDExpectation

	callArgs []*RepositoryMockDeleteSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteSessionsByUserIDExpectation specifies expectation struct of the Repository.DeleteSessionsByUserID
type RepositoryMockDeleteSessionsByUserIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteSessionsByUserIDParams
	paramPtrs          *RepositoryMockDeleteSessionsByUserIDParamPtrs
	expectationOrigins RepositoryMockDeleteSessionsByUserIDExpectationOrigins
	results            *RepositoryMockDeleteSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteSessionsByUserIDParams contains parameters of the Repository.DeleteSessionsByUserID
type RepositoryMockDeleteSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// RepositoryMockDeleteSessionsByUserIDParamPtrs contains pointers to parameters of the Repository.DeleteSessionsByUserID
type RepositoryMockDeleteSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// RepositoryMockDeleteSessionsByUserIDResults contains results of the Repository.DeleteSessionsByUserID
type RepositoryMockDeleteSessionsByUserIDResults struct {
	err error
}

// RepositoryMockDeleteSessionsByUserIDOrigins contains origins of expectations of the Repository.DeleteSessionsByUserID
type RepositoryMockDeleteSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Optional() *mRepositoryMockDeleteSessionsByUserID {
	mmDeleteSessionsByUserID.optional = true
	return mmDeleteSessionsByUserID
}

// Expect sets up expected params for Repository.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mRepositoryMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &RepositoryMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteSessionsByUserID.defaultExpectation.params = &RepositoryMockDeleteSessionsByUserIDParams{ctx, userID}
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteSessionsByUserID.defaultExpectation.params) {
			mmDeleteSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &RepositoryMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for Repository.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mRepositoryMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &RepositoryMockDeleteSessionsByUserIDExpectation{}
	}

	if mmDeleteSessionsByUserID.defaultExpectation.params != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Expect")
	}

	if mmDeleteSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteSessionsByUserID.defaultExpectation.paramPtrs = &RepositoryMockDeleteSessionsByUserIDParamPtrs{}
	}
	mmDeleteSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mRepositoryMockDeleteSessionsByUserID {
	if mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSessionsByUserID")
	}

	mmDeleteSessionsByUserID.mock.inspectFuncDeleteSessionsByUserID = f

	return mmDeleteSessionsByUserID
}

// Return sets up results that will be returned by Repository.DeleteSessionsByUserID
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Return(err error) *RepositoryMock {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Set")
	}

	if mmDeleteSessionsByUserID.defaultExpectation == nil {
		mmDeleteSessionsByUserID.defaultExpectation = &RepositoryMockDeleteSessionsByUserIDExpectation{mock: mmDeleteSessionsByUserID.mock}
	}
	mmDeleteSessionsByUserID.defaultExpectation.results = &RepositoryMockDeleteSessionsByUserIDResults{err}
	mmDeleteSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// Set uses given function f to mock the Repository.DeleteSessionsByUserID method
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (err error)) *RepositoryMock {
	if mmDeleteSessionsByUserID.defaultExpectation != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSessionsByUserID method")
	}

	if len(mmDeleteSessionsByUserID.expectations) > 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSessionsByUserID method")
	}

	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID = f
	mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID.mock
}

// When sets expectation for the Repository.DeleteSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *RepositoryMockDeleteSessionsByUserIDExpectation {
	if mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.mock.t.Fatalf("RepositoryMock.DeleteSessionsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSessionsByUserIDExpectation{
		mock:               mmDeleteSessionsByUserID.mock,
		params:             &RepositoryMockDeleteSessionsByUserIDParams{ctx, userID},
		expectationOrigins: RepositoryMockDeleteSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSessionsByUserID.expectations = append(mmDeleteSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSessionsByUserIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSessionsByUserIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteSessionsByUserID should be invoked
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Times(n uint64) *mRepositoryMockDeleteSessionsByUserID {
	if n == 0 {
		mmDeleteSessionsByUserID.mock.t.Fatalf("Times of RepositoryMock.DeleteSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSessionsByUserID.expectedInvocations, n)
	mmDeleteSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSessionsByUserID
}

func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) invocationsDone() bool {
	if len(mmDeleteSessionsByUserID.expectations) == 0 && mmDeleteSessionsByUserID.defaultExpectation == nil && mmDeleteSessionsByUserID.mock.funcDeleteSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.mock.afterDeleteSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSessionsByUserID implements mm_auth.Repository
func (mmDeleteSessionsByUserID *RepositoryMock) DeleteSessionsByUserID(ctx context.Context, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter, 1)

	mmDeleteSessionsByUserID.t.Helper()

	if mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID != nil {
		mmDeleteSessionsByUserID.inspectFuncDeleteSessionsByUserID(ctx, userID)
	}

	mm_params := RepositoryMockDeleteSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Lock()
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs = append(mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.callArgs, &mm_params)
	mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSessionsByUserID.t.Errorf("RepositoryMock.DeleteSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteSessionsByUserID.t.Errorf("RepositoryMock.DeleteSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSessionsByUserID.t.Errorf("RepositoryMock.DeleteSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSessionsByUserID.DeleteSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSessionsByUserID.t.Fatal("No results are set for the RepositoryMock.DeleteSessionsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteSessionsByUserID.funcDeleteSessionsByUserID != nil {
		return mmDeleteSessionsByUserID.funcDeleteSessionsByUserID(ctx, userID)
	}
	mmDeleteSessionsByUserID.t.Fatalf("Unexpected call to RepositoryMock.DeleteSessionsByUserID. %v %v", ctx, userID)
	return
}

// DeleteSessionsByUserIDAfterCounter returns a count of finished RepositoryMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *RepositoryMock) DeleteSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.afterDeleteSessionsByUserIDCounter)
}

// DeleteSessionsByUserIDBeforeCounter returns a count of RepositoryMock.DeleteSessionsByUserID invocations
func (mmDeleteSessionsByUserID *RepositoryMock) DeleteSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSessionsByUserID.beforeDeleteSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSessionsByUserID *mRepositoryMockDeleteSessionsByUserID) Calls() []*RepositoryMockDeleteSessionsByUserIDParams {
	mmDeleteSessionsByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSessionsByUserIDParams, len(mmDeleteSessionsByUserID.callArgs))
	copy(argCopy, mmDeleteSessionsByUserID.callArgs)

	mmDeleteSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSessionsByUserIDDone returns true if the count of the DeleteSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSessionsByUserIDDone() bool {
	if m.DeleteSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSessionsByUserIDMock.invocationsDone()
}

// MinimockDeleteSessionsByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSessionsByUserIDInspect() {
	for _, e := range m.DeleteSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSessionsByUserIDMock.defaultExpectation != nil && afterDeleteSessionsByUserIDCounter < 1 {
		if m.DeleteSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionsByUserID at\n%s", m.DeleteSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSessionsByUserID at\n%s with params: %#v", m.DeleteSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSessionsByUserID != nil && afterDeleteSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteSessionsByUserID at\n%s", m.funcDeleteSessionsByUserIDOrigin)
	}

	if !m.DeleteSessionsByUserIDMock.invocationsDone() && afterDeleteSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSessionsByUserIDMock.expectedInvocations), m.DeleteSessionsByUserIDMock.expectedInvocationsOrigin, afterDeleteSessionsByUserIDCounter)
	}
}

type mRepositoryMockDeleteUserRole struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteUserRoleExpectation
	expectations       []*RepositoryMockDeleteUserRoleExpectation

	callArgs []*RepositoryMockDeleteUserRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteUserRoleExpectation specifies expectation struct of the Repository.DeleteUserRole
type RepositoryMockDeleteUserRoleExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteUserRoleParams
	paramPtrs          *RepositoryMockDeleteUserRoleParamPtrs
	expectationOrigins RepositoryMockDeleteUserRoleExpectationOrigins
	results            *RepositoryMockDeleteUserRoleResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteUserRoleParams contains parameters of the Repository.DeleteUserRole
type RepositoryMockDeleteUserRoleParams struct {
	ctx  context.Context
	role mm_auth.UserRole
}

// RepositoryMockDeleteUserRoleParamPtrs contains pointers to parameters of the Repository.DeleteUserRole
type RepositoryMockDeleteUserRoleParamPtrs struct {
	ctx  *context.Context
	role *mm_auth.UserRole
}

// RepositoryMockDeleteUserRoleResults contains results of the Repository.DeleteUserRole
type RepositoryMockDeleteUserRoleResults struct {
	err error
}

// RepositoryMockDeleteUserRoleOrigins contains origins of expectations of the Repository.DeleteUserRole
type RepositoryMockDeleteUserRoleExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Optional() *mRepositoryMockDeleteUserRole {
	mmDeleteUserRole.optional = true
	return mmDeleteUserRole
}

// Expect sets up expected params for Repository.DeleteUserRole
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Expect(ctx context.Context, role mm_auth.UserRole) *mRepositoryMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &RepositoryMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by ExpectParams functions")
	}

	mmDeleteUserRole.defaultExpectation.params = &RepositoryMockDeleteUserRoleParams{ctx, role}
	mmDeleteUserRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUserRole.expectations {
		if minimock.Equal(e.params, mmDeleteUserRole.defaultExpectation.params) {
			mmDeleteUserRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserRole.defaultExpectation.params)
		}
	}

	return mmDeleteUserRole
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteUserRole
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &RepositoryMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.params != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Expect")
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs == nil {
		mmDeleteUserRole.defaultExpectation.paramPtrs = &RepositoryMockDeleteUserRoleParamPtrs{}
	}
	mmDeleteUserRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUserRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUserRole
}

// ExpectRoleParam2 sets up expected param role for Repository.DeleteUserRole
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) ExpectRoleParam2(role mm_auth.UserRole) *mRepositoryMockDeleteUserRole {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &RepositoryMockDeleteUserRoleExpectation{}
	}

	if mmDeleteUserRole.defaultExpectation.params != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Expect")
	}

	if mmDeleteUserRole.defaultExpectation.paramPtrs == nil {
		mmDeleteUserRole.defaultExpectation.paramPtrs = &RepositoryMockDeleteUserRoleParamPtrs{}
	}
	mmDeleteUserRole.defaultExpectation.paramPtrs.role = &role
	mmDeleteUserRole.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmDeleteUserRole
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteUserRole
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Inspect(f func(ctx context.Context, role mm_auth.UserRole)) *mRepositoryMockDeleteUserRole {
	if mmDeleteUserRole.mock.inspectFuncDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteUserRole")
	}

	mmDeleteUserRole.mock.inspectFuncDeleteUserRole = f

	return mmDeleteUserRole
}

// Return sets up results that will be returned by Repository.DeleteUserRole
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Return(err error) *RepositoryMock {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Set")
	}

	if mmDeleteUserRole.defaultExpectation == nil {
		mmDeleteUserRole.defaultExpectation = &RepositoryMockDeleteUserRoleExpectation{mock: mmDeleteUserRole.mock}
	}
	mmDeleteUserRole.defaultExpectation.results = &RepositoryMockDeleteUserRoleResults{err}
	mmDeleteUserRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole.mock
}

// Set uses given function f to mock the Repository.DeleteUserRole method
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Set(f func(ctx context.Context, role mm_auth.UserRole) (err error)) *RepositoryMock {
	if mmDeleteUserRole.defaultExpectation != nil {
		mmDeleteUserRole.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteUserRole method")
	}

	if len(mmDeleteUserRole.expectations) > 0 {
		mmDeleteUserRole.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteUserRole method")
	}

	mmDeleteUserRole.mock.funcDeleteUserRole = f
	mmDeleteUserRole.mock.funcDeleteUserRoleOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole.mock
}

// When sets expectation for the Repository.DeleteUserRole which will trigger the result defined by the following
// Then helper
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) When(ctx context.Context, role mm_auth.UserRole) *RepositoryMockDeleteUserRoleExpectation {
	if mmDeleteUserRole.mock.funcDeleteUserRole != nil {
		mmDeleteUserRole.mock.t.Fatalf("RepositoryMock.DeleteUserRole mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteUserRoleExpectation{
		mock:               mmDeleteUserRole.mock,
		params:             &RepositoryMockDeleteUserRoleParams{ctx, role},
		expectationOrigins: RepositoryMockDeleteUserRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUserRole.expectations = append(mmDeleteUserRole.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteUserRole return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteUserRoleExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteUserRoleResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteUserRole should be invoked
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Times(n uint64) *mRepositoryMockDeleteUserRole {
	if n == 0 {
		mmDeleteUserRole.mock.t.Fatalf("Times of RepositoryMock.DeleteUserRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUserRole.expectedInvocations, n)
	mmDeleteUserRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUserRole
}

func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) invocationsDone() bool {
	if len(mmDeleteUserRole.expectations) == 0 && mmDeleteUserRole.defaultExpectation == nil && mmDeleteUserRole.mock.funcDeleteUserRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUserRole.mock.afterDeleteUserRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUserRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUserRole implements mm_auth.Repository
func (mmDeleteUserRole *RepositoryMock) DeleteUserRole(ctx context.Context, role mm_auth.UserRole) (err error) {
	mm_atomic.AddUint64(&mmDeleteUserRole.beforeDeleteUserRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserRole.afterDeleteUserRoleCounter, 1)

	mmDeleteUserRole.t.Helper()

	if mmDeleteUserRole.inspectFuncDeleteUserRole != nil {
		mmDeleteUserRole.inspectFuncDeleteUserRole(ctx, role)
	}

	mm_params := RepositoryMockDeleteUserRoleParams{ctx, role}

	// Record call args
	mmDeleteUserRole.DeleteUserRoleMock.mutex.Lock()
	mmDeleteUserRole.DeleteUserRoleMock.callArgs = append(mmDeleteUserRole.DeleteUserRoleMock.callArgs, &mm_params)
	mmDeleteUserRole.DeleteUserRoleMock.mutex.Unlock()

	for _, e := range mmDeleteUserRole.DeleteUserRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteUserRoleParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUserRole.t.Errorf("RepositoryMock.DeleteUserRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmDeleteUserRole.t.Errorf("RepositoryMock.DeleteUserRole got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserRole.t.Errorf("RepositoryMock.DeleteUserRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserRole.DeleteUserRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserRole.t.Fatal("No results are set for the RepositoryMock.DeleteUserRole")
		}
		return (*mm_results).err
	}
	if mmDeleteUserRole.funcDeleteUserRole != nil {
		return mmDeleteUserRole.funcDeleteUserRole(ctx, role)
	}
	mmDeleteUserRole.t.Fatalf("Unexpected call to RepositoryMock.DeleteUserRole. %v %v", ctx, role)
	return
}

// DeleteUserRoleAfterCounter returns a count of finished RepositoryMock.DeleteUserRole invocations
func (mmDeleteUserRole *RepositoryMock) DeleteUserRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserRole.afterDeleteUserRoleCounter)
}

// DeleteUserRoleBeforeCounter returns a count of RepositoryMock.DeleteUserRole invocations
func (mmDeleteUserRole *RepositoryMock) DeleteUserRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserRole.beforeDeleteUserRoleCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteUserRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserRole *mRepositoryMockDeleteUserRole) Calls() []*RepositoryMockDeleteUserRoleParams {
	mmDeleteUserRole.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteUserRoleParams, len(mmDeleteUserRole.callArgs))
	copy(argCopy, mmDeleteUserRole.callArgs)

	mmDeleteUserRole.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserRoleDone returns true if the count of the DeleteUserRole invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteUserRoleDone() bool {
	if m.DeleteUserRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserRoleMock.invocationsDone()
}

// MinimockDeleteUserRoleInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteUserRoleInspect() {
	for _, e := range m.DeleteUserRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUserRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserRoleCounter := mm_atomic.LoadUint64(&m.afterDeleteUserRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserRoleMock.defaultExpectation != nil && afterDeleteUserRoleCounter < 1 {
		if m.DeleteUserRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUserRole at\n%s", m.DeleteUserRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUserRole at\n%s with params: %#v", m.DeleteUserRoleMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserRole != nil && afterDeleteUserRoleCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteUserRole at\n%s", m.funcDeleteUserRoleOrigin)
	}

	if !m.DeleteUserRoleMock.invocationsDone() && afterDeleteUserRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteUserRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserRoleMock.expectedInvocations), m.DeleteUserRoleMock.expectedInvocationsOrigin, afterDeleteUserRoleCounter)
	}
}

type mRepositoryMockGetSessionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSessionByIDExpectation
	expectations       []*RepositoryMockGetSessionByIDExpectation

	callArgs []*RepositoryMockGetSessionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSessionByIDExpectation specifies expectation struct of the Repository.GetSessionByID
type RepositoryMockGetSessionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSessionByIDParams
	paramPtrs          *RepositoryMockGetSessionByIDParamPtrs
	expectationOrigins RepositoryMockGetSessionByIDExpectationOrigins
	results            *RepositoryMockGetSessionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSessionByIDParams contains parameters of the Repository.GetSessionByID
type RepositoryMockGetSessionByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockGetSessionByIDParamPtrs contains pointers to parameters of the Repository.GetSessionByID
type RepositoryMockGetSessionByIDParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockGetSessionByIDResults contains results of the Repository.GetSessionByID
type RepositoryMockGetSessionByIDResults struct {
	s1  mm_auth.Session
	s2  string
	err error
}

// RepositoryMockGetSessionByIDOrigins contains origins of expectations of the Repository.GetSessionByID
type RepositoryMockGetSessionByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Optional() *mRepositoryMockGetSessionByID {
	mmGetSessionByID.optional = true
	return mmGetSessionByID
}

// Expect sets up expected params for Repository.GetSessionByID
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockGetSessionByID {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &RepositoryMockGetSessionByIDExpectation{}
	}

	if mmGetSessionByID.defaultExpectation.paramPtrs != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by ExpectParams functions")
	}

	mmGetSessionByID.defaultExpectation.params = &RepositoryMockGetSessionByIDParams{ctx, id}
	mmGetSessionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSessionByID.expectations {
		if minimock.Equal(e.params, mmGetSessionByID.defaultExpectation.params) {
			mmGetSessionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSessionByID.defaultExpectation.params)
		}
	}

	return mmGetSessionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSessionByID
func (mmGetSessionByID *mRepositoryMockGetSessionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSessionByID {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &RepositoryMockGetSessionByIDExpectation{}
	}

	if mmGetSessionByID.defaultExpectation.params != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Expect")
	}

	if mmGetSessionByID.defaultExpectation.paramPtrs == nil {
		mmGetSessionByID.defaultExpectation.paramPtrs = &RepositoryMockGetSessionByIDParamPtrs{}
	}
	mmGetSessionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSessionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSessionByID
}

// ExpectIdParam2 sets up expected param id for Repository.GetSessionByID
func (mmGetSessionByID *mRepositoryMockGetSessionByID) ExpectIdParam2(id uuid.UUID) *mRepositoryMockGetSessionByID {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &RepositoryMockGetSessionByIDExpectation{}
	}

	if mmGetSessionByID.defaultExpectation.params != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Expect")
	}

	if mmGetSessionByID.defaultExpectation.paramPtrs == nil {
		mmGetSessionByID.defaultExpectation.paramPtrs = &RepositoryMockGetSessionByIDParamPtrs{}
	}
	mmGetSessionByID.defaultExpectation.paramPtrs.id = &id
	mmGetSessionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetSessionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSessionByID
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockGetSessionByID {
	if mmGetSessionByID.mock.inspectFuncGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSessionByID")
	}

	mmGetSessionByID.mock.inspectFuncGetSessionByID = f

	return mmGetSessionByID
}

// Return sets up results that will be returned by Repository.GetSessionByID
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Return(s1 mm_auth.Session, s2 string, err error) *RepositoryMock {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Set")
	}

	if mmGetSessionByID.defaultExpectation == nil {
		mmGetSessionByID.defaultExpectation = &RepositoryMockGetSessionByIDExpectation{mock: mmGetSessionByID.mock}
	}
	mmGetSessionByID.defaultExpectation.results = &RepositoryMockGetSessionByIDResults{s1, s2, err}
	mmGetSessionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSessionByID.mock
}

// Set uses given function f to mock the Repository.GetSessionByID method
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Set(f func(ctx context.Context, id uuid.UUID) (s1 mm_auth.Session, s2 string, err error)) *RepositoryMock {
	if mmGetSessionByID.defaultExpectation != nil {
		mmGetSessionByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetSessionByID method")
	}

	if len(mmGetSessionByID.expectations) > 0 {
		mmGetSessionByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetSessionByID method")
	}

	mmGetSessionByID.mock.funcGetSessionByID = f
	mmGetSessionByID.mock.funcGetSessionByIDOrigin = minimock.CallerInfo(1)
	return mmGetSessionByID.mock
}

// When sets expectation for the Repository.GetSessionByID which will trigger the result defined by the following
// Then helper
func (mmGetSessionByID *mRepositoryMockGetSessionByID) When(ctx context.Context, id uuid.UUID) *RepositoryMockGetSessionByIDExpectation {
	if mmGetSessionByID.mock.funcGetSessionByID != nil {
		mmGetSessionByID.mock.t.Fatalf("RepositoryMock.GetSessionByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetSessionByIDExpectation{
		mock:               mmGetSessionByID.mock,
		params:             &RepositoryMockGetSessionByIDParams{ctx, id},
		expectationOrigins: RepositoryMockGetSessionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSessionByID.expectations = append(mmGetSessionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSessionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSessionByIDExpectation) Then(s1 mm_auth.Session, s2 string, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSessionByIDResults{s1, s2, err}
	return e.mock
}

// Times sets number of times Repository.GetSessionByID should be invoked
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Times(n uint64) *mRepositoryMockGetSessionByID {
	if n == 0 {
		mmGetSessionByID.mock.t.Fatalf("Times of RepositoryMock.GetSessionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSessionByID.expectedInvocations, n)
	mmGetSessionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSessionByID
}

func (mmGetSessionByID *mRepositoryMockGetSessionByID) invocationsDone() bool {
	if len(mmGetSessionByID.expectations) == 0 && mmGetSessionByID.defaultExpectation == nil && mmGetSessionByID.mock.funcGetSessionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSessionByID.mock.afterGetSessionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSessionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSessionByID implements mm_auth.Repository
func (mmGetSessionByID *RepositoryMock) GetSessionByID(ctx context.Context, id uuid.UUID) (s1 mm_auth.Session, s2 string, err error) {
	mm_atomic.AddUint64(&mmGetSessionByID.beforeGetSessionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSessionByID.afterGetSessionByIDCounter, 1)

	mmGetSessionByID.t.Helper()

	if mmGetSessionByID.inspectFuncGetSessionByID != nil {
		mmGetSessionByID.inspectFuncGetSessionByID(ctx, id)
	}

	mm_params := RepositoryMockGetSessionByIDParams{ctx, id}

	// Record call args
	mmGetSessionByID.GetSessionByIDMock.mutex.Lock()
	mmGetSessionByID.GetSessionByIDMock.callArgs = append(mmGetSessionByID.GetSessionByIDMock.callArgs, &mm_params)
	mmGetSessionByID.GetSessionByIDMock.mutex.Unlock()

	for _, e := range mmGetSessionByID.GetSessionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.s2, e.results.err
		}
	}

	if mmGetSessionByID.GetSessionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSessionByID.GetSessionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSessionByID.GetSessionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSessionByID.GetSessionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSessionByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSessionByID.t.Errorf("RepositoryMock.GetSessionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionByID.GetSessionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetSessionByID.t.Errorf("RepositoryMock.GetSessionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionByID.GetSessionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSessionByID.t.Errorf("RepositoryMock.GetSessionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSessionByID.GetSessionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSessionByID.GetSessionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSessionByID.t.Fatal("No results are set for the RepositoryMock.GetSessionByID")
		}
		return (*mm_results).s1, (*mm_results).s2, (*mm_results).err
	}
	if mmGetSessionByID.funcGetSessionByID != nil {
		return mmGetSessionByID.funcGetSessionByID(ctx, id)
	}
	mmGetSessionByID.t.Fatalf("Unexpected call to RepositoryMock.GetSessionByID. %v %v", ctx, id)
	return
}

// GetSessionByIDAfterCounter returns a count of finished RepositoryMock.GetSessionByID invocations
func (mmGetSessionByID *RepositoryMock) GetSessionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionByID.afterGetSessionByIDCounter)
}

// GetSessionByIDBeforeCounter returns a count of RepositoryMock.GetSessionByID invocations
func (mmGetSessionByID *RepositoryMock) GetSessionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionByID.beforeGetSessionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSessionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSessionByID *mRepositoryMockGetSessionByID) Calls() []*RepositoryMockGetSessionByIDParams {
	mmGetSessionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSessionByIDParams, len(mmGetSessionByID.callArgs))
	copy(argCopy, mmGetSessionByID.callArgs)

	mmGetSessionByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSessionByIDDone returns true if the count of the GetSessionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSessionByIDDone() bool {
	if m.GetSessionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSessionByIDMock.invocationsDone()
}

// MinimockGetSessionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSessionByIDInspect() {
	for _, e := range m.GetSessionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSessionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSessionByIDCounter := mm_atomic.LoadUint64(&m.afterGetSessionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSessionByIDMock.defaultExpectation != nil && afterGetSessionByIDCounter < 1 {
		if m.GetSessionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSessionByID at\n%s", m.GetSessionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSessionByID at\n%s with params: %#v", m.GetSessionByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSessionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSessionByID != nil && afterGetSessionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSessionByID at\n%s", m.funcGetSessionByIDOrigin)
	}

	if !m.GetSessionByIDMock.invocationsDone() && afterGetSessionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSessionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSessionByIDMock.expectedInvocations), m.GetSessionByIDMock.expectedInvocationsOrigin, afterGetSessionByIDCounter)
	}
}

type mRepositoryMockGetSessionsByUserID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSessionsByUserIDExpectation
	expectations       []*RepositoryMockGetSessionsByUserIDExpectation

	callArgs []*RepositoryMockGetSessionsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSessionsByUserIDExpectation specifies expectation struct of the Repository.GetSessionsByUserID
type RepositoryMockGetSessionsByUserIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSessionsByUserIDParams
	paramPtrs          *RepositoryMockGetSessionsByUserIDParamPtrs
	expectationOrigins RepositoryMockGetSessionsByUserIDExpectationOrigins
	results            *RepositoryMockGetSessionsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSessionsByUserIDParams contains parameters of the Repository.GetSessionsByUserID
type RepositoryMockGetSessionsByUserIDParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// RepositoryMockGetSessionsByUserIDParamPtrs contains pointers to parameters of the Repository.GetSessionsByUserID
type RepositoryMockGetSessionsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// RepositoryMockGetSessionsByUserIDResults contains results of the Repository.GetSessionsByUserID
type RepositoryMockGetSessionsByUserIDResults struct {
	sa1 []mm_auth.Session
	err error
}

// RepositoryMockGetSessionsByUserIDOrigins contains origins of expectations of the Repository.GetSessionsByUserID
type RepositoryMockGetSessionsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Optional() *mRepositoryMockGetSessionsByUserID {
	mmGetSessionsByUserID.optional = true
	return mmGetSessionsByUserID
}

// Expect sets up expected params for Repository.GetSessionsByUserID
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Expect(ctx context.Context, userID uuid.UUID) *mRepositoryMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &RepositoryMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by ExpectParams functions")
	}

	mmGetSessionsByUserID.defaultExpectation.params = &RepositoryMockGetSessionsByUserIDParams{ctx, userID}
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSessionsByUserID.expectations {
		if minimock.Equal(e.params, mmGetSessionsByUserID.defaultExpectation.params) {
			mmGetSessionsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSessionsByUserID.defaultExpectation.params)
		}
	}

	return mmGetSessionsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSessionsByUserID
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &RepositoryMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.params != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Expect")
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetSessionsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetSessionsByUserIDParamPtrs{}
	}
	mmGetSessionsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSessionsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for Repository.GetSessionsByUserID
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) ExpectUserIDParam2(userID uuid.UUID) *mRepositoryMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &RepositoryMockGetSessionsByUserIDExpectation{}
	}

	if mmGetSessionsByUserID.defaultExpectation.params != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Expect")
	}

	if mmGetSessionsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetSessionsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetSessionsByUserIDParamPtrs{}
	}
	mmGetSessionsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetSessionsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetSessionsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSessionsByUserID
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mRepositoryMockGetSessionsByUserID {
	if mmGetSessionsByUserID.mock.inspectFuncGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSessionsByUserID")
	}

	mmGetSessionsByUserID.mock.inspectFuncGetSessionsByUserID = f

	return mmGetSessionsByUserID
}

// Return sets up results that will be returned by Repository.GetSessionsByUserID
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Return(sa1 []mm_auth.Session, err error) *RepositoryMock {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Set")
	}

	if mmGetSessionsByUserID.defaultExpectation == nil {
		mmGetSessionsByUserID.defaultExpectation = &RepositoryMockGetSessionsByUserIDExpectation{mock: mmGetSessionsByUserID.mock}
	}
	mmGetSessionsByUserID.defaultExpectation.results = &RepositoryMockGetSessionsByUserIDResults{sa1, err}
	mmGetSessionsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID.mock
}

// Set uses given function f to mock the Repository.GetSessionsByUserID method
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Set(f func(ctx context.Context, userID uuid.UUID) (sa1 []mm_auth.Session, err error)) *RepositoryMock {
	if mmGetSessionsByUserID.defaultExpectation != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.GetSessionsByUserID method")
	}

	if len(mmGetSessionsByUserID.expectations) > 0 {
		mmGetSessionsByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.GetSessionsByUserID method")
	}

	mmGetSessionsByUserID.mock.funcGetSessionsByUserID = f
	mmGetSessionsByUserID.mock.funcGetSessionsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID.mock
}

// When sets expectation for the Repository.GetSessionsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) When(ctx context.Context, userID uuid.UUID) *RepositoryMockGetSessionsByUserIDExpectation {
	if mmGetSessionsByUserID.mock.funcGetSessionsByUserID != nil {
		mmGetSessionsByUserID.mock.t.Fatalf("RepositoryMock.GetSessionsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockGetSessionsByUserIDExpectation{
		mock:               mmGetSessionsByUserID.mock,
		params:             &RepositoryMockGetSessionsByUserIDParams{ctx, userID},
		expectationOrigins: RepositoryMockGetSessionsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSessionsByUserID.expectations = append(mmGetSessionsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSessionsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSessionsByUserIDExpectation) Then(sa1 []mm_auth.Session, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSessionsByUserIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Repository.GetSessionsByUserID should be invoked
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Times(n uint64) *mRepositoryMockGetSessionsByUserID {
	if n == 0 {
		mmGetSessionsByUserID.mock.t.Fatalf("Times of RepositoryMock.GetSessionsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSessionsByUserID.expectedInvocations, n)
	mmGetSessionsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSessionsByUserID
}

func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) invocationsDone() bool {
	if len(mmGetSessionsByUserID.expectations) == 0 && mmGetSessionsByUserID.defaultExpectation == nil && mmGetSessionsByUserID.mock.funcGetSessionsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSessionsByUserID.mock.afterGetSessionsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSessionsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSessionsByUserID implements mm_auth.Repository
func (mmGetSessionsByUserID *RepositoryMock) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) (sa1 []mm_auth.Session, err error) {
	mm_atomic.AddUint64(&mmGetSessionsByUserID.beforeGetSessionsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSessionsByUserID.afterGetSessionsByUserIDCounter, 1)

	mmGetSessionsByUserID.t.Helper()

	if mmGetSessionsByUserID.inspectFuncGetSessionsByUserID != nil {
		mmGetSessionsByUserID.inspectFuncGetSessionsByUserID(ctx, userID)
	}

	mm_params := RepositoryMockGetSessionsByUserIDParams{ctx, userID}

	// Record call args
	mmGetSessionsByUserID.GetSessionsByUserIDMock.mutex.Lock()
	mmGetSessionsByUserID.GetSessionsByUserIDMock.callArgs = append(mmGetSessionsByUserID.GetSessionsByUserIDMock.callArgs, &mm_params)
	mmGetSessionsByUserID.GetSessionsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetSessionsByUserID.GetSessionsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSessionsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSessionsByUserID.t.Errorf("RepositoryMock.GetSessionsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetSessionsByUserID.t.Errorf("RepositoryMock.GetSessionsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSessionsByUserID.t.Errorf("RepositoryMock.GetSessionsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSessionsByUserID.GetSessionsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSessionsByUserID.t.Fatal("No results are set for the RepositoryMock.GetSessionsByUserID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSessionsByUserID.funcGetSessionsByUserID != nil {
		return mmGetSessionsByUserID.funcGetSessionsByUserID(ctx, userID)
	}
	mmGetSessionsByUserID.t.Fatalf("Unexpected call to RepositoryMock.GetSessionsByUserID. %v %v", ctx, userID)
	return
}

// GetSessionsByUserIDAfterCounter returns a count of finished RepositoryMock.GetSessionsByUserID invocations
func (mmGetSessionsByUserID *RepositoryMock) GetSessionsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionsByUserID.afterGetSessionsByUserIDCounter)
}

// GetSessionsByUserIDBeforeCounter returns a count of RepositoryMock.GetSessionsByUserID invocations
func (mmGetSessionsByUserID *RepositoryMock) GetSessionsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSessionsByUserID.beforeGetSessionsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSessionsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSessionsByUserID *mRepositoryMockGetSessionsByUserID) Calls() []*RepositoryMockGetSessionsByUserIDParams {
	mmGetSessionsByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSessionsByUserIDParams, len(mmGetSessionsByUserID.callArgs))
	copy(argCopy, mmGetSessionsByUserID.callArgs)

	mmGetSessionsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSessionsByUserIDDone returns true if the count of the GetSessionsByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSessionsByUserIDDone() bool {
	if m.GetSessionsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSessionsByUserIDMock.invocationsDone()
}

// MinimockGetSessionsByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSessionsByUserIDInspect() {
	for _, e := range m.GetSessionsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSessionsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSessionsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetSessionsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSessionsByUserIDMock.defaultExpectation != nil && afterGetSessionsByUserIDCounter < 1 {
		if m.GetSessionsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSessionsByUserID at\n%s", m.GetSessionsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSessionsByUserID at\n%s with params: %#v", m.GetSessionsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSessionsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSessionsByUserID != nil && afterGetSessionsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSessionsByUserID at\n%s", m.funcGetSessionsByUserIDOrigin)
	}

	if !m.GetSessionsByUserIDMock.invocationsDone() && afterGetSessionsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSessionsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSessionsByUserIDMock.expectedInvocations), m.GetSessionsByUserIDMock.expectedInvocationsOrigin, afterGetSessionsByUserIDCounter)
	}
}

type mRepositoryMockGetUserRoles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserRolesExpectation
	expectations       []*RepositoryMockGetUserRolesExpectation

	callArgs []*RepositoryMockGetUserRolesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetUserRolesExpectation specifies expectation struct of the Repository.GetUserRoles
type RepositoryMockGetUserRolesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetUserRolesParams
	paramPtrs          *RepositoryMockGetUserRolesParamPtrs
	expectationOrigins RepositoryMockGetUserRolesExpectationOrigins
	results            *RepositoryMockGetUserRolesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetUserRolesParams contains parameters of the Repository.GetUserRoles
type RepositoryMockGetUserRolesParams struct {
	ctx    context.Context
	userID uuid.UUID
	roles  []mm_auth.Role
}

// RepositoryMockGetUserRolesParamPtrs contains pointers to parameters of the Repository.GetUserRoles
type RepositoryMockGetUserRolesParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
	roles  *[]mm_auth.Role
}

// RepositoryMockGetUserRolesResults contains results of the Repository.GetUserRoles
type RepositoryMockGetUserRolesResults struct {
	ua1 []mm_auth.UserRole
	err error
}

// RepositoryMockGetUserRolesOrigins contains origins of expectations of the Repository.GetUserRoles
type RepositoryMockGetUserRolesExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originRoles  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Optional() *mRepositoryMockGetUserRoles {
	mmGetUserRoles.optional = true
	return mmGetUserRoles
}

// Expect sets up expected params for Repository.GetUserRoles
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Expect(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role) *mRepositoryMockGetUserRoles {
	if mmGetUserRoles.mock.funcGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Set")
	}

	if mmGetUserRoles.defaultExpectation == nil {
		mmGetUserRoles.defaultExpectation = &RepositoryMockGetUserRolesExpectation{}
	}

	if mmGetUserRoles.defaultExpectation.paramPtrs != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by ExpectParams functions")
	}

	mmGetUserRoles.defaultExpectation.params = &RepositoryMockGetUserRolesParams{ctx, userID, roles}
	mmGetUserRoles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserRoles.expectations {
		if minimock.Equal(e.params, mmGetUserRoles.defaultExpectation.params) {
			mmGetUserRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserRoles.defaultExpectation.params)
		}
	}

	return mmGetUserRoles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetUserRoles
func (mmGetUserRoles *mRepositoryMockGetUserRoles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetUserRoles {
	if mmGetUserRoles.mock.funcGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Set")
	}

	if mmGetUserRoles.defaultExpectation == nil {
		mmGetUserRoles.defaultExpectation = &RepositoryMockGetUserRolesExpectation{}
	}

	if mmGetUserRoles.defaultExpectation.params != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Expect")
	}

	if mmGetUserRoles.defaultExpectation.paramPtrs == nil {
		mmGetUserRoles.defaultExpectation.paramPtrs = &RepositoryMockGetUserRolesParamPtrs{}
	}
	mmGetUserRoles.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserRoles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserRoles
}

// ExpectUserIDParam2 sets up expected param userID for Repository.GetUserRoles
func (mmGetUserRoles *mRepositoryMockGetUserRoles) ExpectUserIDParam2(userID uuid.UUID) *mRepositoryMockGetUserRoles {
	if mmGetUserRoles.mock.funcGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Set")
	}

	if mmGetUserRoles.defaultExpectation == nil {
		mmGetUserRoles.defaultExpectation = &RepositoryMockGetUserRolesExpectation{}
	}

	if mmGetUserRoles.defaultExpectation.params != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Expect")
	}

	if mmGetUserRoles.defaultExpectation.paramPtrs == nil {
		mmGetUserRoles.defaultExpectation.paramPtrs = &RepositoryMockGetUserRolesParamPtrs{}
	}
	mmGetUserRoles.defaultExpectation.paramPtrs.userID = &userID
	mmGetUserRoles.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetUserRoles
}

// ExpectRolesParam3 sets up expected param roles for Repository.GetUserRoles
func (mmGetUserRoles *mRepositoryMockGetUserRoles) ExpectRolesParam3(roles []mm_auth.Role) *mRepositoryMockGetUserRoles {
	if mmGetUserRoles.mock.funcGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Set")
	}

	if mmGetUserRoles.defaultExpectation == nil {
		mmGetUserRoles.defaultExpectation = &RepositoryMockGetUserRolesExpectation{}
	}

	if mmGetUserRoles.defaultExpectation.params != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Expect")
	}

	if mmGetUserRoles.defaultExpectation.paramPtrs == nil {
		mmGetUserRoles.defaultExpectation.paramPtrs = &RepositoryMockGetUserRolesParamPtrs{}
	}
	mmGetUserRoles.defaultExpectation.paramPtrs.roles = &roles
	mmGetUserRoles.defaultExpectation.expectationOrigins.originRoles = minimock.CallerInfo(1)

	return mmGetUserRoles
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserRoles
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Inspect(f func(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role)) *mRepositoryMockGetUserRoles {
	if mmGetUserRoles.mock.inspectFuncGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserRoles")
	}

	mmGetUserRoles.mock.inspectFuncGetUserRoles = f

	return mmGetUserRoles
}

// Return sets up results that will be returned by Repository.GetUserRoles
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Return(ua1 []mm_auth.UserRole, err error) *RepositoryMock {
	if mmGetUserRoles.mock.funcGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Set")
	}

	if mmGetUserRoles.defaultExpectation == nil {
		mmGetUserRoles.defaultExpectation = &RepositoryMockGetUserRolesExpectation{mock: mmGetUserRoles.mock}
	}
	mmGetUserRoles.defaultExpectation.results = &RepositoryMockGetUserRolesResults{ua1, err}
	mmGetUserRoles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserRoles.mock
}

// Set uses given function f to mock the Repository.GetUserRoles method
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Set(f func(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role) (ua1 []mm_auth.UserRole, err error)) *RepositoryMock {
	if mmGetUserRoles.defaultExpectation != nil {
		mmGetUserRoles.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserRoles method")
	}

	if len(mmGetUserRoles.expectations) > 0 {
		mmGetUserRoles.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserRoles method")
	}

	mmGetUserRoles.mock.funcGetUserRoles = f
	mmGetUserRoles.mock.funcGetUserRolesOrigin = minimock.CallerInfo(1)
	return mmGetUserRoles.mock
}

// When sets expectation for the Repository.GetUserRoles which will trigger the result defined by the following
// Then helper
func (mmGetUserRoles *mRepositoryMockGetUserRoles) When(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role) *RepositoryMockGetUserRolesExpectation {
	if mmGetUserRoles.mock.funcGetUserRoles != nil {
		mmGetUserRoles.mock.t.Fatalf("RepositoryMock.GetUserRoles mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserRolesExpectation{
		mock:               mmGetUserRoles.mock,
		params:             &RepositoryMockGetUserRolesParams{ctx, userID, roles},
		expectationOrigins: RepositoryMockGetUserRolesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserRoles.expectations = append(mmGetUserRoles.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserRoles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserRolesExpectation) Then(ua1 []mm_auth.UserRole, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserRolesResults{ua1, err}
	return e.mock
}

// Times sets number of times Repository.GetUserRoles should be invoked
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Times(n uint64) *mRepositoryMockGetUserRoles {
	if n == 0 {
		mmGetUserRoles.mock.t.Fatalf("Times of RepositoryMock.GetUserRoles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserRoles.expectedInvocations, n)
	mmGetUserRoles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserRoles
}

func (mmGetUserRoles *mRepositoryMockGetUserRoles) invocationsDone() bool {
	if len(mmGetUserRoles.expectations) == 0 && mmGetUserRoles.defaultExpectation == nil && mmGetUserRoles.mock.funcGetUserRoles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserRoles.mock.afterGetUserRolesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserRoles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserRoles implements mm_auth.Repository
func (mmGetUserRoles *RepositoryMock) GetUserRoles(ctx context.Context, userID uuid.UUID, roles []mm_auth.Role) (ua1 []mm_auth.UserRole, err error) {
	mm_atomic.AddUint64(&mmGetUserRoles.beforeGetUserRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserRoles.afterGetUserRolesCounter, 1)

	mmGetUserRoles.t.Helper()

	if mmGetUserRoles.inspectFuncGetUserRoles != nil {
		mmGetUserRoles.inspectFuncGetUserRoles(ctx, userID, roles)
	}

	mm_params := RepositoryMockGetUserRolesParams{ctx, userID, roles}

	// Record call args
	mmGetUserRoles.GetUserRolesMock.mutex.Lock()
	mmGetUserRoles.GetUserRolesMock.callArgs = append(mmGetUserRoles.GetUserRolesMock.callArgs, &mm_params)
	mmGetUserRoles.GetUserRolesMock.mutex.Unlock()

	for _, e := range mmGetUserRoles.GetUserRolesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetUserRoles.GetUserRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserRoles.GetUserRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserRoles.GetUserRolesMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserRoles.GetUserRolesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetUserRolesParams{ctx, userID, roles}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserRoles.t.Errorf("RepositoryMock.GetUserRoles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserRoles.GetUserRolesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetUserRoles.t.Errorf("RepositoryMock.GetUserRoles got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserRoles.GetUserRolesMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.roles != nil && !minimock.Equal(*mm_want_ptrs.roles, mm_got.roles) {
				mmGetUserRoles.t.Errorf("RepositoryMock.GetUserRoles got unexpected parameter roles, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserRoles.GetUserRolesMock.defaultExpectation.expectationOrigins.originRoles, *mm_want_ptrs.roles, mm_got.roles, minimock.Diff(*mm_want_ptrs.roles, mm_got.roles))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserRoles.t.Errorf("RepositoryMock.GetUserRoles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserRoles.GetUserRolesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserRoles.GetUserRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserRoles.t.Fatal("No results are set for the RepositoryMock.GetUserRoles")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetUserRoles.funcGetUserRoles != nil {
		return mmGetUserRoles.funcGetUserRoles(ctx, userID, roles)
	}
	mmGetUserRoles.t.Fatalf("Unexpected call to RepositoryMock.GetUserRoles. %v %v %v", ctx, userID, roles)
	return
}

// GetUserRolesAfterCounter returns a count of finished RepositoryMock.GetUserRoles invocations
func (mmGetUserRoles *RepositoryMock) GetUserRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserRoles.afterGetUserRolesCounter)
}

// GetUserRolesBeforeCounter returns a count of RepositoryMock.GetUserRoles invocations
func (mmGetUserRoles *RepositoryMock) GetUserRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserRoles.beforeGetUserRolesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserRoles *mRepositoryMockGetUserRoles) Calls() []*RepositoryMockGetUserRolesParams {
	mmGetUserRoles.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserRolesParams, len(mmGetUserRoles.callArgs))
	copy(argCopy, mmGetUserRoles.callArgs)

	mmGetUserRoles.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserRolesDone returns true if the count of the GetUserRoles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserRolesDone() bool {
	if m.GetUserRolesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserRolesMock.invocationsDone()
}

// MinimockGetUserRolesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserRolesInspect() {
	for _, e := range m.GetUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserRoles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserRolesCounter := mm_atomic.LoadUint64(&m.afterGetUserRolesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserRolesMock.defaultExpectation != nil && afterGetUserRolesCounter < 1 {
		if m.GetUserRolesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetUserRoles at\n%s", m.GetUserRolesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserRoles at\n%s with params: %#v", m.GetUserRolesMock.defaultExpectation.expectationOrigins.origin, *m.GetUserRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserRoles != nil && afterGetUserRolesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetUserRoles at\n%s", m.funcGetUserRolesOrigin)
	}

	if !m.GetUserRolesMock.invocationsDone() && afterGetUserRolesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetUserRoles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserRolesMock.expectedInvocations), m.GetUserRolesMock.expectedInvocationsOrigin, afterGetUserRolesCounter)
	}
}

type mRepositoryMockListUserRoles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListUserRolesExpectation
	expectations       []*RepositoryMockListUserRolesExpectation

	callArgs []*RepositoryMockListUserRolesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListUserRolesExpectation specifies expectation struct of the Repository.ListUserRoles
type RepositoryMockListUserRolesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListUserRolesParams
	paramPtrs          *RepositoryMockListUserRolesParamPtrs
	expectationOrigins RepositoryMockListUserRolesExpectationOrigins
	results            *RepositoryMockListUserRolesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListUserRolesParams contains parameters of the Repository.ListUserRoles
type RepositoryMockListUserRolesParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// RepositoryMockListUserRolesParamPtrs contains pointers to parameters of the Repository.ListUserRoles
type RepositoryMockListUserRolesParamPtrs struct {
	ctx    *context.Context
	userID *uuid.UUID
}

// RepositoryMockListUserRolesResults contains results of the Repository.ListUserRoles
type RepositoryMockListUserRolesResults struct {
	ua1 []mm_auth.UserRole
	err error
}

// RepositoryMockListUserRolesOrigins contains origins of expectations of the Repository.ListUserRoles
type RepositoryMockListUserRolesExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserRoles *mRepositoryMockListUserRoles) Optional() *mRepositoryMockListUserRoles {
	mmListUserRoles.optional = true
	return mmListUserRoles
}

// Expect sets up expected params for Repository.ListUserRoles
func (mmListUserRoles *mRepositoryMockListUserRoles) Expect(ctx context.Context, userID uuid.UUID) *mRepositoryMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &RepositoryMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.paramPtrs != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by ExpectParams functions")
	}

	mmListUserRoles.defaultExpectation.params = &RepositoryMockListUserRolesParams{ctx, userID}
	mmListUserRoles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListUserRoles.expectations {
		if minimock.Equal(e.params, mmListUserRoles.defaultExpectation.params) {
			mmListUserRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserRoles.defaultExpectation.params)
		}
	}

	return mmListUserRoles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListUserRoles
func (mmListUserRoles *mRepositoryMockListUserRoles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &RepositoryMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.params != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Expect")
	}

	if mmListUserRoles.defaultExpectation.paramPtrs == nil {
		mmListUserRoles.defaultExpectation.paramPtrs = &RepositoryMockListUserRolesParamPtrs{}
	}
	mmListUserRoles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListUserRoles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListUserRoles
}

// ExpectUserIDParam2 sets up expected param userID for Repository.ListUserRoles
func (mmListUserRoles *mRepositoryMockListUserRoles) ExpectUserIDParam2(userID uuid.UUID) *mRepositoryMockListUserRoles {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &RepositoryMockListUserRolesExpectation{}
	}

	if mmListUserRoles.defaultExpectation.params != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Expect")
	}

	if mmListUserRoles.defaultExpectation.paramPtrs == nil {
		mmListUserRoles.defaultExpectation.paramPtrs = &RepositoryMockListUserRolesParamPtrs{}
	}
	mmListUserRoles.defaultExpectation.paramPtrs.userID = &userID
	mmListUserRoles.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListUserRoles
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListUserRoles
func (mmListUserRoles *mRepositoryMockListUserRoles) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mRepositoryMockListUserRoles {
	if mmListUserRoles.mock.inspectFuncListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListUserRoles")
	}

	mmListUserRoles.mock.inspectFuncListUserRoles = f

	return mmListUserRoles
}

// Return sets up results that will be returned by Repository.ListUserRoles
func (mmListUserRoles *mRepositoryMockListUserRoles) Return(ua1 []mm_auth.UserRole, err error) *RepositoryMock {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Set")
	}

	if mmListUserRoles.defaultExpectation == nil {
		mmListUserRoles.defaultExpectation = &RepositoryMockListUserRolesExpectation{mock: mmListUserRoles.mock}
	}
	mmListUserRoles.defaultExpectation.results = &RepositoryMockListUserRolesResults{ua1, err}
	mmListUserRoles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListUserRoles.mock
}

// Set uses given function f to mock the Repository.ListUserRoles method
func (mmListUserRoles *mRepositoryMockListUserRoles) Set(f func(ctx context.Context, userID uuid.UUID) (ua1 []mm_auth.UserRole, err error)) *RepositoryMock {
	if mmListUserRoles.defaultExpectation != nil {
		mmListUserRoles.mock.t.Fatalf("Default expectation is already set for the Repository.ListUserRoles method")
	}

	if len(mmListUserRoles.expectations) > 0 {
		mmListUserRoles.mock.t.Fatalf("Some expectations are already set for the Repository.ListUserRoles method")
	}

	mmListUserRoles.mock.funcListUserRoles = f
	mmListUserRoles.mock.funcListUserRolesOrigin = minimock.CallerInfo(1)
	return mmListUserRoles.mock
}

// When sets expectation for the Repository.ListUserRoles which will trigger the result defined by the following
// Then helper
func (mmListUserRoles *mRepositoryMockListUserRoles) When(ctx context.Context, userID uuid.UUID) *RepositoryMockListUserRolesExpectation {
	if mmListUserRoles.mock.funcListUserRoles != nil {
		mmListUserRoles.mock.t.Fatalf("RepositoryMock.ListUserRoles mock is already set by Set")
	}

	expectation := &RepositoryMockListUserRolesExpectation{
		mock:               mmListUserRoles.mock,
		params:             &RepositoryMockListUserRolesParams{ctx, userID},
		expectationOrigins: RepositoryMockListUserRolesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListUserRoles.expectations = append(mmListUserRoles.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListUserRoles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListUserRolesExpectation) Then(ua1 []mm_auth.UserRole, err error) *RepositoryMock {
	e.results = &RepositoryMockListUserRolesResults{ua1, err}
	return e.mock
}

// Times sets number of times Repository.ListUserRoles should be invoked
func (mmListUserRoles *mRepositoryMockListUserRoles) Times(n uint64) *mRepositoryMockListUserRoles {
	if n == 0 {
		mmListUserRoles.mock.t.Fatalf("Times of RepositoryMock.ListUserRoles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListUserRoles.expectedInvocations, n)
	mmListUserRoles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListUserRoles
}

func (mmListUserRoles *mRepositoryMockListUserRoles) invocationsDone() bool {
	if len(mmListUserRoles.expectations) == 0 && mmListUserRoles.defaultExpectation == nil && mmListUserRoles.mock.funcListUserRoles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListUserRoles.mock.afterListUserRolesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListUserRoles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListUserRoles implements mm_auth.Repository
func (mmListUserRoles *RepositoryMock) ListUserRoles(ctx context.Context, userID uuid.UUID) (ua1 []mm_auth.UserRole, err error) {
	mm_atomic.AddUint64(&mmListUserRoles.beforeListUserRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmListUserRoles.afterListUserRolesCounter, 1)

	mmListUserRoles.t.Helper()

	if mmListUserRoles.inspectFuncListUserRoles != nil {
		mmListUserRoles.inspectFuncListUserRoles(ctx, userID)
	}

	mm_params := RepositoryMockListUserRolesParams{ctx, userID}

	// Record call args
	mmListUserRoles.ListUserRolesMock.mutex.Lock()
	mmListUserRoles.ListUserRolesMock.callArgs = append(mmListUserRoles.ListUserRolesMock.callArgs, &mm_params)
	mmListUserRoles.ListUserRolesMock.mutex.Unlock()

	for _, e := range mmListUserRoles.ListUserRolesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListUserRoles.ListUserRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUserRoles.ListUserRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmListUserRoles.ListUserRolesMock.defaultExpectation.params
		mm_want_ptrs := mmListUserRoles.ListUserRolesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListUserRolesParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListUserRoles.t.Errorf("RepositoryMock.ListUserRoles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListUserRoles.t.Errorf("RepositoryMock.ListUserRoles got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUserRoles.t.Errorf("RepositoryMock.ListUserRoles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListUserRoles.ListUserRolesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUserRoles.ListUserRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmListUserRoles.t.Fatal("No results are set for the RepositoryMock.ListUserRoles")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListUserRoles.funcListUserRoles != nil {
		return mmListUserRoles.funcListUserRoles(ctx, userID)
	}
	mmListUserRoles.t.Fatalf("Unexpected call to RepositoryMock.ListUserRoles. %v %v", ctx, userID)
	return
}

// ListUserRolesAfterCounter returns a count of finished RepositoryMock.ListUserRoles invocations
func (mmListUserRoles *RepositoryMock) ListUserRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserRoles.afterListUserRolesCounter)
}

// ListUserRolesBeforeCounter returns a count of RepositoryMock.ListUserRoles invocations
func (mmListUserRoles *RepositoryMock) ListUserRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserRoles.beforeListUserRolesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListUserRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserRoles *mRepositoryMockListUserRoles) Calls() []*RepositoryMockListUserRolesParams {
	mmListUserRoles.mutex.RLock()

	argCopy := make([]*RepositoryMockListUserRolesParams, len(mmListUserRoles.callArgs))
	copy(argCopy, mmListUserRoles.callArgs)

	mmListUserRoles.mutex.RUnlock()

	return argCopy
}

// MinimockListUserRolesDone returns true if the count of the ListUserRoles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListUserRolesDone() bool {
	if m.ListUserRolesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListUserRolesMock.invocationsDone()
}

// MinimockListUserRolesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListUserRolesInspect() {
	for _, e := range m.ListUserRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListUserRoles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListUserRolesCounter := mm_atomic.LoadUint64(&m.afterListUserRolesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListUserRolesMock.defaultExpectation != nil && afterListUserRolesCounter < 1 {
		if m.ListUserRolesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListUserRoles at\n%s", m.ListUserRolesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListUserRoles at\n%s with params: %#v", m.ListUserRolesMock.defaultExpectation.expectationOrigins.origin, *m.ListUserRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUserRoles != nil && afterListUserRolesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListUserRoles at\n%s", m.funcListUserRolesOrigin)
	}

	if !m.ListUserRolesMock.invocationsDone() && afterListUserRolesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListUserRoles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListUserRolesMock.expectedInvocations), m.ListUserRolesMock.expectedInvocationsOrigin, afterListUserRolesCounter)
	}
}

type mRepositoryMockUpdateRefreshToken struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateRefreshTokenExpectation
	expectations       []*RepositoryMockUpdateRefreshTokenExpectation

	callArgs []*RepositoryMockUpdateRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateRefreshTokenExpectation specifies expectation struct of the Repository.UpdateRefreshToken
type RepositoryMockUpdateRefreshTokenExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateRefreshTokenParams
	paramPtrs          *RepositoryMockUpdateRefreshTokenParamPtrs
	expectationOrigins RepositoryMockUpdateRefreshTokenExpectationOrigins
	results            *RepositoryMockUpdateRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateRefreshTokenParams contains parameters of the Repository.UpdateRefreshToken
type RepositoryMockUpdateRefreshTokenParams struct {
	ctx context.Context
	req mm_auth.UpdateTokenReq
}

// RepositoryMockUpdateRefreshTokenParamPtrs contains pointers to parameters of the Repository.UpdateRefreshToken
type RepositoryMockUpdateRefreshTokenParamPtrs struct {
	ctx *context.Context
	req *mm_auth.UpdateTokenReq
}

// RepositoryMockUpdateRefreshTokenResults contains results of the Repository.UpdateRefreshToken
type RepositoryMockUpdateRefreshTokenResults struct {
	err error
}

// RepositoryMockUpdateRefreshTokenOrigins contains origins of expectations of the Repository.UpdateRefreshToken
type RepositoryMockUpdateRefreshTokenExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Optional() *mRepositoryMockUpdateRefreshToken {
	mmUpdateRefreshToken.optional = true
	return mmUpdateRefreshToken
}

// Expect sets up expected params for Repository.UpdateRefreshToken
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Expect(ctx context.Context, req mm_auth.UpdateTokenReq) *mRepositoryMockUpdateRefreshToken {
	if mmUpdateRefreshToken.mock.funcUpdateRefreshToken != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Set")
	}

	if mmUpdateRefreshToken.defaultExpectation == nil {
		mmUpdateRefreshToken.defaultExpectation = &RepositoryMockUpdateRefreshTokenExpectation{}
	}

	if mmUpdateRefreshToken.defaultExpectation.paramPtrs != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by ExpectParams functions")
	}

	mmUpdateRefreshToken.defaultExpectation.params = &RepositoryMockUpdateRefreshTokenParams{ctx, req}
	mmUpdateRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateRefreshToken.expectations {
		if minimock.Equal(e.params, mmUpdateRefreshToken.defaultExpectation.params) {
			mmUpdateRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateRefreshToken.defaultExpectation.params)
		}
	}

	return mmUpdateRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateRefreshToken
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateRefreshToken {
	if mmUpdateRefreshToken.mock.funcUpdateRefreshToken != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Set")
	}

	if mmUpdateRefreshToken.defaultExpectation == nil {
		mmUpdateRefreshToken.defaultExpectation = &RepositoryMockUpdateRefreshTokenExpectation{}
	}

	if mmUpdateRefreshToken.defaultExpectation.params != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Expect")
	}

	if mmUpdateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmUpdateRefreshToken.defaultExpectation.paramPtrs = &RepositoryMockUpdateRefreshTokenParamPtrs{}
	}
	mmUpdateRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateRefreshToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateRefreshToken
}

// ExpectReqParam2 sets up expected param req for Repository.UpdateRefreshToken
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) ExpectReqParam2(req mm_auth.UpdateTokenReq) *mRepositoryMockUpdateRefreshToken {
	if mmUpdateRefreshToken.mock.funcUpdateRefreshToken != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Set")
	}

	if mmUpdateRefreshToken.defaultExpectation == nil {
		mmUpdateRefreshToken.defaultExpectation = &RepositoryMockUpdateRefreshTokenExpectation{}
	}

	if mmUpdateRefreshToken.defaultExpectation.params != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Expect")
	}

	if mmUpdateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmUpdateRefreshToken.defaultExpectation.paramPtrs = &RepositoryMockUpdateRefreshTokenParamPtrs{}
	}
	mmUpdateRefreshToken.defaultExpectation.paramPtrs.req = &req
	mmUpdateRefreshToken.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdateRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateRefreshToken
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Inspect(f func(ctx context.Context, req mm_auth.UpdateTokenReq)) *mRepositoryMockUpdateRefreshToken {
	if mmUpdateRefreshToken.mock.inspectFuncUpdateRefreshToken != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateRefreshToken")
	}

	mmUpdateRefreshToken.mock.inspectFuncUpdateRefreshToken = f

	return mmUpdateRefreshToken
}

// Return sets up results that will be returned by Repository.UpdateRefreshToken
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Return(err error) *RepositoryMock {
	if mmUpdateRefreshToken.mock.funcUpdateRefreshToken != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Set")
	}

	if mmUpdateRefreshToken.defaultExpectation == nil {
		mmUpdateRefreshToken.defaultExpectation = &RepositoryMockUpdateRefreshTokenExpectation{mock: mmUpdateRefreshToken.mock}
	}
	mmUpdateRefreshToken.defaultExpectation.results = &RepositoryMockUpdateRefreshTokenResults{err}
	mmUpdateRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateRefreshToken.mock
}

// Set uses given function f to mock the Repository.UpdateRefreshToken method
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Set(f func(ctx context.Context, req mm_auth.UpdateTokenReq) (err error)) *RepositoryMock {
	if mmUpdateRefreshToken.defaultExpectation != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateRefreshToken method")
	}

	if len(mmUpdateRefreshToken.expectations) > 0 {
		mmUpdateRefreshToken.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateRefreshToken method")
	}

	mmUpdateRefreshToken.mock.funcUpdateRefreshToken = f
	mmUpdateRefreshToken.mock.funcUpdateRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmUpdateRefreshToken.mock
}

// When sets expectation for the Repository.UpdateRefreshToken which will trigger the result defined by the following
// Then helper
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) When(ctx context.Context, req mm_auth.UpdateTokenReq) *RepositoryMockUpdateRefreshTokenExpectation {
	if mmUpdateRefreshToken.mock.funcUpdateRefreshToken != nil {
		mmUpdateRefreshToken.mock.t.Fatalf("RepositoryMock.UpdateRefreshToken mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateRefreshTokenExpectation{
		mock:               mmUpdateRefreshToken.mock,
		params:             &RepositoryMockUpdateRefreshTokenParams{ctx, req},
		expectationOrigins: RepositoryMockUpdateRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateRefreshToken.expectations = append(mmUpdateRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateRefreshToken return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateRefreshTokenExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateRefreshTokenResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateRefreshToken should be invoked
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Times(n uint64) *mRepositoryMockUpdateRefreshToken {
	if n == 0 {
		mmUpdateRefreshToken.mock.t.Fatalf("Times of RepositoryMock.UpdateRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateRefreshToken.expectedInvocations, n)
	mmUpdateRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateRefreshToken
}

func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) invocationsDone() bool {
	if len(mmUpdateRefreshToken.expectations) == 0 && mmUpdateRefreshToken.defaultExpectation == nil && mmUpdateRefreshToken.mock.funcUpdateRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateRefreshToken.mock.afterUpdateRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateRefreshToken implements mm_auth.Repository
func (mmUpdateRefreshToken *RepositoryMock) UpdateRefreshToken(ctx context.Context, req mm_auth.UpdateTokenReq) (err error) {
	mm_atomic.AddUint64(&mmUpdateRefreshToken.beforeUpdateRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateRefreshToken.afterUpdateRefreshTokenCounter, 1)

	mmUpdateRefreshToken.t.Helper()

	if mmUpdateRefreshToken.inspectFuncUpdateRefreshToken != nil {
		mmUpdateRefreshToken.inspectFuncUpdateRefreshToken(ctx, req)
	}

	mm_params := RepositoryMockUpdateRefreshTokenParams{ctx, req}

	// Record call args
	mmUpdateRefreshToken.UpdateRefreshTokenMock.mutex.Lock()
	mmUpdateRefreshToken.UpdateRefreshTokenMock.callArgs = append(mmUpdateRefreshToken.UpdateRefreshTokenMock.callArgs, &mm_params)
	mmUpdateRefreshToken.UpdateRefreshTokenMock.mutex.Unlock()

	for _, e := range mmUpdateRefreshToken.UpdateRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateRefreshTokenParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateRefreshToken.t.Errorf("RepositoryMock.UpdateRefreshToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdateRefreshToken.t.Errorf("RepositoryMock.UpdateRefreshToken got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateRefreshToken.t.Errorf("RepositoryMock.UpdateRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateRefreshToken.UpdateRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateRefreshToken.t.Fatal("No results are set for the RepositoryMock.UpdateRefreshToken")
		}
		return (*mm_results).err
	}
	if mmUpdateRefreshToken.funcUpdateRefreshToken != nil {
		return mmUpdateRefreshToken.funcUpdateRefreshToken(ctx, req)
	}
	mmUpdateRefreshToken.t.Fatalf("Unexpected call to RepositoryMock.UpdateRefreshToken. %v %v", ctx, req)
	return
}

// UpdateRefreshTokenAfterCounter returns a count of finished RepositoryMock.UpdateRefreshToken invocations
func (mmUpdateRefreshToken *RepositoryMock) UpdateRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRefreshToken.afterUpdateRefreshTokenCounter)
}

// UpdateRefreshTokenBeforeCounter returns a count of RepositoryMock.UpdateRefreshToken invocations
func (mmUpdateRefreshToken *RepositoryMock) UpdateRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRefreshToken.beforeUpdateRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateRefreshToken *mRepositoryMockUpdateRefreshToken) Calls() []*RepositoryMockUpdateRefreshTokenParams {
	mmUpdateRefreshToken.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateRefreshTokenParams, len(mmUpdateRefreshToken.callArgs))
	copy(argCopy, mmUpdateRefreshToken.callArgs)

	mmUpdateRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateRefreshTokenDone returns true if the count of the UpdateRefreshToken invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateRefreshTokenDone() bool {
	if m.UpdateRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateRefreshTokenMock.invocationsDone()
}

// MinimockUpdateRefreshTokenInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateRefreshTokenInspect() {
	for _, e := range m.UpdateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterUpdateRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateRefreshTokenMock.defaultExpectation != nil && afterUpdateRefreshTokenCounter < 1 {
		if m.UpdateRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateRefreshToken at\n%s", m.UpdateRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateRefreshToken at\n%s with params: %#v", m.UpdateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.UpdateRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateRefreshToken != nil && afterUpdateRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateRefreshToken at\n%s", m.funcUpdateRefreshTokenOrigin)
	}

	if !m.UpdateRefreshTokenMock.invocationsDone() && afterUpdateRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateRefreshTokenMock.expectedInvocations), m.UpdateRefreshTokenMock.expectedInvocationsOrigin, afterUpdateRefreshTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUserRoleInspect()

			m.MinimockCreateSessionInspect()

			m.MinimockDeleteSessionByIDInspect()

			m.MinimockDeleteSessionByIDAndUserInspect()

			m.MinimockDeleteSessionsByUserIDInspect()

			m.MinimockDeleteUserRoleInspect()

			m.MinimockGetSessionByIDInspect()

			m.MinimockGetSessionsByUserIDInspect()

			m.MinimockGetUserRolesInspect()

			m.MinimockListUserRolesInspect()

			m.MinimockUpdateRefreshTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUserRoleDone() &&
		m.MinimockCreateSessionDone() &&
		m.MinimockDeleteSessionByIDDone() &&
		m.MinimockDeleteSessionByIDAndUserDone() &&
		m.MinimockDeleteSessionsByUserIDDone() &&
		m.MinimockDeleteUserRoleDone() &&
		m.MinimockGetSessionByIDDone() &&
		m.MinimockGetSessionsByUserIDDone() &&
		m.MinimockGetUserRolesDone() &&
		m.MinimockListUserRolesDone() &&
		m.MinimockUpdateRefreshTokenDone()
}
