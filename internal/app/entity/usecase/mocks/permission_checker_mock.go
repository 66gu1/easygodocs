// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/entity/usecase.PermissionChecker -o permission_checker_mock.go -n PermissionCheckerMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/auth"
	mm_usecase "github.com/66gu1/easygodocs/internal/app/entity/usecase"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// PermissionCheckerMock implements mm_usecase.PermissionChecker
type PermissionCheckerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckEntityPermission          func(ctx context.Context, id uuid.UUID, role auth.Role) (err error)
	funcCheckEntityPermissionOrigin    string
	inspectFuncCheckEntityPermission   func(ctx context.Context, id uuid.UUID, role auth.Role)
	afterCheckEntityPermissionCounter  uint64
	beforeCheckEntityPermissionCounter uint64
	CheckEntityPermissionMock          mPermissionCheckerMockCheckEntityPermission

	funcGetDirectPermissions          func(ctx context.Context, role auth.Role) (ua1 []uuid.UUID, b1 bool, err error)
	funcGetDirectPermissionsOrigin    string
	inspectFuncGetDirectPermissions   func(ctx context.Context, role auth.Role)
	afterGetDirectPermissionsCounter  uint64
	beforeGetDirectPermissionsCounter uint64
	GetDirectPermissionsMock          mPermissionCheckerMockGetDirectPermissions

	funcGetEffectivePermissions          func(ctx context.Context, role auth.Role) (e1 mm_usecase.EffectivePermissions, err error)
	funcGetEffectivePermissionsOrigin    string
	inspectFuncGetEffectivePermissions   func(ctx context.Context, role auth.Role)
	afterGetEffectivePermissionsCounter  uint64
	beforeGetEffectivePermissionsCounter uint64
	GetEffectivePermissionsMock          mPermissionCheckerMockGetEffectivePermissions
}

// NewPermissionCheckerMock returns a mock for mm_usecase.PermissionChecker
func NewPermissionCheckerMock(t minimock.Tester) *PermissionCheckerMock {
	m := &PermissionCheckerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckEntityPermissionMock = mPermissionCheckerMockCheckEntityPermission{mock: m}
	m.CheckEntityPermissionMock.callArgs = []*PermissionCheckerMockCheckEntityPermissionParams{}

	m.GetDirectPermissionsMock = mPermissionCheckerMockGetDirectPermissions{mock: m}
	m.GetDirectPermissionsMock.callArgs = []*PermissionCheckerMockGetDirectPermissionsParams{}

	m.GetEffectivePermissionsMock = mPermissionCheckerMockGetEffectivePermissions{mock: m}
	m.GetEffectivePermissionsMock.callArgs = []*PermissionCheckerMockGetEffectivePermissionsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPermissionCheckerMockCheckEntityPermission struct {
	optional           bool
	mock               *PermissionCheckerMock
	defaultExpectation *PermissionCheckerMockCheckEntityPermissionExpectation
	expectations       []*PermissionCheckerMockCheckEntityPermissionExpectation

	callArgs []*PermissionCheckerMockCheckEntityPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PermissionCheckerMockCheckEntityPermissionExpectation specifies expectation struct of the PermissionChecker.CheckEntityPermission
type PermissionCheckerMockCheckEntityPermissionExpectation struct {
	mock               *PermissionCheckerMock
	params             *PermissionCheckerMockCheckEntityPermissionParams
	paramPtrs          *PermissionCheckerMockCheckEntityPermissionParamPtrs
	expectationOrigins PermissionCheckerMockCheckEntityPermissionExpectationOrigins
	results            *PermissionCheckerMockCheckEntityPermissionResults
	returnOrigin       string
	Counter            uint64
}

// PermissionCheckerMockCheckEntityPermissionParams contains parameters of the PermissionChecker.CheckEntityPermission
type PermissionCheckerMockCheckEntityPermissionParams struct {
	ctx  context.Context
	id   uuid.UUID
	role auth.Role
}

// PermissionCheckerMockCheckEntityPermissionParamPtrs contains pointers to parameters of the PermissionChecker.CheckEntityPermission
type PermissionCheckerMockCheckEntityPermissionParamPtrs struct {
	ctx  *context.Context
	id   *uuid.UUID
	role *auth.Role
}

// PermissionCheckerMockCheckEntityPermissionResults contains results of the PermissionChecker.CheckEntityPermission
type PermissionCheckerMockCheckEntityPermissionResults struct {
	err error
}

// PermissionCheckerMockCheckEntityPermissionOrigins contains origins of expectations of the PermissionChecker.CheckEntityPermission
type PermissionCheckerMockCheckEntityPermissionExpectationOrigins struct {
	origin     string
	originCtx  string
	originId   string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Optional() *mPermissionCheckerMockCheckEntityPermission {
	mmCheckEntityPermission.optional = true
	return mmCheckEntityPermission
}

// Expect sets up expected params for PermissionChecker.CheckEntityPermission
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Expect(ctx context.Context, id uuid.UUID, role auth.Role) *mPermissionCheckerMockCheckEntityPermission {
	if mmCheckEntityPermission.mock.funcCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Set")
	}

	if mmCheckEntityPermission.defaultExpectation == nil {
		mmCheckEntityPermission.defaultExpectation = &PermissionCheckerMockCheckEntityPermissionExpectation{}
	}

	if mmCheckEntityPermission.defaultExpectation.paramPtrs != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by ExpectParams functions")
	}

	mmCheckEntityPermission.defaultExpectation.params = &PermissionCheckerMockCheckEntityPermissionParams{ctx, id, role}
	mmCheckEntityPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckEntityPermission.expectations {
		if minimock.Equal(e.params, mmCheckEntityPermission.defaultExpectation.params) {
			mmCheckEntityPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckEntityPermission.defaultExpectation.params)
		}
	}

	return mmCheckEntityPermission
}

// ExpectCtxParam1 sets up expected param ctx for PermissionChecker.CheckEntityPermission
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) ExpectCtxParam1(ctx context.Context) *mPermissionCheckerMockCheckEntityPermission {
	if mmCheckEntityPermission.mock.funcCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Set")
	}

	if mmCheckEntityPermission.defaultExpectation == nil {
		mmCheckEntityPermission.defaultExpectation = &PermissionCheckerMockCheckEntityPermissionExpectation{}
	}

	if mmCheckEntityPermission.defaultExpectation.params != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Expect")
	}

	if mmCheckEntityPermission.defaultExpectation.paramPtrs == nil {
		mmCheckEntityPermission.defaultExpectation.paramPtrs = &PermissionCheckerMockCheckEntityPermissionParamPtrs{}
	}
	mmCheckEntityPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckEntityPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckEntityPermission
}

// ExpectIdParam2 sets up expected param id for PermissionChecker.CheckEntityPermission
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) ExpectIdParam2(id uuid.UUID) *mPermissionCheckerMockCheckEntityPermission {
	if mmCheckEntityPermission.mock.funcCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Set")
	}

	if mmCheckEntityPermission.defaultExpectation == nil {
		mmCheckEntityPermission.defaultExpectation = &PermissionCheckerMockCheckEntityPermissionExpectation{}
	}

	if mmCheckEntityPermission.defaultExpectation.params != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Expect")
	}

	if mmCheckEntityPermission.defaultExpectation.paramPtrs == nil {
		mmCheckEntityPermission.defaultExpectation.paramPtrs = &PermissionCheckerMockCheckEntityPermissionParamPtrs{}
	}
	mmCheckEntityPermission.defaultExpectation.paramPtrs.id = &id
	mmCheckEntityPermission.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCheckEntityPermission
}

// ExpectRoleParam3 sets up expected param role for PermissionChecker.CheckEntityPermission
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) ExpectRoleParam3(role auth.Role) *mPermissionCheckerMockCheckEntityPermission {
	if mmCheckEntityPermission.mock.funcCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Set")
	}

	if mmCheckEntityPermission.defaultExpectation == nil {
		mmCheckEntityPermission.defaultExpectation = &PermissionCheckerMockCheckEntityPermissionExpectation{}
	}

	if mmCheckEntityPermission.defaultExpectation.params != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Expect")
	}

	if mmCheckEntityPermission.defaultExpectation.paramPtrs == nil {
		mmCheckEntityPermission.defaultExpectation.paramPtrs = &PermissionCheckerMockCheckEntityPermissionParamPtrs{}
	}
	mmCheckEntityPermission.defaultExpectation.paramPtrs.role = &role
	mmCheckEntityPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckEntityPermission
}

// Inspect accepts an inspector function that has same arguments as the PermissionChecker.CheckEntityPermission
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Inspect(f func(ctx context.Context, id uuid.UUID, role auth.Role)) *mPermissionCheckerMockCheckEntityPermission {
	if mmCheckEntityPermission.mock.inspectFuncCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("Inspect function is already set for PermissionCheckerMock.CheckEntityPermission")
	}

	mmCheckEntityPermission.mock.inspectFuncCheckEntityPermission = f

	return mmCheckEntityPermission
}

// Return sets up results that will be returned by PermissionChecker.CheckEntityPermission
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Return(err error) *PermissionCheckerMock {
	if mmCheckEntityPermission.mock.funcCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Set")
	}

	if mmCheckEntityPermission.defaultExpectation == nil {
		mmCheckEntityPermission.defaultExpectation = &PermissionCheckerMockCheckEntityPermissionExpectation{mock: mmCheckEntityPermission.mock}
	}
	mmCheckEntityPermission.defaultExpectation.results = &PermissionCheckerMockCheckEntityPermissionResults{err}
	mmCheckEntityPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckEntityPermission.mock
}

// Set uses given function f to mock the PermissionChecker.CheckEntityPermission method
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Set(f func(ctx context.Context, id uuid.UUID, role auth.Role) (err error)) *PermissionCheckerMock {
	if mmCheckEntityPermission.defaultExpectation != nil {
		mmCheckEntityPermission.mock.t.Fatalf("Default expectation is already set for the PermissionChecker.CheckEntityPermission method")
	}

	if len(mmCheckEntityPermission.expectations) > 0 {
		mmCheckEntityPermission.mock.t.Fatalf("Some expectations are already set for the PermissionChecker.CheckEntityPermission method")
	}

	mmCheckEntityPermission.mock.funcCheckEntityPermission = f
	mmCheckEntityPermission.mock.funcCheckEntityPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckEntityPermission.mock
}

// When sets expectation for the PermissionChecker.CheckEntityPermission which will trigger the result defined by the following
// Then helper
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) When(ctx context.Context, id uuid.UUID, role auth.Role) *PermissionCheckerMockCheckEntityPermissionExpectation {
	if mmCheckEntityPermission.mock.funcCheckEntityPermission != nil {
		mmCheckEntityPermission.mock.t.Fatalf("PermissionCheckerMock.CheckEntityPermission mock is already set by Set")
	}

	expectation := &PermissionCheckerMockCheckEntityPermissionExpectation{
		mock:               mmCheckEntityPermission.mock,
		params:             &PermissionCheckerMockCheckEntityPermissionParams{ctx, id, role},
		expectationOrigins: PermissionCheckerMockCheckEntityPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckEntityPermission.expectations = append(mmCheckEntityPermission.expectations, expectation)
	return expectation
}

// Then sets up PermissionChecker.CheckEntityPermission return parameters for the expectation previously defined by the When method
func (e *PermissionCheckerMockCheckEntityPermissionExpectation) Then(err error) *PermissionCheckerMock {
	e.results = &PermissionCheckerMockCheckEntityPermissionResults{err}
	return e.mock
}

// Times sets number of times PermissionChecker.CheckEntityPermission should be invoked
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Times(n uint64) *mPermissionCheckerMockCheckEntityPermission {
	if n == 0 {
		mmCheckEntityPermission.mock.t.Fatalf("Times of PermissionCheckerMock.CheckEntityPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckEntityPermission.expectedInvocations, n)
	mmCheckEntityPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckEntityPermission
}

func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) invocationsDone() bool {
	if len(mmCheckEntityPermission.expectations) == 0 && mmCheckEntityPermission.defaultExpectation == nil && mmCheckEntityPermission.mock.funcCheckEntityPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckEntityPermission.mock.afterCheckEntityPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckEntityPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckEntityPermission implements mm_usecase.PermissionChecker
func (mmCheckEntityPermission *PermissionCheckerMock) CheckEntityPermission(ctx context.Context, id uuid.UUID, role auth.Role) (err error) {
	mm_atomic.AddUint64(&mmCheckEntityPermission.beforeCheckEntityPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckEntityPermission.afterCheckEntityPermissionCounter, 1)

	mmCheckEntityPermission.t.Helper()

	if mmCheckEntityPermission.inspectFuncCheckEntityPermission != nil {
		mmCheckEntityPermission.inspectFuncCheckEntityPermission(ctx, id, role)
	}

	mm_params := PermissionCheckerMockCheckEntityPermissionParams{ctx, id, role}

	// Record call args
	mmCheckEntityPermission.CheckEntityPermissionMock.mutex.Lock()
	mmCheckEntityPermission.CheckEntityPermissionMock.callArgs = append(mmCheckEntityPermission.CheckEntityPermissionMock.callArgs, &mm_params)
	mmCheckEntityPermission.CheckEntityPermissionMock.mutex.Unlock()

	for _, e := range mmCheckEntityPermission.CheckEntityPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.paramPtrs

		mm_got := PermissionCheckerMockCheckEntityPermissionParams{ctx, id, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckEntityPermission.t.Errorf("PermissionCheckerMock.CheckEntityPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCheckEntityPermission.t.Errorf("PermissionCheckerMock.CheckEntityPermission got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckEntityPermission.t.Errorf("PermissionCheckerMock.CheckEntityPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckEntityPermission.t.Errorf("PermissionCheckerMock.CheckEntityPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckEntityPermission.CheckEntityPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckEntityPermission.t.Fatal("No results are set for the PermissionCheckerMock.CheckEntityPermission")
		}
		return (*mm_results).err
	}
	if mmCheckEntityPermission.funcCheckEntityPermission != nil {
		return mmCheckEntityPermission.funcCheckEntityPermission(ctx, id, role)
	}
	mmCheckEntityPermission.t.Fatalf("Unexpected call to PermissionCheckerMock.CheckEntityPermission. %v %v %v", ctx, id, role)
	return
}

// CheckEntityPermissionAfterCounter returns a count of finished PermissionCheckerMock.CheckEntityPermission invocations
func (mmCheckEntityPermission *PermissionCheckerMock) CheckEntityPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckEntityPermission.afterCheckEntityPermissionCounter)
}

// CheckEntityPermissionBeforeCounter returns a count of PermissionCheckerMock.CheckEntityPermission invocations
func (mmCheckEntityPermission *PermissionCheckerMock) CheckEntityPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckEntityPermission.beforeCheckEntityPermissionCounter)
}

// Calls returns a list of arguments used in each call to PermissionCheckerMock.CheckEntityPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckEntityPermission *mPermissionCheckerMockCheckEntityPermission) Calls() []*PermissionCheckerMockCheckEntityPermissionParams {
	mmCheckEntityPermission.mutex.RLock()

	argCopy := make([]*PermissionCheckerMockCheckEntityPermissionParams, len(mmCheckEntityPermission.callArgs))
	copy(argCopy, mmCheckEntityPermission.callArgs)

	mmCheckEntityPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckEntityPermissionDone returns true if the count of the CheckEntityPermission invocations corresponds
// the number of defined expectations
func (m *PermissionCheckerMock) MinimockCheckEntityPermissionDone() bool {
	if m.CheckEntityPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckEntityPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckEntityPermissionMock.invocationsDone()
}

// MinimockCheckEntityPermissionInspect logs each unmet expectation
func (m *PermissionCheckerMock) MinimockCheckEntityPermissionInspect() {
	for _, e := range m.CheckEntityPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PermissionCheckerMock.CheckEntityPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckEntityPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckEntityPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckEntityPermissionMock.defaultExpectation != nil && afterCheckEntityPermissionCounter < 1 {
		if m.CheckEntityPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PermissionCheckerMock.CheckEntityPermission at\n%s", m.CheckEntityPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PermissionCheckerMock.CheckEntityPermission at\n%s with params: %#v", m.CheckEntityPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckEntityPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckEntityPermission != nil && afterCheckEntityPermissionCounter < 1 {
		m.t.Errorf("Expected call to PermissionCheckerMock.CheckEntityPermission at\n%s", m.funcCheckEntityPermissionOrigin)
	}

	if !m.CheckEntityPermissionMock.invocationsDone() && afterCheckEntityPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to PermissionCheckerMock.CheckEntityPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckEntityPermissionMock.expectedInvocations), m.CheckEntityPermissionMock.expectedInvocationsOrigin, afterCheckEntityPermissionCounter)
	}
}

type mPermissionCheckerMockGetDirectPermissions struct {
	optional           bool
	mock               *PermissionCheckerMock
	defaultExpectation *PermissionCheckerMockGetDirectPermissionsExpectation
	expectations       []*PermissionCheckerMockGetDirectPermissionsExpectation

	callArgs []*PermissionCheckerMockGetDirectPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PermissionCheckerMockGetDirectPermissionsExpectation specifies expectation struct of the PermissionChecker.GetDirectPermissions
type PermissionCheckerMockGetDirectPermissionsExpectation struct {
	mock               *PermissionCheckerMock
	params             *PermissionCheckerMockGetDirectPermissionsParams
	paramPtrs          *PermissionCheckerMockGetDirectPermissionsParamPtrs
	expectationOrigins PermissionCheckerMockGetDirectPermissionsExpectationOrigins
	results            *PermissionCheckerMockGetDirectPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// PermissionCheckerMockGetDirectPermissionsParams contains parameters of the PermissionChecker.GetDirectPermissions
type PermissionCheckerMockGetDirectPermissionsParams struct {
	ctx  context.Context
	role auth.Role
}

// PermissionCheckerMockGetDirectPermissionsParamPtrs contains pointers to parameters of the PermissionChecker.GetDirectPermissions
type PermissionCheckerMockGetDirectPermissionsParamPtrs struct {
	ctx  *context.Context
	role *auth.Role
}

// PermissionCheckerMockGetDirectPermissionsResults contains results of the PermissionChecker.GetDirectPermissions
type PermissionCheckerMockGetDirectPermissionsResults struct {
	ua1 []uuid.UUID
	b1  bool
	err error
}

// PermissionCheckerMockGetDirectPermissionsOrigins contains origins of expectations of the PermissionChecker.GetDirectPermissions
type PermissionCheckerMockGetDirectPermissionsExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Optional() *mPermissionCheckerMockGetDirectPermissions {
	mmGetDirectPermissions.optional = true
	return mmGetDirectPermissions
}

// Expect sets up expected params for PermissionChecker.GetDirectPermissions
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Expect(ctx context.Context, role auth.Role) *mPermissionCheckerMockGetDirectPermissions {
	if mmGetDirectPermissions.mock.funcGetDirectPermissions != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Set")
	}

	if mmGetDirectPermissions.defaultExpectation == nil {
		mmGetDirectPermissions.defaultExpectation = &PermissionCheckerMockGetDirectPermissionsExpectation{}
	}

	if mmGetDirectPermissions.defaultExpectation.paramPtrs != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by ExpectParams functions")
	}

	mmGetDirectPermissions.defaultExpectation.params = &PermissionCheckerMockGetDirectPermissionsParams{ctx, role}
	mmGetDirectPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDirectPermissions.expectations {
		if minimock.Equal(e.params, mmGetDirectPermissions.defaultExpectation.params) {
			mmGetDirectPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDirectPermissions.defaultExpectation.params)
		}
	}

	return mmGetDirectPermissions
}

// ExpectCtxParam1 sets up expected param ctx for PermissionChecker.GetDirectPermissions
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) ExpectCtxParam1(ctx context.Context) *mPermissionCheckerMockGetDirectPermissions {
	if mmGetDirectPermissions.mock.funcGetDirectPermissions != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Set")
	}

	if mmGetDirectPermissions.defaultExpectation == nil {
		mmGetDirectPermissions.defaultExpectation = &PermissionCheckerMockGetDirectPermissionsExpectation{}
	}

	if mmGetDirectPermissions.defaultExpectation.params != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Expect")
	}

	if mmGetDirectPermissions.defaultExpectation.paramPtrs == nil {
		mmGetDirectPermissions.defaultExpectation.paramPtrs = &PermissionCheckerMockGetDirectPermissionsParamPtrs{}
	}
	mmGetDirectPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDirectPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDirectPermissions
}

// ExpectRoleParam2 sets up expected param role for PermissionChecker.GetDirectPermissions
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) ExpectRoleParam2(role auth.Role) *mPermissionCheckerMockGetDirectPermissions {
	if mmGetDirectPermissions.mock.funcGetDirectPermissions != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Set")
	}

	if mmGetDirectPermissions.defaultExpectation == nil {
		mmGetDirectPermissions.defaultExpectation = &PermissionCheckerMockGetDirectPermissionsExpectation{}
	}

	if mmGetDirectPermissions.defaultExpectation.params != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Expect")
	}

	if mmGetDirectPermissions.defaultExpectation.paramPtrs == nil {
		mmGetDirectPermissions.defaultExpectation.paramPtrs = &PermissionCheckerMockGetDirectPermissionsParamPtrs{}
	}
	mmGetDirectPermissions.defaultExpectation.paramPtrs.role = &role
	mmGetDirectPermissions.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmGetDirectPermissions
}

// Inspect accepts an inspector function that has same arguments as the PermissionChecker.GetDirectPermissions
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Inspect(f func(ctx context.Context, role auth.Role)) *mPermissionCheckerMockGetDirectPermissions {
	if mmGetDirectPermissions.mock.inspectFuncGetDirectPermissions != nil {
		mmGetDirectPermissions.mock.t.Fatalf("Inspect function is already set for PermissionCheckerMock.GetDirectPermissions")
	}

	mmGetDirectPermissions.mock.inspectFuncGetDirectPermissions = f

	return mmGetDirectPermissions
}

// Return sets up results that will be returned by PermissionChecker.GetDirectPermissions
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Return(ua1 []uuid.UUID, b1 bool, err error) *PermissionCheckerMock {
	if mmGetDirectPermissions.mock.funcGetDirectPermissions != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Set")
	}

	if mmGetDirectPermissions.defaultExpectation == nil {
		mmGetDirectPermissions.defaultExpectation = &PermissionCheckerMockGetDirectPermissionsExpectation{mock: mmGetDirectPermissions.mock}
	}
	mmGetDirectPermissions.defaultExpectation.results = &PermissionCheckerMockGetDirectPermissionsResults{ua1, b1, err}
	mmGetDirectPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDirectPermissions.mock
}

// Set uses given function f to mock the PermissionChecker.GetDirectPermissions method
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Set(f func(ctx context.Context, role auth.Role) (ua1 []uuid.UUID, b1 bool, err error)) *PermissionCheckerMock {
	if mmGetDirectPermissions.defaultExpectation != nil {
		mmGetDirectPermissions.mock.t.Fatalf("Default expectation is already set for the PermissionChecker.GetDirectPermissions method")
	}

	if len(mmGetDirectPermissions.expectations) > 0 {
		mmGetDirectPermissions.mock.t.Fatalf("Some expectations are already set for the PermissionChecker.GetDirectPermissions method")
	}

	mmGetDirectPermissions.mock.funcGetDirectPermissions = f
	mmGetDirectPermissions.mock.funcGetDirectPermissionsOrigin = minimock.CallerInfo(1)
	return mmGetDirectPermissions.mock
}

// When sets expectation for the PermissionChecker.GetDirectPermissions which will trigger the result defined by the following
// Then helper
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) When(ctx context.Context, role auth.Role) *PermissionCheckerMockGetDirectPermissionsExpectation {
	if mmGetDirectPermissions.mock.funcGetDirectPermissions != nil {
		mmGetDirectPermissions.mock.t.Fatalf("PermissionCheckerMock.GetDirectPermissions mock is already set by Set")
	}

	expectation := &PermissionCheckerMockGetDirectPermissionsExpectation{
		mock:               mmGetDirectPermissions.mock,
		params:             &PermissionCheckerMockGetDirectPermissionsParams{ctx, role},
		expectationOrigins: PermissionCheckerMockGetDirectPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDirectPermissions.expectations = append(mmGetDirectPermissions.expectations, expectation)
	return expectation
}

// Then sets up PermissionChecker.GetDirectPermissions return parameters for the expectation previously defined by the When method
func (e *PermissionCheckerMockGetDirectPermissionsExpectation) Then(ua1 []uuid.UUID, b1 bool, err error) *PermissionCheckerMock {
	e.results = &PermissionCheckerMockGetDirectPermissionsResults{ua1, b1, err}
	return e.mock
}

// Times sets number of times PermissionChecker.GetDirectPermissions should be invoked
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Times(n uint64) *mPermissionCheckerMockGetDirectPermissions {
	if n == 0 {
		mmGetDirectPermissions.mock.t.Fatalf("Times of PermissionCheckerMock.GetDirectPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDirectPermissions.expectedInvocations, n)
	mmGetDirectPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDirectPermissions
}

func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) invocationsDone() bool {
	if len(mmGetDirectPermissions.expectations) == 0 && mmGetDirectPermissions.defaultExpectation == nil && mmGetDirectPermissions.mock.funcGetDirectPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDirectPermissions.mock.afterGetDirectPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDirectPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDirectPermissions implements mm_usecase.PermissionChecker
func (mmGetDirectPermissions *PermissionCheckerMock) GetDirectPermissions(ctx context.Context, role auth.Role) (ua1 []uuid.UUID, b1 bool, err error) {
	mm_atomic.AddUint64(&mmGetDirectPermissions.beforeGetDirectPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDirectPermissions.afterGetDirectPermissionsCounter, 1)

	mmGetDirectPermissions.t.Helper()

	if mmGetDirectPermissions.inspectFuncGetDirectPermissions != nil {
		mmGetDirectPermissions.inspectFuncGetDirectPermissions(ctx, role)
	}

	mm_params := PermissionCheckerMockGetDirectPermissionsParams{ctx, role}

	// Record call args
	mmGetDirectPermissions.GetDirectPermissionsMock.mutex.Lock()
	mmGetDirectPermissions.GetDirectPermissionsMock.callArgs = append(mmGetDirectPermissions.GetDirectPermissionsMock.callArgs, &mm_params)
	mmGetDirectPermissions.GetDirectPermissionsMock.mutex.Unlock()

	for _, e := range mmGetDirectPermissions.GetDirectPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.b1, e.results.err
		}
	}

	if mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.paramPtrs

		mm_got := PermissionCheckerMockGetDirectPermissionsParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDirectPermissions.t.Errorf("PermissionCheckerMock.GetDirectPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmGetDirectPermissions.t.Errorf("PermissionCheckerMock.GetDirectPermissions got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDirectPermissions.t.Errorf("PermissionCheckerMock.GetDirectPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDirectPermissions.GetDirectPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDirectPermissions.t.Fatal("No results are set for the PermissionCheckerMock.GetDirectPermissions")
		}
		return (*mm_results).ua1, (*mm_results).b1, (*mm_results).err
	}
	if mmGetDirectPermissions.funcGetDirectPermissions != nil {
		return mmGetDirectPermissions.funcGetDirectPermissions(ctx, role)
	}
	mmGetDirectPermissions.t.Fatalf("Unexpected call to PermissionCheckerMock.GetDirectPermissions. %v %v", ctx, role)
	return
}

// GetDirectPermissionsAfterCounter returns a count of finished PermissionCheckerMock.GetDirectPermissions invocations
func (mmGetDirectPermissions *PermissionCheckerMock) GetDirectPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDirectPermissions.afterGetDirectPermissionsCounter)
}

// GetDirectPermissionsBeforeCounter returns a count of PermissionCheckerMock.GetDirectPermissions invocations
func (mmGetDirectPermissions *PermissionCheckerMock) GetDirectPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDirectPermissions.beforeGetDirectPermissionsCounter)
}

// Calls returns a list of arguments used in each call to PermissionCheckerMock.GetDirectPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDirectPermissions *mPermissionCheckerMockGetDirectPermissions) Calls() []*PermissionCheckerMockGetDirectPermissionsParams {
	mmGetDirectPermissions.mutex.RLock()

	argCopy := make([]*PermissionCheckerMockGetDirectPermissionsParams, len(mmGetDirectPermissions.callArgs))
	copy(argCopy, mmGetDirectPermissions.callArgs)

	mmGetDirectPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockGetDirectPermissionsDone returns true if the count of the GetDirectPermissions invocations corresponds
// the number of defined expectations
func (m *PermissionCheckerMock) MinimockGetDirectPermissionsDone() bool {
	if m.GetDirectPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDirectPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDirectPermissionsMock.invocationsDone()
}

// MinimockGetDirectPermissionsInspect logs each unmet expectation
func (m *PermissionCheckerMock) MinimockGetDirectPermissionsInspect() {
	for _, e := range m.GetDirectPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PermissionCheckerMock.GetDirectPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDirectPermissionsCounter := mm_atomic.LoadUint64(&m.afterGetDirectPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDirectPermissionsMock.defaultExpectation != nil && afterGetDirectPermissionsCounter < 1 {
		if m.GetDirectPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PermissionCheckerMock.GetDirectPermissions at\n%s", m.GetDirectPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PermissionCheckerMock.GetDirectPermissions at\n%s with params: %#v", m.GetDirectPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.GetDirectPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDirectPermissions != nil && afterGetDirectPermissionsCounter < 1 {
		m.t.Errorf("Expected call to PermissionCheckerMock.GetDirectPermissions at\n%s", m.funcGetDirectPermissionsOrigin)
	}

	if !m.GetDirectPermissionsMock.invocationsDone() && afterGetDirectPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to PermissionCheckerMock.GetDirectPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDirectPermissionsMock.expectedInvocations), m.GetDirectPermissionsMock.expectedInvocationsOrigin, afterGetDirectPermissionsCounter)
	}
}

type mPermissionCheckerMockGetEffectivePermissions struct {
	optional           bool
	mock               *PermissionCheckerMock
	defaultExpectation *PermissionCheckerMockGetEffectivePermissionsExpectation
	expectations       []*PermissionCheckerMockGetEffectivePermissionsExpectation

	callArgs []*PermissionCheckerMockGetEffectivePermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PermissionCheckerMockGetEffectivePermissionsExpectation specifies expectation struct of the PermissionChecker.GetEffectivePermissions
type PermissionCheckerMockGetEffectivePermissionsExpectation struct {
	mock               *PermissionCheckerMock
	params             *PermissionCheckerMockGetEffectivePermissionsParams
	paramPtrs          *PermissionCheckerMockGetEffectivePermissionsParamPtrs
	expectationOrigins PermissionCheckerMockGetEffectivePermissionsExpectationOrigins
	results            *PermissionCheckerMockGetEffectivePermissionsResults
	returnOrigin       string
	Counter            uint64
}

// PermissionCheckerMockGetEffectivePermissionsParams contains parameters of the PermissionChecker.GetEffectivePermissions
type PermissionCheckerMockGetEffectivePermissionsParams struct {
	ctx  context.Context
	role auth.Role
}

// PermissionCheckerMockGetEffectivePermissionsParamPtrs contains pointers to parameters of the PermissionChecker.GetEffectivePermissions
type PermissionCheckerMockGetEffectivePermissionsParamPtrs struct {
	ctx  *context.Context
	role *auth.Role
}

// PermissionCheckerMockGetEffectivePermissionsResults contains results of the PermissionChecker.GetEffectivePermissions
type PermissionCheckerMockGetEffectivePermissionsResults struct {
	e1  mm_usecase.EffectivePermissions
	err error
}

// PermissionCheckerMockGetEffectivePermissionsOrigins contains origins of expectations of the PermissionChecker.GetEffectivePermissions
type PermissionCheckerMockGetEffectivePermissionsExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Optional() *mPermissionCheckerMockGetEffectivePermissions {
	mmGetEffectivePermissions.optional = true
	return mmGetEffectivePermissions
}

// Expect sets up expected params for PermissionChecker.GetEffectivePermissions
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Expect(ctx context.Context, role auth.Role) *mPermissionCheckerMockGetEffectivePermissions {
	if mmGetEffectivePermissions.mock.funcGetEffectivePermissions != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Set")
	}

	if mmGetEffectivePermissions.defaultExpectation == nil {
		mmGetEffectivePermissions.defaultExpectation = &PermissionCheckerMockGetEffectivePermissionsExpectation{}
	}

	if mmGetEffectivePermissions.defaultExpectation.paramPtrs != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by ExpectParams functions")
	}

	mmGetEffectivePermissions.defaultExpectation.params = &PermissionCheckerMockGetEffectivePermissionsParams{ctx, role}
	mmGetEffectivePermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetEffectivePermissions.expectations {
		if minimock.Equal(e.params, mmGetEffectivePermissions.defaultExpectation.params) {
			mmGetEffectivePermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEffectivePermissions.defaultExpectation.params)
		}
	}

	return mmGetEffectivePermissions
}

// ExpectCtxParam1 sets up expected param ctx for PermissionChecker.GetEffectivePermissions
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) ExpectCtxParam1(ctx context.Context) *mPermissionCheckerMockGetEffectivePermissions {
	if mmGetEffectivePermissions.mock.funcGetEffectivePermissions != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Set")
	}

	if mmGetEffectivePermissions.defaultExpectation == nil {
		mmGetEffectivePermissions.defaultExpectation = &PermissionCheckerMockGetEffectivePermissionsExpectation{}
	}

	if mmGetEffectivePermissions.defaultExpectation.params != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Expect")
	}

	if mmGetEffectivePermissions.defaultExpectation.paramPtrs == nil {
		mmGetEffectivePermissions.defaultExpectation.paramPtrs = &PermissionCheckerMockGetEffectivePermissionsParamPtrs{}
	}
	mmGetEffectivePermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetEffectivePermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetEffectivePermissions
}

// ExpectRoleParam2 sets up expected param role for PermissionChecker.GetEffectivePermissions
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) ExpectRoleParam2(role auth.Role) *mPermissionCheckerMockGetEffectivePermissions {
	if mmGetEffectivePermissions.mock.funcGetEffectivePermissions != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Set")
	}

	if mmGetEffectivePermissions.defaultExpectation == nil {
		mmGetEffectivePermissions.defaultExpectation = &PermissionCheckerMockGetEffectivePermissionsExpectation{}
	}

	if mmGetEffectivePermissions.defaultExpectation.params != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Expect")
	}

	if mmGetEffectivePermissions.defaultExpectation.paramPtrs == nil {
		mmGetEffectivePermissions.defaultExpectation.paramPtrs = &PermissionCheckerMockGetEffectivePermissionsParamPtrs{}
	}
	mmGetEffectivePermissions.defaultExpectation.paramPtrs.role = &role
	mmGetEffectivePermissions.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmGetEffectivePermissions
}

// Inspect accepts an inspector function that has same arguments as the PermissionChecker.GetEffectivePermissions
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Inspect(f func(ctx context.Context, role auth.Role)) *mPermissionCheckerMockGetEffectivePermissions {
	if mmGetEffectivePermissions.mock.inspectFuncGetEffectivePermissions != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("Inspect function is already set for PermissionCheckerMock.GetEffectivePermissions")
	}

	mmGetEffectivePermissions.mock.inspectFuncGetEffectivePermissions = f

	return mmGetEffectivePermissions
}

// Return sets up results that will be returned by PermissionChecker.GetEffectivePermissions
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Return(e1 mm_usecase.EffectivePermissions, err error) *PermissionCheckerMock {
	if mmGetEffectivePermissions.mock.funcGetEffectivePermissions != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Set")
	}

	if mmGetEffectivePermissions.defaultExpectation == nil {
		mmGetEffectivePermissions.defaultExpectation = &PermissionCheckerMockGetEffectivePermissionsExpectation{mock: mmGetEffectivePermissions.mock}
	}
	mmGetEffectivePermissions.defaultExpectation.results = &PermissionCheckerMockGetEffectivePermissionsResults{e1, err}
	mmGetEffectivePermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetEffectivePermissions.mock
}

// Set uses given function f to mock the PermissionChecker.GetEffectivePermissions method
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Set(f func(ctx context.Context, role auth.Role) (e1 mm_usecase.EffectivePermissions, err error)) *PermissionCheckerMock {
	if mmGetEffectivePermissions.defaultExpectation != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("Default expectation is already set for the PermissionChecker.GetEffectivePermissions method")
	}

	if len(mmGetEffectivePermissions.expectations) > 0 {
		mmGetEffectivePermissions.mock.t.Fatalf("Some expectations are already set for the PermissionChecker.GetEffectivePermissions method")
	}

	mmGetEffectivePermissions.mock.funcGetEffectivePermissions = f
	mmGetEffectivePermissions.mock.funcGetEffectivePermissionsOrigin = minimock.CallerInfo(1)
	return mmGetEffectivePermissions.mock
}

// When sets expectation for the PermissionChecker.GetEffectivePermissions which will trigger the result defined by the following
// Then helper
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) When(ctx context.Context, role auth.Role) *PermissionCheckerMockGetEffectivePermissionsExpectation {
	if mmGetEffectivePermissions.mock.funcGetEffectivePermissions != nil {
		mmGetEffectivePermissions.mock.t.Fatalf("PermissionCheckerMock.GetEffectivePermissions mock is already set by Set")
	}

	expectation := &PermissionCheckerMockGetEffectivePermissionsExpectation{
		mock:               mmGetEffectivePermissions.mock,
		params:             &PermissionCheckerMockGetEffectivePermissionsParams{ctx, role},
		expectationOrigins: PermissionCheckerMockGetEffectivePermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetEffectivePermissions.expectations = append(mmGetEffectivePermissions.expectations, expectation)
	return expectation
}

// Then sets up PermissionChecker.GetEffectivePermissions return parameters for the expectation previously defined by the When method
func (e *PermissionCheckerMockGetEffectivePermissionsExpectation) Then(e1 mm_usecase.EffectivePermissions, err error) *PermissionCheckerMock {
	e.results = &PermissionCheckerMockGetEffectivePermissionsResults{e1, err}
	return e.mock
}

// Times sets number of times PermissionChecker.GetEffectivePermissions should be invoked
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Times(n uint64) *mPermissionCheckerMockGetEffectivePermissions {
	if n == 0 {
		mmGetEffectivePermissions.mock.t.Fatalf("Times of PermissionCheckerMock.GetEffectivePermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEffectivePermissions.expectedInvocations, n)
	mmGetEffectivePermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetEffectivePermissions
}

func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) invocationsDone() bool {
	if len(mmGetEffectivePermissions.expectations) == 0 && mmGetEffectivePermissions.defaultExpectation == nil && mmGetEffectivePermissions.mock.funcGetEffectivePermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEffectivePermissions.mock.afterGetEffectivePermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEffectivePermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEffectivePermissions implements mm_usecase.PermissionChecker
func (mmGetEffectivePermissions *PermissionCheckerMock) GetEffectivePermissions(ctx context.Context, role auth.Role) (e1 mm_usecase.EffectivePermissions, err error) {
	mm_atomic.AddUint64(&mmGetEffectivePermissions.beforeGetEffectivePermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEffectivePermissions.afterGetEffectivePermissionsCounter, 1)

	mmGetEffectivePermissions.t.Helper()

	if mmGetEffectivePermissions.inspectFuncGetEffectivePermissions != nil {
		mmGetEffectivePermissions.inspectFuncGetEffectivePermissions(ctx, role)
	}

	mm_params := PermissionCheckerMockGetEffectivePermissionsParams{ctx, role}

	// Record call args
	mmGetEffectivePermissions.GetEffectivePermissionsMock.mutex.Lock()
	mmGetEffectivePermissions.GetEffectivePermissionsMock.callArgs = append(mmGetEffectivePermissions.GetEffectivePermissionsMock.callArgs, &mm_params)
	mmGetEffectivePermissions.GetEffectivePermissionsMock.mutex.Unlock()

	for _, e := range mmGetEffectivePermissions.GetEffectivePermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.paramPtrs

		mm_got := PermissionCheckerMockGetEffectivePermissionsParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetEffectivePermissions.t.Errorf("PermissionCheckerMock.GetEffectivePermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmGetEffectivePermissions.t.Errorf("PermissionCheckerMock.GetEffectivePermissions got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEffectivePermissions.t.Errorf("PermissionCheckerMock.GetEffectivePermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEffectivePermissions.GetEffectivePermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEffectivePermissions.t.Fatal("No results are set for the PermissionCheckerMock.GetEffectivePermissions")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGetEffectivePermissions.funcGetEffectivePermissions != nil {
		return mmGetEffectivePermissions.funcGetEffectivePermissions(ctx, role)
	}
	mmGetEffectivePermissions.t.Fatalf("Unexpected call to PermissionCheckerMock.GetEffectivePermissions. %v %v", ctx, role)
	return
}

// GetEffectivePermissionsAfterCounter returns a count of finished PermissionCheckerMock.GetEffectivePermissions invocations
func (mmGetEffectivePermissions *PermissionCheckerMock) GetEffectivePermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEffectivePermissions.afterGetEffectivePermissionsCounter)
}

// GetEffectivePermissionsBeforeCounter returns a count of PermissionCheckerMock.GetEffectivePermissions invocations
func (mmGetEffectivePermissions *PermissionCheckerMock) GetEffectivePermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEffectivePermissions.beforeGetEffectivePermissionsCounter)
}

// Calls returns a list of arguments used in each call to PermissionCheckerMock.GetEffectivePermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEffectivePermissions *mPermissionCheckerMockGetEffectivePermissions) Calls() []*PermissionCheckerMockGetEffectivePermissionsParams {
	mmGetEffectivePermissions.mutex.RLock()

	argCopy := make([]*PermissionCheckerMockGetEffectivePermissionsParams, len(mmGetEffectivePermissions.callArgs))
	copy(argCopy, mmGetEffectivePermissions.callArgs)

	mmGetEffectivePermissions.mutex.RUnlock()

	return argCopy
}

// MinimockGetEffectivePermissionsDone returns true if the count of the GetEffectivePermissions invocations corresponds
// the number of defined expectations
func (m *PermissionCheckerMock) MinimockGetEffectivePermissionsDone() bool {
	if m.GetEffectivePermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetEffectivePermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEffectivePermissionsMock.invocationsDone()
}

// MinimockGetEffectivePermissionsInspect logs each unmet expectation
func (m *PermissionCheckerMock) MinimockGetEffectivePermissionsInspect() {
	for _, e := range m.GetEffectivePermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PermissionCheckerMock.GetEffectivePermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetEffectivePermissionsCounter := mm_atomic.LoadUint64(&m.afterGetEffectivePermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEffectivePermissionsMock.defaultExpectation != nil && afterGetEffectivePermissionsCounter < 1 {
		if m.GetEffectivePermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PermissionCheckerMock.GetEffectivePermissions at\n%s", m.GetEffectivePermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PermissionCheckerMock.GetEffectivePermissions at\n%s with params: %#v", m.GetEffectivePermissionsMock.defaultExpectation.expectationOrigins.origin, *m.GetEffectivePermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEffectivePermissions != nil && afterGetEffectivePermissionsCounter < 1 {
		m.t.Errorf("Expected call to PermissionCheckerMock.GetEffectivePermissions at\n%s", m.funcGetEffectivePermissionsOrigin)
	}

	if !m.GetEffectivePermissionsMock.invocationsDone() && afterGetEffectivePermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to PermissionCheckerMock.GetEffectivePermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetEffectivePermissionsMock.expectedInvocations), m.GetEffectivePermissionsMock.expectedInvocationsOrigin, afterGetEffectivePermissionsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PermissionCheckerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckEntityPermissionInspect()

			m.MinimockGetDirectPermissionsInspect()

			m.MinimockGetEffectivePermissionsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PermissionCheckerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PermissionCheckerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckEntityPermissionDone() &&
		m.MinimockGetDirectPermissionsDone() &&
		m.MinimockGetEffectivePermissionsDone()
}
