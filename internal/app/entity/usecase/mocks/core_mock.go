// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/entity/usecase.Core -o core_mock.go -n CoreMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/entity"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// CoreMock implements mm_usecase.Core
type CoreMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, req entity.CreateEntityReq) (u1 uuid.UUID, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, req entity.CreateEntityReq)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mCoreMockCreate

	funcDelete          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mCoreMockDelete

	funcGet          func(ctx context.Context, id uuid.UUID) (e1 entity.Entity, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCoreMockGet

	funcGetListItem          func(ctx context.Context, id uuid.UUID) (l1 entity.ListItem, err error)
	funcGetListItemOrigin    string
	inspectFuncGetListItem   func(ctx context.Context, id uuid.UUID)
	afterGetListItemCounter  uint64
	beforeGetListItemCounter uint64
	GetListItemMock          mCoreMockGetListItem

	funcGetPermittedHierarchy          func(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool) (ua1 []uuid.UUID, err error)
	funcGetPermittedHierarchyOrigin    string
	inspectFuncGetPermittedHierarchy   func(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool)
	afterGetPermittedHierarchyCounter  uint64
	beforeGetPermittedHierarchyCounter uint64
	GetPermittedHierarchyMock          mCoreMockGetPermittedHierarchy

	funcGetTree          func(ctx context.Context, permissions []uuid.UUID, isAdmin bool) (t1 entity.Tree, err error)
	funcGetTreeOrigin    string
	inspectFuncGetTree   func(ctx context.Context, permissions []uuid.UUID, isAdmin bool)
	afterGetTreeCounter  uint64
	beforeGetTreeCounter uint64
	GetTreeMock          mCoreMockGetTree

	funcGetVersion          func(ctx context.Context, id uuid.UUID, version int) (e1 entity.Entity, err error)
	funcGetVersionOrigin    string
	inspectFuncGetVersion   func(ctx context.Context, id uuid.UUID, version int)
	afterGetVersionCounter  uint64
	beforeGetVersionCounter uint64
	GetVersionMock          mCoreMockGetVersion

	funcGetVersionsList          func(ctx context.Context, id uuid.UUID) (ea1 []entity.Entity, err error)
	funcGetVersionsListOrigin    string
	inspectFuncGetVersionsList   func(ctx context.Context, id uuid.UUID)
	afterGetVersionsListCounter  uint64
	beforeGetVersionsListCounter uint64
	GetVersionsListMock          mCoreMockGetVersionsList

	funcUpdate          func(ctx context.Context, req entity.UpdateEntityReq) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, req entity.UpdateEntityReq)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mCoreMockUpdate
}

// NewCoreMock returns a mock for mm_usecase.Core
func NewCoreMock(t minimock.Tester) *CoreMock {
	m := &CoreMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mCoreMockCreate{mock: m}
	m.CreateMock.callArgs = []*CoreMockCreateParams{}

	m.DeleteMock = mCoreMockDelete{mock: m}
	m.DeleteMock.callArgs = []*CoreMockDeleteParams{}

	m.GetMock = mCoreMockGet{mock: m}
	m.GetMock.callArgs = []*CoreMockGetParams{}

	m.GetListItemMock = mCoreMockGetListItem{mock: m}
	m.GetListItemMock.callArgs = []*CoreMockGetListItemParams{}

	m.GetPermittedHierarchyMock = mCoreMockGetPermittedHierarchy{mock: m}
	m.GetPermittedHierarchyMock.callArgs = []*CoreMockGetPermittedHierarchyParams{}

	m.GetTreeMock = mCoreMockGetTree{mock: m}
	m.GetTreeMock.callArgs = []*CoreMockGetTreeParams{}

	m.GetVersionMock = mCoreMockGetVersion{mock: m}
	m.GetVersionMock.callArgs = []*CoreMockGetVersionParams{}

	m.GetVersionsListMock = mCoreMockGetVersionsList{mock: m}
	m.GetVersionsListMock.callArgs = []*CoreMockGetVersionsListParams{}

	m.UpdateMock = mCoreMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*CoreMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCoreMockCreate struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockCreateExpectation
	expectations       []*CoreMockCreateExpectation

	callArgs []*CoreMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockCreateExpectation specifies expectation struct of the Core.Create
type CoreMockCreateExpectation struct {
	mock               *CoreMock
	params             *CoreMockCreateParams
	paramPtrs          *CoreMockCreateParamPtrs
	expectationOrigins CoreMockCreateExpectationOrigins
	results            *CoreMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockCreateParams contains parameters of the Core.Create
type CoreMockCreateParams struct {
	ctx context.Context
	req entity.CreateEntityReq
}

// CoreMockCreateParamPtrs contains pointers to parameters of the Core.Create
type CoreMockCreateParamPtrs struct {
	ctx *context.Context
	req *entity.CreateEntityReq
}

// CoreMockCreateResults contains results of the Core.Create
type CoreMockCreateResults struct {
	u1  uuid.UUID
	err error
}

// CoreMockCreateOrigins contains origins of expectations of the Core.Create
type CoreMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mCoreMockCreate) Optional() *mCoreMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Core.Create
func (mmCreate *mCoreMockCreate) Expect(ctx context.Context, req entity.CreateEntityReq) *mCoreMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CoreMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &CoreMockCreateParams{ctx, req}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Core.Create
func (mmCreate *mCoreMockCreate) ExpectCtxParam1(ctx context.Context) *mCoreMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CoreMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &CoreMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectReqParam2 sets up expected param req for Core.Create
func (mmCreate *mCoreMockCreate) ExpectReqParam2(req entity.CreateEntityReq) *mCoreMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CoreMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &CoreMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.req = &req
	mmCreate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Core.Create
func (mmCreate *mCoreMockCreate) Inspect(f func(ctx context.Context, req entity.CreateEntityReq)) *mCoreMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for CoreMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Core.Create
func (mmCreate *mCoreMockCreate) Return(u1 uuid.UUID, err error) *CoreMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CoreMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &CoreMockCreateResults{u1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the Core.Create method
func (mmCreate *mCoreMockCreate) Set(f func(ctx context.Context, req entity.CreateEntityReq) (u1 uuid.UUID, err error)) *CoreMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Core.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Core.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the Core.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mCoreMockCreate) When(ctx context.Context, req entity.CreateEntityReq) *CoreMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CoreMock.Create mock is already set by Set")
	}

	expectation := &CoreMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &CoreMockCreateParams{ctx, req},
		expectationOrigins: CoreMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Core.Create return parameters for the expectation previously defined by the When method
func (e *CoreMockCreateExpectation) Then(u1 uuid.UUID, err error) *CoreMock {
	e.results = &CoreMockCreateResults{u1, err}
	return e.mock
}

// Times sets number of times Core.Create should be invoked
func (mmCreate *mCoreMockCreate) Times(n uint64) *mCoreMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of CoreMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mCoreMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_usecase.Core
func (mmCreate *CoreMock) Create(ctx context.Context, req entity.CreateEntityReq) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, req)
	}

	mm_params := CoreMockCreateParams{ctx, req}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := CoreMockCreateParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("CoreMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreate.t.Errorf("CoreMock.Create got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("CoreMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the CoreMock.Create")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, req)
	}
	mmCreate.t.Fatalf("Unexpected call to CoreMock.Create. %v %v", ctx, req)
	return
}

// CreateAfterCounter returns a count of finished CoreMock.Create invocations
func (mmCreate *CoreMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of CoreMock.Create invocations
func (mmCreate *CoreMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mCoreMockCreate) Calls() []*CoreMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*CoreMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *CoreMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mCoreMockDelete struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockDeleteExpectation
	expectations       []*CoreMockDeleteExpectation

	callArgs []*CoreMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockDeleteExpectation specifies expectation struct of the Core.Delete
type CoreMockDeleteExpectation struct {
	mock               *CoreMock
	params             *CoreMockDeleteParams
	paramPtrs          *CoreMockDeleteParamPtrs
	expectationOrigins CoreMockDeleteExpectationOrigins
	results            *CoreMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockDeleteParams contains parameters of the Core.Delete
type CoreMockDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockDeleteParamPtrs contains pointers to parameters of the Core.Delete
type CoreMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockDeleteResults contains results of the Core.Delete
type CoreMockDeleteResults struct {
	err error
}

// CoreMockDeleteOrigins contains origins of expectations of the Core.Delete
type CoreMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mCoreMockDelete) Optional() *mCoreMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Core.Delete
func (mmDelete *mCoreMockDelete) Expect(ctx context.Context, id uuid.UUID) *mCoreMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CoreMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &CoreMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Core.Delete
func (mmDelete *mCoreMockDelete) ExpectCtxParam1(ctx context.Context) *mCoreMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CoreMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CoreMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for Core.Delete
func (mmDelete *mCoreMockDelete) ExpectIdParam2(id uuid.UUID) *mCoreMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CoreMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CoreMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Core.Delete
func (mmDelete *mCoreMockDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for CoreMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Core.Delete
func (mmDelete *mCoreMockDelete) Return(err error) *CoreMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CoreMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &CoreMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Core.Delete method
func (mmDelete *mCoreMockDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *CoreMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Core.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Core.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Core.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mCoreMockDelete) When(ctx context.Context, id uuid.UUID) *CoreMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CoreMock.Delete mock is already set by Set")
	}

	expectation := &CoreMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &CoreMockDeleteParams{ctx, id},
		expectationOrigins: CoreMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Core.Delete return parameters for the expectation previously defined by the When method
func (e *CoreMockDeleteExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Core.Delete should be invoked
func (mmDelete *mCoreMockDelete) Times(n uint64) *mCoreMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of CoreMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mCoreMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_usecase.Core
func (mmDelete *CoreMock) Delete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := CoreMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := CoreMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("CoreMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("CoreMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("CoreMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the CoreMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to CoreMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished CoreMock.Delete invocations
func (mmDelete *CoreMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of CoreMock.Delete invocations
func (mmDelete *CoreMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mCoreMockDelete) Calls() []*CoreMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*CoreMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *CoreMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mCoreMockGet struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetExpectation
	expectations       []*CoreMockGetExpectation

	callArgs []*CoreMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetExpectation specifies expectation struct of the Core.Get
type CoreMockGetExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetParams
	paramPtrs          *CoreMockGetParamPtrs
	expectationOrigins CoreMockGetExpectationOrigins
	results            *CoreMockGetResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetParams contains parameters of the Core.Get
type CoreMockGetParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockGetParamPtrs contains pointers to parameters of the Core.Get
type CoreMockGetParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockGetResults contains results of the Core.Get
type CoreMockGetResults struct {
	e1  entity.Entity
	err error
}

// CoreMockGetOrigins contains origins of expectations of the Core.Get
type CoreMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mCoreMockGet) Optional() *mCoreMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Core.Get
func (mmGet *mCoreMockGet) Expect(ctx context.Context, id uuid.UUID) *mCoreMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CoreMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &CoreMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Core.Get
func (mmGet *mCoreMockGet) ExpectCtxParam1(ctx context.Context) *mCoreMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CoreMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CoreMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for Core.Get
func (mmGet *mCoreMockGet) ExpectIdParam2(id uuid.UUID) *mCoreMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CoreMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CoreMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Core.Get
func (mmGet *mCoreMockGet) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CoreMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Core.Get
func (mmGet *mCoreMockGet) Return(e1 entity.Entity, err error) *CoreMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CoreMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CoreMockGetResults{e1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Core.Get method
func (mmGet *mCoreMockGet) Set(f func(ctx context.Context, id uuid.UUID) (e1 entity.Entity, err error)) *CoreMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Core.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Core.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Core.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCoreMockGet) When(ctx context.Context, id uuid.UUID) *CoreMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CoreMock.Get mock is already set by Set")
	}

	expectation := &CoreMockGetExpectation{
		mock:               mmGet.mock,
		params:             &CoreMockGetParams{ctx, id},
		expectationOrigins: CoreMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Core.Get return parameters for the expectation previously defined by the When method
func (e *CoreMockGetExpectation) Then(e1 entity.Entity, err error) *CoreMock {
	e.results = &CoreMockGetResults{e1, err}
	return e.mock
}

// Times sets number of times Core.Get should be invoked
func (mmGet *mCoreMockGet) Times(n uint64) *mCoreMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of CoreMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mCoreMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_usecase.Core
func (mmGet *CoreMock) Get(ctx context.Context, id uuid.UUID) (e1 entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := CoreMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("CoreMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("CoreMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CoreMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CoreMock.Get")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to CoreMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished CoreMock.Get invocations
func (mmGet *CoreMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CoreMock.Get invocations
func (mmGet *CoreMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCoreMockGet) Calls() []*CoreMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CoreMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *CoreMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mCoreMockGetListItem struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetListItemExpectation
	expectations       []*CoreMockGetListItemExpectation

	callArgs []*CoreMockGetListItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetListItemExpectation specifies expectation struct of the Core.GetListItem
type CoreMockGetListItemExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetListItemParams
	paramPtrs          *CoreMockGetListItemParamPtrs
	expectationOrigins CoreMockGetListItemExpectationOrigins
	results            *CoreMockGetListItemResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetListItemParams contains parameters of the Core.GetListItem
type CoreMockGetListItemParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockGetListItemParamPtrs contains pointers to parameters of the Core.GetListItem
type CoreMockGetListItemParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockGetListItemResults contains results of the Core.GetListItem
type CoreMockGetListItemResults struct {
	l1  entity.ListItem
	err error
}

// CoreMockGetListItemOrigins contains origins of expectations of the Core.GetListItem
type CoreMockGetListItemExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListItem *mCoreMockGetListItem) Optional() *mCoreMockGetListItem {
	mmGetListItem.optional = true
	return mmGetListItem
}

// Expect sets up expected params for Core.GetListItem
func (mmGetListItem *mCoreMockGetListItem) Expect(ctx context.Context, id uuid.UUID) *mCoreMockGetListItem {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &CoreMockGetListItemExpectation{}
	}

	if mmGetListItem.defaultExpectation.paramPtrs != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by ExpectParams functions")
	}

	mmGetListItem.defaultExpectation.params = &CoreMockGetListItemParams{ctx, id}
	mmGetListItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListItem.expectations {
		if minimock.Equal(e.params, mmGetListItem.defaultExpectation.params) {
			mmGetListItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListItem.defaultExpectation.params)
		}
	}

	return mmGetListItem
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetListItem
func (mmGetListItem *mCoreMockGetListItem) ExpectCtxParam1(ctx context.Context) *mCoreMockGetListItem {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &CoreMockGetListItemExpectation{}
	}

	if mmGetListItem.defaultExpectation.params != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Expect")
	}

	if mmGetListItem.defaultExpectation.paramPtrs == nil {
		mmGetListItem.defaultExpectation.paramPtrs = &CoreMockGetListItemParamPtrs{}
	}
	mmGetListItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListItem
}

// ExpectIdParam2 sets up expected param id for Core.GetListItem
func (mmGetListItem *mCoreMockGetListItem) ExpectIdParam2(id uuid.UUID) *mCoreMockGetListItem {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &CoreMockGetListItemExpectation{}
	}

	if mmGetListItem.defaultExpectation.params != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Expect")
	}

	if mmGetListItem.defaultExpectation.paramPtrs == nil {
		mmGetListItem.defaultExpectation.paramPtrs = &CoreMockGetListItemParamPtrs{}
	}
	mmGetListItem.defaultExpectation.paramPtrs.id = &id
	mmGetListItem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetListItem
}

// Inspect accepts an inspector function that has same arguments as the Core.GetListItem
func (mmGetListItem *mCoreMockGetListItem) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockGetListItem {
	if mmGetListItem.mock.inspectFuncGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("Inspect function is already set for CoreMock.GetListItem")
	}

	mmGetListItem.mock.inspectFuncGetListItem = f

	return mmGetListItem
}

// Return sets up results that will be returned by Core.GetListItem
func (mmGetListItem *mCoreMockGetListItem) Return(l1 entity.ListItem, err error) *CoreMock {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &CoreMockGetListItemExpectation{mock: mmGetListItem.mock}
	}
	mmGetListItem.defaultExpectation.results = &CoreMockGetListItemResults{l1, err}
	mmGetListItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListItem.mock
}

// Set uses given function f to mock the Core.GetListItem method
func (mmGetListItem *mCoreMockGetListItem) Set(f func(ctx context.Context, id uuid.UUID) (l1 entity.ListItem, err error)) *CoreMock {
	if mmGetListItem.defaultExpectation != nil {
		mmGetListItem.mock.t.Fatalf("Default expectation is already set for the Core.GetListItem method")
	}

	if len(mmGetListItem.expectations) > 0 {
		mmGetListItem.mock.t.Fatalf("Some expectations are already set for the Core.GetListItem method")
	}

	mmGetListItem.mock.funcGetListItem = f
	mmGetListItem.mock.funcGetListItemOrigin = minimock.CallerInfo(1)
	return mmGetListItem.mock
}

// When sets expectation for the Core.GetListItem which will trigger the result defined by the following
// Then helper
func (mmGetListItem *mCoreMockGetListItem) When(ctx context.Context, id uuid.UUID) *CoreMockGetListItemExpectation {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("CoreMock.GetListItem mock is already set by Set")
	}

	expectation := &CoreMockGetListItemExpectation{
		mock:               mmGetListItem.mock,
		params:             &CoreMockGetListItemParams{ctx, id},
		expectationOrigins: CoreMockGetListItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListItem.expectations = append(mmGetListItem.expectations, expectation)
	return expectation
}

// Then sets up Core.GetListItem return parameters for the expectation previously defined by the When method
func (e *CoreMockGetListItemExpectation) Then(l1 entity.ListItem, err error) *CoreMock {
	e.results = &CoreMockGetListItemResults{l1, err}
	return e.mock
}

// Times sets number of times Core.GetListItem should be invoked
func (mmGetListItem *mCoreMockGetListItem) Times(n uint64) *mCoreMockGetListItem {
	if n == 0 {
		mmGetListItem.mock.t.Fatalf("Times of CoreMock.GetListItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListItem.expectedInvocations, n)
	mmGetListItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListItem
}

func (mmGetListItem *mCoreMockGetListItem) invocationsDone() bool {
	if len(mmGetListItem.expectations) == 0 && mmGetListItem.defaultExpectation == nil && mmGetListItem.mock.funcGetListItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListItem.mock.afterGetListItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListItem implements mm_usecase.Core
func (mmGetListItem *CoreMock) GetListItem(ctx context.Context, id uuid.UUID) (l1 entity.ListItem, err error) {
	mm_atomic.AddUint64(&mmGetListItem.beforeGetListItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListItem.afterGetListItemCounter, 1)

	mmGetListItem.t.Helper()

	if mmGetListItem.inspectFuncGetListItem != nil {
		mmGetListItem.inspectFuncGetListItem(ctx, id)
	}

	mm_params := CoreMockGetListItemParams{ctx, id}

	// Record call args
	mmGetListItem.GetListItemMock.mutex.Lock()
	mmGetListItem.GetListItemMock.callArgs = append(mmGetListItem.GetListItemMock.callArgs, &mm_params)
	mmGetListItem.GetListItemMock.mutex.Unlock()

	for _, e := range mmGetListItem.GetListItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmGetListItem.GetListItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListItem.GetListItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListItem.GetListItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetListItem.GetListItemMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetListItemParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListItem.t.Errorf("CoreMock.GetListItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListItem.GetListItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetListItem.t.Errorf("CoreMock.GetListItem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListItem.GetListItemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListItem.t.Errorf("CoreMock.GetListItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListItem.GetListItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListItem.GetListItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListItem.t.Fatal("No results are set for the CoreMock.GetListItem")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmGetListItem.funcGetListItem != nil {
		return mmGetListItem.funcGetListItem(ctx, id)
	}
	mmGetListItem.t.Fatalf("Unexpected call to CoreMock.GetListItem. %v %v", ctx, id)
	return
}

// GetListItemAfterCounter returns a count of finished CoreMock.GetListItem invocations
func (mmGetListItem *CoreMock) GetListItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListItem.afterGetListItemCounter)
}

// GetListItemBeforeCounter returns a count of CoreMock.GetListItem invocations
func (mmGetListItem *CoreMock) GetListItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListItem.beforeGetListItemCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetListItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListItem *mCoreMockGetListItem) Calls() []*CoreMockGetListItemParams {
	mmGetListItem.mutex.RLock()

	argCopy := make([]*CoreMockGetListItemParams, len(mmGetListItem.callArgs))
	copy(argCopy, mmGetListItem.callArgs)

	mmGetListItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetListItemDone returns true if the count of the GetListItem invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetListItemDone() bool {
	if m.GetListItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListItemMock.invocationsDone()
}

// MinimockGetListItemInspect logs each unmet expectation
func (m *CoreMock) MinimockGetListItemInspect() {
	for _, e := range m.GetListItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetListItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListItemCounter := mm_atomic.LoadUint64(&m.afterGetListItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListItemMock.defaultExpectation != nil && afterGetListItemCounter < 1 {
		if m.GetListItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetListItem at\n%s", m.GetListItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetListItem at\n%s with params: %#v", m.GetListItemMock.defaultExpectation.expectationOrigins.origin, *m.GetListItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListItem != nil && afterGetListItemCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetListItem at\n%s", m.funcGetListItemOrigin)
	}

	if !m.GetListItemMock.invocationsDone() && afterGetListItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetListItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListItemMock.expectedInvocations), m.GetListItemMock.expectedInvocationsOrigin, afterGetListItemCounter)
	}
}

type mCoreMockGetPermittedHierarchy struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetPermittedHierarchyExpectation
	expectations       []*CoreMockGetPermittedHierarchyExpectation

	callArgs []*CoreMockGetPermittedHierarchyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetPermittedHierarchyExpectation specifies expectation struct of the Core.GetPermittedHierarchy
type CoreMockGetPermittedHierarchyExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetPermittedHierarchyParams
	paramPtrs          *CoreMockGetPermittedHierarchyParamPtrs
	expectationOrigins CoreMockGetPermittedHierarchyExpectationOrigins
	results            *CoreMockGetPermittedHierarchyResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetPermittedHierarchyParams contains parameters of the Core.GetPermittedHierarchy
type CoreMockGetPermittedHierarchyParams struct {
	ctx               context.Context
	directPermissions []uuid.UUID
	onlyForRead       bool
}

// CoreMockGetPermittedHierarchyParamPtrs contains pointers to parameters of the Core.GetPermittedHierarchy
type CoreMockGetPermittedHierarchyParamPtrs struct {
	ctx               *context.Context
	directPermissions *[]uuid.UUID
	onlyForRead       *bool
}

// CoreMockGetPermittedHierarchyResults contains results of the Core.GetPermittedHierarchy
type CoreMockGetPermittedHierarchyResults struct {
	ua1 []uuid.UUID
	err error
}

// CoreMockGetPermittedHierarchyOrigins contains origins of expectations of the Core.GetPermittedHierarchy
type CoreMockGetPermittedHierarchyExpectationOrigins struct {
	origin                  string
	originCtx               string
	originDirectPermissions string
	originOnlyForRead       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Optional() *mCoreMockGetPermittedHierarchy {
	mmGetPermittedHierarchy.optional = true
	return mmGetPermittedHierarchy
}

// Expect sets up expected params for Core.GetPermittedHierarchy
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Expect(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool) *mCoreMockGetPermittedHierarchy {
	if mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Set")
	}

	if mmGetPermittedHierarchy.defaultExpectation == nil {
		mmGetPermittedHierarchy.defaultExpectation = &CoreMockGetPermittedHierarchyExpectation{}
	}

	if mmGetPermittedHierarchy.defaultExpectation.paramPtrs != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by ExpectParams functions")
	}

	mmGetPermittedHierarchy.defaultExpectation.params = &CoreMockGetPermittedHierarchyParams{ctx, directPermissions, onlyForRead}
	mmGetPermittedHierarchy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPermittedHierarchy.expectations {
		if minimock.Equal(e.params, mmGetPermittedHierarchy.defaultExpectation.params) {
			mmGetPermittedHierarchy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPermittedHierarchy.defaultExpectation.params)
		}
	}

	return mmGetPermittedHierarchy
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetPermittedHierarchy
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) ExpectCtxParam1(ctx context.Context) *mCoreMockGetPermittedHierarchy {
	if mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Set")
	}

	if mmGetPermittedHierarchy.defaultExpectation == nil {
		mmGetPermittedHierarchy.defaultExpectation = &CoreMockGetPermittedHierarchyExpectation{}
	}

	if mmGetPermittedHierarchy.defaultExpectation.params != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Expect")
	}

	if mmGetPermittedHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetPermittedHierarchy.defaultExpectation.paramPtrs = &CoreMockGetPermittedHierarchyParamPtrs{}
	}
	mmGetPermittedHierarchy.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPermittedHierarchy.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPermittedHierarchy
}

// ExpectDirectPermissionsParam2 sets up expected param directPermissions for Core.GetPermittedHierarchy
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) ExpectDirectPermissionsParam2(directPermissions []uuid.UUID) *mCoreMockGetPermittedHierarchy {
	if mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Set")
	}

	if mmGetPermittedHierarchy.defaultExpectation == nil {
		mmGetPermittedHierarchy.defaultExpectation = &CoreMockGetPermittedHierarchyExpectation{}
	}

	if mmGetPermittedHierarchy.defaultExpectation.params != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Expect")
	}

	if mmGetPermittedHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetPermittedHierarchy.defaultExpectation.paramPtrs = &CoreMockGetPermittedHierarchyParamPtrs{}
	}
	mmGetPermittedHierarchy.defaultExpectation.paramPtrs.directPermissions = &directPermissions
	mmGetPermittedHierarchy.defaultExpectation.expectationOrigins.originDirectPermissions = minimock.CallerInfo(1)

	return mmGetPermittedHierarchy
}

// ExpectOnlyForReadParam3 sets up expected param onlyForRead for Core.GetPermittedHierarchy
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) ExpectOnlyForReadParam3(onlyForRead bool) *mCoreMockGetPermittedHierarchy {
	if mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Set")
	}

	if mmGetPermittedHierarchy.defaultExpectation == nil {
		mmGetPermittedHierarchy.defaultExpectation = &CoreMockGetPermittedHierarchyExpectation{}
	}

	if mmGetPermittedHierarchy.defaultExpectation.params != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Expect")
	}

	if mmGetPermittedHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetPermittedHierarchy.defaultExpectation.paramPtrs = &CoreMockGetPermittedHierarchyParamPtrs{}
	}
	mmGetPermittedHierarchy.defaultExpectation.paramPtrs.onlyForRead = &onlyForRead
	mmGetPermittedHierarchy.defaultExpectation.expectationOrigins.originOnlyForRead = minimock.CallerInfo(1)

	return mmGetPermittedHierarchy
}

// Inspect accepts an inspector function that has same arguments as the Core.GetPermittedHierarchy
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Inspect(f func(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool)) *mCoreMockGetPermittedHierarchy {
	if mmGetPermittedHierarchy.mock.inspectFuncGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("Inspect function is already set for CoreMock.GetPermittedHierarchy")
	}

	mmGetPermittedHierarchy.mock.inspectFuncGetPermittedHierarchy = f

	return mmGetPermittedHierarchy
}

// Return sets up results that will be returned by Core.GetPermittedHierarchy
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Return(ua1 []uuid.UUID, err error) *CoreMock {
	if mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Set")
	}

	if mmGetPermittedHierarchy.defaultExpectation == nil {
		mmGetPermittedHierarchy.defaultExpectation = &CoreMockGetPermittedHierarchyExpectation{mock: mmGetPermittedHierarchy.mock}
	}
	mmGetPermittedHierarchy.defaultExpectation.results = &CoreMockGetPermittedHierarchyResults{ua1, err}
	mmGetPermittedHierarchy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPermittedHierarchy.mock
}

// Set uses given function f to mock the Core.GetPermittedHierarchy method
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Set(f func(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool) (ua1 []uuid.UUID, err error)) *CoreMock {
	if mmGetPermittedHierarchy.defaultExpectation != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("Default expectation is already set for the Core.GetPermittedHierarchy method")
	}

	if len(mmGetPermittedHierarchy.expectations) > 0 {
		mmGetPermittedHierarchy.mock.t.Fatalf("Some expectations are already set for the Core.GetPermittedHierarchy method")
	}

	mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy = f
	mmGetPermittedHierarchy.mock.funcGetPermittedHierarchyOrigin = minimock.CallerInfo(1)
	return mmGetPermittedHierarchy.mock
}

// When sets expectation for the Core.GetPermittedHierarchy which will trigger the result defined by the following
// Then helper
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) When(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool) *CoreMockGetPermittedHierarchyExpectation {
	if mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.mock.t.Fatalf("CoreMock.GetPermittedHierarchy mock is already set by Set")
	}

	expectation := &CoreMockGetPermittedHierarchyExpectation{
		mock:               mmGetPermittedHierarchy.mock,
		params:             &CoreMockGetPermittedHierarchyParams{ctx, directPermissions, onlyForRead},
		expectationOrigins: CoreMockGetPermittedHierarchyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPermittedHierarchy.expectations = append(mmGetPermittedHierarchy.expectations, expectation)
	return expectation
}

// Then sets up Core.GetPermittedHierarchy return parameters for the expectation previously defined by the When method
func (e *CoreMockGetPermittedHierarchyExpectation) Then(ua1 []uuid.UUID, err error) *CoreMock {
	e.results = &CoreMockGetPermittedHierarchyResults{ua1, err}
	return e.mock
}

// Times sets number of times Core.GetPermittedHierarchy should be invoked
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Times(n uint64) *mCoreMockGetPermittedHierarchy {
	if n == 0 {
		mmGetPermittedHierarchy.mock.t.Fatalf("Times of CoreMock.GetPermittedHierarchy mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPermittedHierarchy.expectedInvocations, n)
	mmGetPermittedHierarchy.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPermittedHierarchy
}

func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) invocationsDone() bool {
	if len(mmGetPermittedHierarchy.expectations) == 0 && mmGetPermittedHierarchy.defaultExpectation == nil && mmGetPermittedHierarchy.mock.funcGetPermittedHierarchy == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPermittedHierarchy.mock.afterGetPermittedHierarchyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPermittedHierarchy.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPermittedHierarchy implements mm_usecase.Core
func (mmGetPermittedHierarchy *CoreMock) GetPermittedHierarchy(ctx context.Context, directPermissions []uuid.UUID, onlyForRead bool) (ua1 []uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmGetPermittedHierarchy.beforeGetPermittedHierarchyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPermittedHierarchy.afterGetPermittedHierarchyCounter, 1)

	mmGetPermittedHierarchy.t.Helper()

	if mmGetPermittedHierarchy.inspectFuncGetPermittedHierarchy != nil {
		mmGetPermittedHierarchy.inspectFuncGetPermittedHierarchy(ctx, directPermissions, onlyForRead)
	}

	mm_params := CoreMockGetPermittedHierarchyParams{ctx, directPermissions, onlyForRead}

	// Record call args
	mmGetPermittedHierarchy.GetPermittedHierarchyMock.mutex.Lock()
	mmGetPermittedHierarchy.GetPermittedHierarchyMock.callArgs = append(mmGetPermittedHierarchy.GetPermittedHierarchyMock.callArgs, &mm_params)
	mmGetPermittedHierarchy.GetPermittedHierarchyMock.mutex.Unlock()

	for _, e := range mmGetPermittedHierarchy.GetPermittedHierarchyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.params
		mm_want_ptrs := mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetPermittedHierarchyParams{ctx, directPermissions, onlyForRead}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPermittedHierarchy.t.Errorf("CoreMock.GetPermittedHierarchy got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.directPermissions != nil && !minimock.Equal(*mm_want_ptrs.directPermissions, mm_got.directPermissions) {
				mmGetPermittedHierarchy.t.Errorf("CoreMock.GetPermittedHierarchy got unexpected parameter directPermissions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.expectationOrigins.originDirectPermissions, *mm_want_ptrs.directPermissions, mm_got.directPermissions, minimock.Diff(*mm_want_ptrs.directPermissions, mm_got.directPermissions))
			}

			if mm_want_ptrs.onlyForRead != nil && !minimock.Equal(*mm_want_ptrs.onlyForRead, mm_got.onlyForRead) {
				mmGetPermittedHierarchy.t.Errorf("CoreMock.GetPermittedHierarchy got unexpected parameter onlyForRead, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.expectationOrigins.originOnlyForRead, *mm_want_ptrs.onlyForRead, mm_got.onlyForRead, minimock.Diff(*mm_want_ptrs.onlyForRead, mm_got.onlyForRead))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPermittedHierarchy.t.Errorf("CoreMock.GetPermittedHierarchy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPermittedHierarchy.GetPermittedHierarchyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPermittedHierarchy.t.Fatal("No results are set for the CoreMock.GetPermittedHierarchy")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetPermittedHierarchy.funcGetPermittedHierarchy != nil {
		return mmGetPermittedHierarchy.funcGetPermittedHierarchy(ctx, directPermissions, onlyForRead)
	}
	mmGetPermittedHierarchy.t.Fatalf("Unexpected call to CoreMock.GetPermittedHierarchy. %v %v %v", ctx, directPermissions, onlyForRead)
	return
}

// GetPermittedHierarchyAfterCounter returns a count of finished CoreMock.GetPermittedHierarchy invocations
func (mmGetPermittedHierarchy *CoreMock) GetPermittedHierarchyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPermittedHierarchy.afterGetPermittedHierarchyCounter)
}

// GetPermittedHierarchyBeforeCounter returns a count of CoreMock.GetPermittedHierarchy invocations
func (mmGetPermittedHierarchy *CoreMock) GetPermittedHierarchyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPermittedHierarchy.beforeGetPermittedHierarchyCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetPermittedHierarchy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPermittedHierarchy *mCoreMockGetPermittedHierarchy) Calls() []*CoreMockGetPermittedHierarchyParams {
	mmGetPermittedHierarchy.mutex.RLock()

	argCopy := make([]*CoreMockGetPermittedHierarchyParams, len(mmGetPermittedHierarchy.callArgs))
	copy(argCopy, mmGetPermittedHierarchy.callArgs)

	mmGetPermittedHierarchy.mutex.RUnlock()

	return argCopy
}

// MinimockGetPermittedHierarchyDone returns true if the count of the GetPermittedHierarchy invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetPermittedHierarchyDone() bool {
	if m.GetPermittedHierarchyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPermittedHierarchyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPermittedHierarchyMock.invocationsDone()
}

// MinimockGetPermittedHierarchyInspect logs each unmet expectation
func (m *CoreMock) MinimockGetPermittedHierarchyInspect() {
	for _, e := range m.GetPermittedHierarchyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetPermittedHierarchy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPermittedHierarchyCounter := mm_atomic.LoadUint64(&m.afterGetPermittedHierarchyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPermittedHierarchyMock.defaultExpectation != nil && afterGetPermittedHierarchyCounter < 1 {
		if m.GetPermittedHierarchyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetPermittedHierarchy at\n%s", m.GetPermittedHierarchyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetPermittedHierarchy at\n%s with params: %#v", m.GetPermittedHierarchyMock.defaultExpectation.expectationOrigins.origin, *m.GetPermittedHierarchyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPermittedHierarchy != nil && afterGetPermittedHierarchyCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetPermittedHierarchy at\n%s", m.funcGetPermittedHierarchyOrigin)
	}

	if !m.GetPermittedHierarchyMock.invocationsDone() && afterGetPermittedHierarchyCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetPermittedHierarchy at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPermittedHierarchyMock.expectedInvocations), m.GetPermittedHierarchyMock.expectedInvocationsOrigin, afterGetPermittedHierarchyCounter)
	}
}

type mCoreMockGetTree struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetTreeExpectation
	expectations       []*CoreMockGetTreeExpectation

	callArgs []*CoreMockGetTreeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetTreeExpectation specifies expectation struct of the Core.GetTree
type CoreMockGetTreeExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetTreeParams
	paramPtrs          *CoreMockGetTreeParamPtrs
	expectationOrigins CoreMockGetTreeExpectationOrigins
	results            *CoreMockGetTreeResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetTreeParams contains parameters of the Core.GetTree
type CoreMockGetTreeParams struct {
	ctx         context.Context
	permissions []uuid.UUID
	isAdmin     bool
}

// CoreMockGetTreeParamPtrs contains pointers to parameters of the Core.GetTree
type CoreMockGetTreeParamPtrs struct {
	ctx         *context.Context
	permissions *[]uuid.UUID
	isAdmin     *bool
}

// CoreMockGetTreeResults contains results of the Core.GetTree
type CoreMockGetTreeResults struct {
	t1  entity.Tree
	err error
}

// CoreMockGetTreeOrigins contains origins of expectations of the Core.GetTree
type CoreMockGetTreeExpectationOrigins struct {
	origin            string
	originCtx         string
	originPermissions string
	originIsAdmin     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTree *mCoreMockGetTree) Optional() *mCoreMockGetTree {
	mmGetTree.optional = true
	return mmGetTree
}

// Expect sets up expected params for Core.GetTree
func (mmGetTree *mCoreMockGetTree) Expect(ctx context.Context, permissions []uuid.UUID, isAdmin bool) *mCoreMockGetTree {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &CoreMockGetTreeExpectation{}
	}

	if mmGetTree.defaultExpectation.paramPtrs != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by ExpectParams functions")
	}

	mmGetTree.defaultExpectation.params = &CoreMockGetTreeParams{ctx, permissions, isAdmin}
	mmGetTree.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTree.expectations {
		if minimock.Equal(e.params, mmGetTree.defaultExpectation.params) {
			mmGetTree.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTree.defaultExpectation.params)
		}
	}

	return mmGetTree
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetTree
func (mmGetTree *mCoreMockGetTree) ExpectCtxParam1(ctx context.Context) *mCoreMockGetTree {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &CoreMockGetTreeExpectation{}
	}

	if mmGetTree.defaultExpectation.params != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Expect")
	}

	if mmGetTree.defaultExpectation.paramPtrs == nil {
		mmGetTree.defaultExpectation.paramPtrs = &CoreMockGetTreeParamPtrs{}
	}
	mmGetTree.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTree.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTree
}

// ExpectPermissionsParam2 sets up expected param permissions for Core.GetTree
func (mmGetTree *mCoreMockGetTree) ExpectPermissionsParam2(permissions []uuid.UUID) *mCoreMockGetTree {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &CoreMockGetTreeExpectation{}
	}

	if mmGetTree.defaultExpectation.params != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Expect")
	}

	if mmGetTree.defaultExpectation.paramPtrs == nil {
		mmGetTree.defaultExpectation.paramPtrs = &CoreMockGetTreeParamPtrs{}
	}
	mmGetTree.defaultExpectation.paramPtrs.permissions = &permissions
	mmGetTree.defaultExpectation.expectationOrigins.originPermissions = minimock.CallerInfo(1)

	return mmGetTree
}

// ExpectIsAdminParam3 sets up expected param isAdmin for Core.GetTree
func (mmGetTree *mCoreMockGetTree) ExpectIsAdminParam3(isAdmin bool) *mCoreMockGetTree {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &CoreMockGetTreeExpectation{}
	}

	if mmGetTree.defaultExpectation.params != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Expect")
	}

	if mmGetTree.defaultExpectation.paramPtrs == nil {
		mmGetTree.defaultExpectation.paramPtrs = &CoreMockGetTreeParamPtrs{}
	}
	mmGetTree.defaultExpectation.paramPtrs.isAdmin = &isAdmin
	mmGetTree.defaultExpectation.expectationOrigins.originIsAdmin = minimock.CallerInfo(1)

	return mmGetTree
}

// Inspect accepts an inspector function that has same arguments as the Core.GetTree
func (mmGetTree *mCoreMockGetTree) Inspect(f func(ctx context.Context, permissions []uuid.UUID, isAdmin bool)) *mCoreMockGetTree {
	if mmGetTree.mock.inspectFuncGetTree != nil {
		mmGetTree.mock.t.Fatalf("Inspect function is already set for CoreMock.GetTree")
	}

	mmGetTree.mock.inspectFuncGetTree = f

	return mmGetTree
}

// Return sets up results that will be returned by Core.GetTree
func (mmGetTree *mCoreMockGetTree) Return(t1 entity.Tree, err error) *CoreMock {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &CoreMockGetTreeExpectation{mock: mmGetTree.mock}
	}
	mmGetTree.defaultExpectation.results = &CoreMockGetTreeResults{t1, err}
	mmGetTree.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTree.mock
}

// Set uses given function f to mock the Core.GetTree method
func (mmGetTree *mCoreMockGetTree) Set(f func(ctx context.Context, permissions []uuid.UUID, isAdmin bool) (t1 entity.Tree, err error)) *CoreMock {
	if mmGetTree.defaultExpectation != nil {
		mmGetTree.mock.t.Fatalf("Default expectation is already set for the Core.GetTree method")
	}

	if len(mmGetTree.expectations) > 0 {
		mmGetTree.mock.t.Fatalf("Some expectations are already set for the Core.GetTree method")
	}

	mmGetTree.mock.funcGetTree = f
	mmGetTree.mock.funcGetTreeOrigin = minimock.CallerInfo(1)
	return mmGetTree.mock
}

// When sets expectation for the Core.GetTree which will trigger the result defined by the following
// Then helper
func (mmGetTree *mCoreMockGetTree) When(ctx context.Context, permissions []uuid.UUID, isAdmin bool) *CoreMockGetTreeExpectation {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("CoreMock.GetTree mock is already set by Set")
	}

	expectation := &CoreMockGetTreeExpectation{
		mock:               mmGetTree.mock,
		params:             &CoreMockGetTreeParams{ctx, permissions, isAdmin},
		expectationOrigins: CoreMockGetTreeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTree.expectations = append(mmGetTree.expectations, expectation)
	return expectation
}

// Then sets up Core.GetTree return parameters for the expectation previously defined by the When method
func (e *CoreMockGetTreeExpectation) Then(t1 entity.Tree, err error) *CoreMock {
	e.results = &CoreMockGetTreeResults{t1, err}
	return e.mock
}

// Times sets number of times Core.GetTree should be invoked
func (mmGetTree *mCoreMockGetTree) Times(n uint64) *mCoreMockGetTree {
	if n == 0 {
		mmGetTree.mock.t.Fatalf("Times of CoreMock.GetTree mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTree.expectedInvocations, n)
	mmGetTree.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTree
}

func (mmGetTree *mCoreMockGetTree) invocationsDone() bool {
	if len(mmGetTree.expectations) == 0 && mmGetTree.defaultExpectation == nil && mmGetTree.mock.funcGetTree == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTree.mock.afterGetTreeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTree.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTree implements mm_usecase.Core
func (mmGetTree *CoreMock) GetTree(ctx context.Context, permissions []uuid.UUID, isAdmin bool) (t1 entity.Tree, err error) {
	mm_atomic.AddUint64(&mmGetTree.beforeGetTreeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTree.afterGetTreeCounter, 1)

	mmGetTree.t.Helper()

	if mmGetTree.inspectFuncGetTree != nil {
		mmGetTree.inspectFuncGetTree(ctx, permissions, isAdmin)
	}

	mm_params := CoreMockGetTreeParams{ctx, permissions, isAdmin}

	// Record call args
	mmGetTree.GetTreeMock.mutex.Lock()
	mmGetTree.GetTreeMock.callArgs = append(mmGetTree.GetTreeMock.callArgs, &mm_params)
	mmGetTree.GetTreeMock.mutex.Unlock()

	for _, e := range mmGetTree.GetTreeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmGetTree.GetTreeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTree.GetTreeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTree.GetTreeMock.defaultExpectation.params
		mm_want_ptrs := mmGetTree.GetTreeMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetTreeParams{ctx, permissions, isAdmin}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTree.t.Errorf("CoreMock.GetTree got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTree.GetTreeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.permissions != nil && !minimock.Equal(*mm_want_ptrs.permissions, mm_got.permissions) {
				mmGetTree.t.Errorf("CoreMock.GetTree got unexpected parameter permissions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTree.GetTreeMock.defaultExpectation.expectationOrigins.originPermissions, *mm_want_ptrs.permissions, mm_got.permissions, minimock.Diff(*mm_want_ptrs.permissions, mm_got.permissions))
			}

			if mm_want_ptrs.isAdmin != nil && !minimock.Equal(*mm_want_ptrs.isAdmin, mm_got.isAdmin) {
				mmGetTree.t.Errorf("CoreMock.GetTree got unexpected parameter isAdmin, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTree.GetTreeMock.defaultExpectation.expectationOrigins.originIsAdmin, *mm_want_ptrs.isAdmin, mm_got.isAdmin, minimock.Diff(*mm_want_ptrs.isAdmin, mm_got.isAdmin))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTree.t.Errorf("CoreMock.GetTree got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTree.GetTreeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTree.GetTreeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTree.t.Fatal("No results are set for the CoreMock.GetTree")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmGetTree.funcGetTree != nil {
		return mmGetTree.funcGetTree(ctx, permissions, isAdmin)
	}
	mmGetTree.t.Fatalf("Unexpected call to CoreMock.GetTree. %v %v %v", ctx, permissions, isAdmin)
	return
}

// GetTreeAfterCounter returns a count of finished CoreMock.GetTree invocations
func (mmGetTree *CoreMock) GetTreeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTree.afterGetTreeCounter)
}

// GetTreeBeforeCounter returns a count of CoreMock.GetTree invocations
func (mmGetTree *CoreMock) GetTreeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTree.beforeGetTreeCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetTree.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTree *mCoreMockGetTree) Calls() []*CoreMockGetTreeParams {
	mmGetTree.mutex.RLock()

	argCopy := make([]*CoreMockGetTreeParams, len(mmGetTree.callArgs))
	copy(argCopy, mmGetTree.callArgs)

	mmGetTree.mutex.RUnlock()

	return argCopy
}

// MinimockGetTreeDone returns true if the count of the GetTree invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetTreeDone() bool {
	if m.GetTreeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTreeMock.invocationsDone()
}

// MinimockGetTreeInspect logs each unmet expectation
func (m *CoreMock) MinimockGetTreeInspect() {
	for _, e := range m.GetTreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetTree at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTreeCounter := mm_atomic.LoadUint64(&m.afterGetTreeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTreeMock.defaultExpectation != nil && afterGetTreeCounter < 1 {
		if m.GetTreeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetTree at\n%s", m.GetTreeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetTree at\n%s with params: %#v", m.GetTreeMock.defaultExpectation.expectationOrigins.origin, *m.GetTreeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTree != nil && afterGetTreeCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetTree at\n%s", m.funcGetTreeOrigin)
	}

	if !m.GetTreeMock.invocationsDone() && afterGetTreeCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetTree at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTreeMock.expectedInvocations), m.GetTreeMock.expectedInvocationsOrigin, afterGetTreeCounter)
	}
}

type mCoreMockGetVersion struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetVersionExpectation
	expectations       []*CoreMockGetVersionExpectation

	callArgs []*CoreMockGetVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetVersionExpectation specifies expectation struct of the Core.GetVersion
type CoreMockGetVersionExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetVersionParams
	paramPtrs          *CoreMockGetVersionParamPtrs
	expectationOrigins CoreMockGetVersionExpectationOrigins
	results            *CoreMockGetVersionResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetVersionParams contains parameters of the Core.GetVersion
type CoreMockGetVersionParams struct {
	ctx     context.Context
	id      uuid.UUID
	version int
}

// CoreMockGetVersionParamPtrs contains pointers to parameters of the Core.GetVersion
type CoreMockGetVersionParamPtrs struct {
	ctx     *context.Context
	id      *uuid.UUID
	version *int
}

// CoreMockGetVersionResults contains results of the Core.GetVersion
type CoreMockGetVersionResults struct {
	e1  entity.Entity
	err error
}

// CoreMockGetVersionOrigins contains origins of expectations of the Core.GetVersion
type CoreMockGetVersionExpectationOrigins struct {
	origin        string
	originCtx     string
	originId      string
	originVersion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVersion *mCoreMockGetVersion) Optional() *mCoreMockGetVersion {
	mmGetVersion.optional = true
	return mmGetVersion
}

// Expect sets up expected params for Core.GetVersion
func (mmGetVersion *mCoreMockGetVersion) Expect(ctx context.Context, id uuid.UUID, version int) *mCoreMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &CoreMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.paramPtrs != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by ExpectParams functions")
	}

	mmGetVersion.defaultExpectation.params = &CoreMockGetVersionParams{ctx, id, version}
	mmGetVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetVersion.expectations {
		if minimock.Equal(e.params, mmGetVersion.defaultExpectation.params) {
			mmGetVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVersion.defaultExpectation.params)
		}
	}

	return mmGetVersion
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetVersion
func (mmGetVersion *mCoreMockGetVersion) ExpectCtxParam1(ctx context.Context) *mCoreMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &CoreMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &CoreMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetVersion
}

// ExpectIdParam2 sets up expected param id for Core.GetVersion
func (mmGetVersion *mCoreMockGetVersion) ExpectIdParam2(id uuid.UUID) *mCoreMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &CoreMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &CoreMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.id = &id
	mmGetVersion.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetVersion
}

// ExpectVersionParam3 sets up expected param version for Core.GetVersion
func (mmGetVersion *mCoreMockGetVersion) ExpectVersionParam3(version int) *mCoreMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &CoreMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &CoreMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.version = &version
	mmGetVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmGetVersion
}

// Inspect accepts an inspector function that has same arguments as the Core.GetVersion
func (mmGetVersion *mCoreMockGetVersion) Inspect(f func(ctx context.Context, id uuid.UUID, version int)) *mCoreMockGetVersion {
	if mmGetVersion.mock.inspectFuncGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("Inspect function is already set for CoreMock.GetVersion")
	}

	mmGetVersion.mock.inspectFuncGetVersion = f

	return mmGetVersion
}

// Return sets up results that will be returned by Core.GetVersion
func (mmGetVersion *mCoreMockGetVersion) Return(e1 entity.Entity, err error) *CoreMock {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &CoreMockGetVersionExpectation{mock: mmGetVersion.mock}
	}
	mmGetVersion.defaultExpectation.results = &CoreMockGetVersionResults{e1, err}
	mmGetVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetVersion.mock
}

// Set uses given function f to mock the Core.GetVersion method
func (mmGetVersion *mCoreMockGetVersion) Set(f func(ctx context.Context, id uuid.UUID, version int) (e1 entity.Entity, err error)) *CoreMock {
	if mmGetVersion.defaultExpectation != nil {
		mmGetVersion.mock.t.Fatalf("Default expectation is already set for the Core.GetVersion method")
	}

	if len(mmGetVersion.expectations) > 0 {
		mmGetVersion.mock.t.Fatalf("Some expectations are already set for the Core.GetVersion method")
	}

	mmGetVersion.mock.funcGetVersion = f
	mmGetVersion.mock.funcGetVersionOrigin = minimock.CallerInfo(1)
	return mmGetVersion.mock
}

// When sets expectation for the Core.GetVersion which will trigger the result defined by the following
// Then helper
func (mmGetVersion *mCoreMockGetVersion) When(ctx context.Context, id uuid.UUID, version int) *CoreMockGetVersionExpectation {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("CoreMock.GetVersion mock is already set by Set")
	}

	expectation := &CoreMockGetVersionExpectation{
		mock:               mmGetVersion.mock,
		params:             &CoreMockGetVersionParams{ctx, id, version},
		expectationOrigins: CoreMockGetVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetVersion.expectations = append(mmGetVersion.expectations, expectation)
	return expectation
}

// Then sets up Core.GetVersion return parameters for the expectation previously defined by the When method
func (e *CoreMockGetVersionExpectation) Then(e1 entity.Entity, err error) *CoreMock {
	e.results = &CoreMockGetVersionResults{e1, err}
	return e.mock
}

// Times sets number of times Core.GetVersion should be invoked
func (mmGetVersion *mCoreMockGetVersion) Times(n uint64) *mCoreMockGetVersion {
	if n == 0 {
		mmGetVersion.mock.t.Fatalf("Times of CoreMock.GetVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVersion.expectedInvocations, n)
	mmGetVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetVersion
}

func (mmGetVersion *mCoreMockGetVersion) invocationsDone() bool {
	if len(mmGetVersion.expectations) == 0 && mmGetVersion.defaultExpectation == nil && mmGetVersion.mock.funcGetVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVersion.mock.afterGetVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVersion implements mm_usecase.Core
func (mmGetVersion *CoreMock) GetVersion(ctx context.Context, id uuid.UUID, version int) (e1 entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGetVersion.beforeGetVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersion.afterGetVersionCounter, 1)

	mmGetVersion.t.Helper()

	if mmGetVersion.inspectFuncGetVersion != nil {
		mmGetVersion.inspectFuncGetVersion(ctx, id, version)
	}

	mm_params := CoreMockGetVersionParams{ctx, id, version}

	// Record call args
	mmGetVersion.GetVersionMock.mutex.Lock()
	mmGetVersion.GetVersionMock.callArgs = append(mmGetVersion.GetVersionMock.callArgs, &mm_params)
	mmGetVersion.GetVersionMock.mutex.Unlock()

	for _, e := range mmGetVersion.GetVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGetVersion.GetVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersion.GetVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVersion.GetVersionMock.defaultExpectation.params
		mm_want_ptrs := mmGetVersion.GetVersionMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetVersionParams{ctx, id, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetVersion.t.Errorf("CoreMock.GetVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetVersion.t.Errorf("CoreMock.GetVersion got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmGetVersion.t.Errorf("CoreMock.GetVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVersion.t.Errorf("CoreMock.GetVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVersion.GetVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVersion.t.Fatal("No results are set for the CoreMock.GetVersion")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGetVersion.funcGetVersion != nil {
		return mmGetVersion.funcGetVersion(ctx, id, version)
	}
	mmGetVersion.t.Fatalf("Unexpected call to CoreMock.GetVersion. %v %v %v", ctx, id, version)
	return
}

// GetVersionAfterCounter returns a count of finished CoreMock.GetVersion invocations
func (mmGetVersion *CoreMock) GetVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersion.afterGetVersionCounter)
}

// GetVersionBeforeCounter returns a count of CoreMock.GetVersion invocations
func (mmGetVersion *CoreMock) GetVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersion.beforeGetVersionCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVersion *mCoreMockGetVersion) Calls() []*CoreMockGetVersionParams {
	mmGetVersion.mutex.RLock()

	argCopy := make([]*CoreMockGetVersionParams, len(mmGetVersion.callArgs))
	copy(argCopy, mmGetVersion.callArgs)

	mmGetVersion.mutex.RUnlock()

	return argCopy
}

// MinimockGetVersionDone returns true if the count of the GetVersion invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetVersionDone() bool {
	if m.GetVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetVersionMock.invocationsDone()
}

// MinimockGetVersionInspect logs each unmet expectation
func (m *CoreMock) MinimockGetVersionInspect() {
	for _, e := range m.GetVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetVersionCounter := mm_atomic.LoadUint64(&m.afterGetVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionMock.defaultExpectation != nil && afterGetVersionCounter < 1 {
		if m.GetVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetVersion at\n%s", m.GetVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetVersion at\n%s with params: %#v", m.GetVersionMock.defaultExpectation.expectationOrigins.origin, *m.GetVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersion != nil && afterGetVersionCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetVersion at\n%s", m.funcGetVersionOrigin)
	}

	if !m.GetVersionMock.invocationsDone() && afterGetVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetVersionMock.expectedInvocations), m.GetVersionMock.expectedInvocationsOrigin, afterGetVersionCounter)
	}
}

type mCoreMockGetVersionsList struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockGetVersionsListExpectation
	expectations       []*CoreMockGetVersionsListExpectation

	callArgs []*CoreMockGetVersionsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockGetVersionsListExpectation specifies expectation struct of the Core.GetVersionsList
type CoreMockGetVersionsListExpectation struct {
	mock               *CoreMock
	params             *CoreMockGetVersionsListParams
	paramPtrs          *CoreMockGetVersionsListParamPtrs
	expectationOrigins CoreMockGetVersionsListExpectationOrigins
	results            *CoreMockGetVersionsListResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockGetVersionsListParams contains parameters of the Core.GetVersionsList
type CoreMockGetVersionsListParams struct {
	ctx context.Context
	id  uuid.UUID
}

// CoreMockGetVersionsListParamPtrs contains pointers to parameters of the Core.GetVersionsList
type CoreMockGetVersionsListParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// CoreMockGetVersionsListResults contains results of the Core.GetVersionsList
type CoreMockGetVersionsListResults struct {
	ea1 []entity.Entity
	err error
}

// CoreMockGetVersionsListOrigins contains origins of expectations of the Core.GetVersionsList
type CoreMockGetVersionsListExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVersionsList *mCoreMockGetVersionsList) Optional() *mCoreMockGetVersionsList {
	mmGetVersionsList.optional = true
	return mmGetVersionsList
}

// Expect sets up expected params for Core.GetVersionsList
func (mmGetVersionsList *mCoreMockGetVersionsList) Expect(ctx context.Context, id uuid.UUID) *mCoreMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &CoreMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by ExpectParams functions")
	}

	mmGetVersionsList.defaultExpectation.params = &CoreMockGetVersionsListParams{ctx, id}
	mmGetVersionsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetVersionsList.expectations {
		if minimock.Equal(e.params, mmGetVersionsList.defaultExpectation.params) {
			mmGetVersionsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVersionsList.defaultExpectation.params)
		}
	}

	return mmGetVersionsList
}

// ExpectCtxParam1 sets up expected param ctx for Core.GetVersionsList
func (mmGetVersionsList *mCoreMockGetVersionsList) ExpectCtxParam1(ctx context.Context) *mCoreMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &CoreMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.params != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Expect")
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs == nil {
		mmGetVersionsList.defaultExpectation.paramPtrs = &CoreMockGetVersionsListParamPtrs{}
	}
	mmGetVersionsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetVersionsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetVersionsList
}

// ExpectIdParam2 sets up expected param id for Core.GetVersionsList
func (mmGetVersionsList *mCoreMockGetVersionsList) ExpectIdParam2(id uuid.UUID) *mCoreMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &CoreMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.params != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Expect")
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs == nil {
		mmGetVersionsList.defaultExpectation.paramPtrs = &CoreMockGetVersionsListParamPtrs{}
	}
	mmGetVersionsList.defaultExpectation.paramPtrs.id = &id
	mmGetVersionsList.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetVersionsList
}

// Inspect accepts an inspector function that has same arguments as the Core.GetVersionsList
func (mmGetVersionsList *mCoreMockGetVersionsList) Inspect(f func(ctx context.Context, id uuid.UUID)) *mCoreMockGetVersionsList {
	if mmGetVersionsList.mock.inspectFuncGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("Inspect function is already set for CoreMock.GetVersionsList")
	}

	mmGetVersionsList.mock.inspectFuncGetVersionsList = f

	return mmGetVersionsList
}

// Return sets up results that will be returned by Core.GetVersionsList
func (mmGetVersionsList *mCoreMockGetVersionsList) Return(ea1 []entity.Entity, err error) *CoreMock {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &CoreMockGetVersionsListExpectation{mock: mmGetVersionsList.mock}
	}
	mmGetVersionsList.defaultExpectation.results = &CoreMockGetVersionsListResults{ea1, err}
	mmGetVersionsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList.mock
}

// Set uses given function f to mock the Core.GetVersionsList method
func (mmGetVersionsList *mCoreMockGetVersionsList) Set(f func(ctx context.Context, id uuid.UUID) (ea1 []entity.Entity, err error)) *CoreMock {
	if mmGetVersionsList.defaultExpectation != nil {
		mmGetVersionsList.mock.t.Fatalf("Default expectation is already set for the Core.GetVersionsList method")
	}

	if len(mmGetVersionsList.expectations) > 0 {
		mmGetVersionsList.mock.t.Fatalf("Some expectations are already set for the Core.GetVersionsList method")
	}

	mmGetVersionsList.mock.funcGetVersionsList = f
	mmGetVersionsList.mock.funcGetVersionsListOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList.mock
}

// When sets expectation for the Core.GetVersionsList which will trigger the result defined by the following
// Then helper
func (mmGetVersionsList *mCoreMockGetVersionsList) When(ctx context.Context, id uuid.UUID) *CoreMockGetVersionsListExpectation {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("CoreMock.GetVersionsList mock is already set by Set")
	}

	expectation := &CoreMockGetVersionsListExpectation{
		mock:               mmGetVersionsList.mock,
		params:             &CoreMockGetVersionsListParams{ctx, id},
		expectationOrigins: CoreMockGetVersionsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetVersionsList.expectations = append(mmGetVersionsList.expectations, expectation)
	return expectation
}

// Then sets up Core.GetVersionsList return parameters for the expectation previously defined by the When method
func (e *CoreMockGetVersionsListExpectation) Then(ea1 []entity.Entity, err error) *CoreMock {
	e.results = &CoreMockGetVersionsListResults{ea1, err}
	return e.mock
}

// Times sets number of times Core.GetVersionsList should be invoked
func (mmGetVersionsList *mCoreMockGetVersionsList) Times(n uint64) *mCoreMockGetVersionsList {
	if n == 0 {
		mmGetVersionsList.mock.t.Fatalf("Times of CoreMock.GetVersionsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVersionsList.expectedInvocations, n)
	mmGetVersionsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList
}

func (mmGetVersionsList *mCoreMockGetVersionsList) invocationsDone() bool {
	if len(mmGetVersionsList.expectations) == 0 && mmGetVersionsList.defaultExpectation == nil && mmGetVersionsList.mock.funcGetVersionsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVersionsList.mock.afterGetVersionsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVersionsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVersionsList implements mm_usecase.Core
func (mmGetVersionsList *CoreMock) GetVersionsList(ctx context.Context, id uuid.UUID) (ea1 []entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGetVersionsList.beforeGetVersionsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersionsList.afterGetVersionsListCounter, 1)

	mmGetVersionsList.t.Helper()

	if mmGetVersionsList.inspectFuncGetVersionsList != nil {
		mmGetVersionsList.inspectFuncGetVersionsList(ctx, id)
	}

	mm_params := CoreMockGetVersionsListParams{ctx, id}

	// Record call args
	mmGetVersionsList.GetVersionsListMock.mutex.Lock()
	mmGetVersionsList.GetVersionsListMock.callArgs = append(mmGetVersionsList.GetVersionsListMock.callArgs, &mm_params)
	mmGetVersionsList.GetVersionsListMock.mutex.Unlock()

	for _, e := range mmGetVersionsList.GetVersionsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetVersionsList.GetVersionsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersionsList.GetVersionsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVersionsList.GetVersionsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetVersionsList.GetVersionsListMock.defaultExpectation.paramPtrs

		mm_got := CoreMockGetVersionsListParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetVersionsList.t.Errorf("CoreMock.GetVersionsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetVersionsList.t.Errorf("CoreMock.GetVersionsList got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVersionsList.t.Errorf("CoreMock.GetVersionsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVersionsList.GetVersionsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVersionsList.t.Fatal("No results are set for the CoreMock.GetVersionsList")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetVersionsList.funcGetVersionsList != nil {
		return mmGetVersionsList.funcGetVersionsList(ctx, id)
	}
	mmGetVersionsList.t.Fatalf("Unexpected call to CoreMock.GetVersionsList. %v %v", ctx, id)
	return
}

// GetVersionsListAfterCounter returns a count of finished CoreMock.GetVersionsList invocations
func (mmGetVersionsList *CoreMock) GetVersionsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionsList.afterGetVersionsListCounter)
}

// GetVersionsListBeforeCounter returns a count of CoreMock.GetVersionsList invocations
func (mmGetVersionsList *CoreMock) GetVersionsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionsList.beforeGetVersionsListCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.GetVersionsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVersionsList *mCoreMockGetVersionsList) Calls() []*CoreMockGetVersionsListParams {
	mmGetVersionsList.mutex.RLock()

	argCopy := make([]*CoreMockGetVersionsListParams, len(mmGetVersionsList.callArgs))
	copy(argCopy, mmGetVersionsList.callArgs)

	mmGetVersionsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetVersionsListDone returns true if the count of the GetVersionsList invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockGetVersionsListDone() bool {
	if m.GetVersionsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetVersionsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetVersionsListMock.invocationsDone()
}

// MinimockGetVersionsListInspect logs each unmet expectation
func (m *CoreMock) MinimockGetVersionsListInspect() {
	for _, e := range m.GetVersionsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.GetVersionsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetVersionsListCounter := mm_atomic.LoadUint64(&m.afterGetVersionsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionsListMock.defaultExpectation != nil && afterGetVersionsListCounter < 1 {
		if m.GetVersionsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.GetVersionsList at\n%s", m.GetVersionsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.GetVersionsList at\n%s with params: %#v", m.GetVersionsListMock.defaultExpectation.expectationOrigins.origin, *m.GetVersionsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersionsList != nil && afterGetVersionsListCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.GetVersionsList at\n%s", m.funcGetVersionsListOrigin)
	}

	if !m.GetVersionsListMock.invocationsDone() && afterGetVersionsListCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.GetVersionsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetVersionsListMock.expectedInvocations), m.GetVersionsListMock.expectedInvocationsOrigin, afterGetVersionsListCounter)
	}
}

type mCoreMockUpdate struct {
	optional           bool
	mock               *CoreMock
	defaultExpectation *CoreMockUpdateExpectation
	expectations       []*CoreMockUpdateExpectation

	callArgs []*CoreMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CoreMockUpdateExpectation specifies expectation struct of the Core.Update
type CoreMockUpdateExpectation struct {
	mock               *CoreMock
	params             *CoreMockUpdateParams
	paramPtrs          *CoreMockUpdateParamPtrs
	expectationOrigins CoreMockUpdateExpectationOrigins
	results            *CoreMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// CoreMockUpdateParams contains parameters of the Core.Update
type CoreMockUpdateParams struct {
	ctx context.Context
	req entity.UpdateEntityReq
}

// CoreMockUpdateParamPtrs contains pointers to parameters of the Core.Update
type CoreMockUpdateParamPtrs struct {
	ctx *context.Context
	req *entity.UpdateEntityReq
}

// CoreMockUpdateResults contains results of the Core.Update
type CoreMockUpdateResults struct {
	err error
}

// CoreMockUpdateOrigins contains origins of expectations of the Core.Update
type CoreMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mCoreMockUpdate) Optional() *mCoreMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for Core.Update
func (mmUpdate *mCoreMockUpdate) Expect(ctx context.Context, req entity.UpdateEntityReq) *mCoreMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CoreMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &CoreMockUpdateParams{ctx, req}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Core.Update
func (mmUpdate *mCoreMockUpdate) ExpectCtxParam1(ctx context.Context) *mCoreMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CoreMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CoreMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectReqParam2 sets up expected param req for Core.Update
func (mmUpdate *mCoreMockUpdate) ExpectReqParam2(req entity.UpdateEntityReq) *mCoreMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CoreMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CoreMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.req = &req
	mmUpdate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Core.Update
func (mmUpdate *mCoreMockUpdate) Inspect(f func(ctx context.Context, req entity.UpdateEntityReq)) *mCoreMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for CoreMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Core.Update
func (mmUpdate *mCoreMockUpdate) Return(err error) *CoreMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CoreMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &CoreMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the Core.Update method
func (mmUpdate *mCoreMockUpdate) Set(f func(ctx context.Context, req entity.UpdateEntityReq) (err error)) *CoreMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Core.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Core.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the Core.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mCoreMockUpdate) When(ctx context.Context, req entity.UpdateEntityReq) *CoreMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CoreMock.Update mock is already set by Set")
	}

	expectation := &CoreMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &CoreMockUpdateParams{ctx, req},
		expectationOrigins: CoreMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Core.Update return parameters for the expectation previously defined by the When method
func (e *CoreMockUpdateExpectation) Then(err error) *CoreMock {
	e.results = &CoreMockUpdateResults{err}
	return e.mock
}

// Times sets number of times Core.Update should be invoked
func (mmUpdate *mCoreMockUpdate) Times(n uint64) *mCoreMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of CoreMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mCoreMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_usecase.Core
func (mmUpdate *CoreMock) Update(ctx context.Context, req entity.UpdateEntityReq) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, req)
	}

	mm_params := CoreMockUpdateParams{ctx, req}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := CoreMockUpdateParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("CoreMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdate.t.Errorf("CoreMock.Update got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("CoreMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the CoreMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, req)
	}
	mmUpdate.t.Fatalf("Unexpected call to CoreMock.Update. %v %v", ctx, req)
	return
}

// UpdateAfterCounter returns a count of finished CoreMock.Update invocations
func (mmUpdate *CoreMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of CoreMock.Update invocations
func (mmUpdate *CoreMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to CoreMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mCoreMockUpdate) Calls() []*CoreMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*CoreMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *CoreMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *CoreMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoreMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CoreMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CoreMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to CoreMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to CoreMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CoreMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetListItemInspect()

			m.MinimockGetPermittedHierarchyInspect()

			m.MinimockGetTreeInspect()

			m.MinimockGetVersionInspect()

			m.MinimockGetVersionsListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetListItemDone() &&
		m.MinimockGetPermittedHierarchyDone() &&
		m.MinimockGetTreeDone() &&
		m.MinimockGetVersionDone() &&
		m.MinimockGetVersionsListDone() &&
		m.MinimockUpdateDone()
}
