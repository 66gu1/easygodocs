// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/entity/transport/http.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/66gu1/easygodocs/internal/app/entity"
	"github.com/66gu1/easygodocs/internal/app/entity/usecase"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ServiceMock implements mm_http.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, req usecase.CreateEntityCmd) (u1 uuid.UUID, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, req usecase.CreateEntityCmd)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mServiceMockCreate

	funcDelete          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mServiceMockDelete

	funcGet          func(ctx context.Context, id uuid.UUID) (e1 entity.Entity, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mServiceMockGet

	funcGetTree          func(ctx context.Context) (t1 entity.Tree, err error)
	funcGetTreeOrigin    string
	inspectFuncGetTree   func(ctx context.Context)
	afterGetTreeCounter  uint64
	beforeGetTreeCounter uint64
	GetTreeMock          mServiceMockGetTree

	funcGetVersion          func(ctx context.Context, id uuid.UUID, version int) (e1 entity.Entity, err error)
	funcGetVersionOrigin    string
	inspectFuncGetVersion   func(ctx context.Context, id uuid.UUID, version int)
	afterGetVersionCounter  uint64
	beforeGetVersionCounter uint64
	GetVersionMock          mServiceMockGetVersion

	funcGetVersionsList          func(ctx context.Context, id uuid.UUID) (ea1 []entity.Entity, err error)
	funcGetVersionsListOrigin    string
	inspectFuncGetVersionsList   func(ctx context.Context, id uuid.UUID)
	afterGetVersionsListCounter  uint64
	beforeGetVersionsListCounter uint64
	GetVersionsListMock          mServiceMockGetVersionsList

	funcUpdate          func(ctx context.Context, req usecase.UpdateEntityCmd) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, req usecase.UpdateEntityCmd)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mServiceMockUpdate
}

// NewServiceMock returns a mock for mm_http.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ServiceMockCreateParams{}

	m.DeleteMock = mServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ServiceMockDeleteParams{}

	m.GetMock = mServiceMockGet{mock: m}
	m.GetMock.callArgs = []*ServiceMockGetParams{}

	m.GetTreeMock = mServiceMockGetTree{mock: m}
	m.GetTreeMock.callArgs = []*ServiceMockGetTreeParams{}

	m.GetVersionMock = mServiceMockGetVersion{mock: m}
	m.GetVersionMock.callArgs = []*ServiceMockGetVersionParams{}

	m.GetVersionsListMock = mServiceMockGetVersionsList{mock: m}
	m.GetVersionsListMock.callArgs = []*ServiceMockGetVersionsListParams{}

	m.UpdateMock = mServiceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*ServiceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockCreate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateExpectation
	expectations       []*ServiceMockCreateExpectation

	callArgs []*ServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateExpectation specifies expectation struct of the Service.Create
type ServiceMockCreateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateParams
	paramPtrs          *ServiceMockCreateParamPtrs
	expectationOrigins ServiceMockCreateExpectationOrigins
	results            *ServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateParams contains parameters of the Service.Create
type ServiceMockCreateParams struct {
	ctx context.Context
	req usecase.CreateEntityCmd
}

// ServiceMockCreateParamPtrs contains pointers to parameters of the Service.Create
type ServiceMockCreateParamPtrs struct {
	ctx *context.Context
	req *usecase.CreateEntityCmd
}

// ServiceMockCreateResults contains results of the Service.Create
type ServiceMockCreateResults struct {
	u1  uuid.UUID
	err error
}

// ServiceMockCreateOrigins contains origins of expectations of the Service.Create
type ServiceMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mServiceMockCreate) Optional() *mServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Service.Create
func (mmCreate *mServiceMockCreate) Expect(ctx context.Context, req usecase.CreateEntityCmd) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ServiceMockCreateParams{ctx, req}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Service.Create
func (mmCreate *mServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectReqParam2 sets up expected param req for Service.Create
func (mmCreate *mServiceMockCreate) ExpectReqParam2(req usecase.CreateEntityCmd) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.req = &req
	mmCreate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Service.Create
func (mmCreate *mServiceMockCreate) Inspect(f func(ctx context.Context, req usecase.CreateEntityCmd)) *mServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Service.Create
func (mmCreate *mServiceMockCreate) Return(u1 uuid.UUID, err error) *ServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ServiceMockCreateResults{u1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the Service.Create method
func (mmCreate *mServiceMockCreate) Set(f func(ctx context.Context, req usecase.CreateEntityCmd) (u1 uuid.UUID, err error)) *ServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Service.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Service.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the Service.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mServiceMockCreate) When(ctx context.Context, req usecase.CreateEntityCmd) *ServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	expectation := &ServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ServiceMockCreateParams{ctx, req},
		expectationOrigins: ServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Service.Create return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateExpectation) Then(u1 uuid.UUID, err error) *ServiceMock {
	e.results = &ServiceMockCreateResults{u1, err}
	return e.mock
}

// Times sets number of times Service.Create should be invoked
func (mmCreate *mServiceMockCreate) Times(n uint64) *mServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_http.Service
func (mmCreate *ServiceMock) Create(ctx context.Context, req usecase.CreateEntityCmd) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, req)
	}

	mm_params := ServiceMockCreateParams{ctx, req}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreate.t.Errorf("ServiceMock.Create got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ServiceMock.Create")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, req)
	}
	mmCreate.t.Fatalf("Unexpected call to ServiceMock.Create. %v %v", ctx, req)
	return
}

// CreateAfterCounter returns a count of finished ServiceMock.Create invocations
func (mmCreate *ServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ServiceMock.Create invocations
func (mmCreate *ServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mServiceMockCreate) Calls() []*ServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mServiceMockDelete struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteExpectation
	expectations       []*ServiceMockDeleteExpectation

	callArgs []*ServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteExpectation specifies expectation struct of the Service.Delete
type ServiceMockDeleteExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteParams
	paramPtrs          *ServiceMockDeleteParamPtrs
	expectationOrigins ServiceMockDeleteExpectationOrigins
	results            *ServiceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteParams contains parameters of the Service.Delete
type ServiceMockDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockDeleteParamPtrs contains pointers to parameters of the Service.Delete
type ServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// ServiceMockDeleteResults contains results of the Service.Delete
type ServiceMockDeleteResults struct {
	err error
}

// ServiceMockDeleteOrigins contains origins of expectations of the Service.Delete
type ServiceMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mServiceMockDelete) Optional() *mServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Service.Delete
func (mmDelete *mServiceMockDelete) Expect(ctx context.Context, id uuid.UUID) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ServiceMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Service.Delete
func (mmDelete *mServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for Service.Delete
func (mmDelete *mServiceMockDelete) ExpectIdParam2(id uuid.UUID) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Service.Delete
func (mmDelete *mServiceMockDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Service.Delete
func (mmDelete *mServiceMockDelete) Return(err error) *ServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ServiceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Service.Delete method
func (mmDelete *mServiceMockDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *ServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Service.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Service.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Service.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mServiceMockDelete) When(ctx context.Context, id uuid.UUID) *ServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	expectation := &ServiceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &ServiceMockDeleteParams{ctx, id},
		expectationOrigins: ServiceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Service.Delete return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Service.Delete should be invoked
func (mmDelete *mServiceMockDelete) Times(n uint64) *mServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_http.Service
func (mmDelete *ServiceMock) Delete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := ServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to ServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished ServiceMock.Delete invocations
func (mmDelete *ServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ServiceMock.Delete invocations
func (mmDelete *ServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mServiceMockDelete) Calls() []*ServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mServiceMockGet struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetExpectation
	expectations       []*ServiceMockGetExpectation

	callArgs []*ServiceMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetExpectation specifies expectation struct of the Service.Get
type ServiceMockGetExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetParams
	paramPtrs          *ServiceMockGetParamPtrs
	expectationOrigins ServiceMockGetExpectationOrigins
	results            *ServiceMockGetResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetParams contains parameters of the Service.Get
type ServiceMockGetParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockGetParamPtrs contains pointers to parameters of the Service.Get
type ServiceMockGetParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// ServiceMockGetResults contains results of the Service.Get
type ServiceMockGetResults struct {
	e1  entity.Entity
	err error
}

// ServiceMockGetOrigins contains origins of expectations of the Service.Get
type ServiceMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mServiceMockGet) Optional() *mServiceMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Service.Get
func (mmGet *mServiceMockGet) Expect(ctx context.Context, id uuid.UUID) *mServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &ServiceMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Service.Get
func (mmGet *mServiceMockGet) ExpectCtxParam1(ctx context.Context) *mServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for Service.Get
func (mmGet *mServiceMockGet) ExpectIdParam2(id uuid.UUID) *mServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Service.Get
func (mmGet *mServiceMockGet) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ServiceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Service.Get
func (mmGet *mServiceMockGet) Return(e1 entity.Entity, err error) *ServiceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ServiceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ServiceMockGetResults{e1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Service.Get method
func (mmGet *mServiceMockGet) Set(f func(ctx context.Context, id uuid.UUID) (e1 entity.Entity, err error)) *ServiceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Service.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Service.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Service.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mServiceMockGet) When(ctx context.Context, id uuid.UUID) *ServiceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ServiceMock.Get mock is already set by Set")
	}

	expectation := &ServiceMockGetExpectation{
		mock:               mmGet.mock,
		params:             &ServiceMockGetParams{ctx, id},
		expectationOrigins: ServiceMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Service.Get return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetExpectation) Then(e1 entity.Entity, err error) *ServiceMock {
	e.results = &ServiceMockGetResults{e1, err}
	return e.mock
}

// Times sets number of times Service.Get should be invoked
func (mmGet *mServiceMockGet) Times(n uint64) *mServiceMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of ServiceMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mServiceMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_http.Service
func (mmGet *ServiceMock) Get(ctx context.Context, id uuid.UUID) (e1 entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := ServiceMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("ServiceMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("ServiceMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ServiceMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ServiceMock.Get")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to ServiceMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished ServiceMock.Get invocations
func (mmGet *ServiceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ServiceMock.Get invocations
func (mmGet *ServiceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mServiceMockGet) Calls() []*ServiceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ServiceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mServiceMockGetTree struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetTreeExpectation
	expectations       []*ServiceMockGetTreeExpectation

	callArgs []*ServiceMockGetTreeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetTreeExpectation specifies expectation struct of the Service.GetTree
type ServiceMockGetTreeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetTreeParams
	paramPtrs          *ServiceMockGetTreeParamPtrs
	expectationOrigins ServiceMockGetTreeExpectationOrigins
	results            *ServiceMockGetTreeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetTreeParams contains parameters of the Service.GetTree
type ServiceMockGetTreeParams struct {
	ctx context.Context
}

// ServiceMockGetTreeParamPtrs contains pointers to parameters of the Service.GetTree
type ServiceMockGetTreeParamPtrs struct {
	ctx *context.Context
}

// ServiceMockGetTreeResults contains results of the Service.GetTree
type ServiceMockGetTreeResults struct {
	t1  entity.Tree
	err error
}

// ServiceMockGetTreeOrigins contains origins of expectations of the Service.GetTree
type ServiceMockGetTreeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTree *mServiceMockGetTree) Optional() *mServiceMockGetTree {
	mmGetTree.optional = true
	return mmGetTree
}

// Expect sets up expected params for Service.GetTree
func (mmGetTree *mServiceMockGetTree) Expect(ctx context.Context) *mServiceMockGetTree {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("ServiceMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &ServiceMockGetTreeExpectation{}
	}

	if mmGetTree.defaultExpectation.paramPtrs != nil {
		mmGetTree.mock.t.Fatalf("ServiceMock.GetTree mock is already set by ExpectParams functions")
	}

	mmGetTree.defaultExpectation.params = &ServiceMockGetTreeParams{ctx}
	mmGetTree.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTree.expectations {
		if minimock.Equal(e.params, mmGetTree.defaultExpectation.params) {
			mmGetTree.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTree.defaultExpectation.params)
		}
	}

	return mmGetTree
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetTree
func (mmGetTree *mServiceMockGetTree) ExpectCtxParam1(ctx context.Context) *mServiceMockGetTree {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("ServiceMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &ServiceMockGetTreeExpectation{}
	}

	if mmGetTree.defaultExpectation.params != nil {
		mmGetTree.mock.t.Fatalf("ServiceMock.GetTree mock is already set by Expect")
	}

	if mmGetTree.defaultExpectation.paramPtrs == nil {
		mmGetTree.defaultExpectation.paramPtrs = &ServiceMockGetTreeParamPtrs{}
	}
	mmGetTree.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTree.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTree
}

// Inspect accepts an inspector function that has same arguments as the Service.GetTree
func (mmGetTree *mServiceMockGetTree) Inspect(f func(ctx context.Context)) *mServiceMockGetTree {
	if mmGetTree.mock.inspectFuncGetTree != nil {
		mmGetTree.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetTree")
	}

	mmGetTree.mock.inspectFuncGetTree = f

	return mmGetTree
}

// Return sets up results that will be returned by Service.GetTree
func (mmGetTree *mServiceMockGetTree) Return(t1 entity.Tree, err error) *ServiceMock {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("ServiceMock.GetTree mock is already set by Set")
	}

	if mmGetTree.defaultExpectation == nil {
		mmGetTree.defaultExpectation = &ServiceMockGetTreeExpectation{mock: mmGetTree.mock}
	}
	mmGetTree.defaultExpectation.results = &ServiceMockGetTreeResults{t1, err}
	mmGetTree.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTree.mock
}

// Set uses given function f to mock the Service.GetTree method
func (mmGetTree *mServiceMockGetTree) Set(f func(ctx context.Context) (t1 entity.Tree, err error)) *ServiceMock {
	if mmGetTree.defaultExpectation != nil {
		mmGetTree.mock.t.Fatalf("Default expectation is already set for the Service.GetTree method")
	}

	if len(mmGetTree.expectations) > 0 {
		mmGetTree.mock.t.Fatalf("Some expectations are already set for the Service.GetTree method")
	}

	mmGetTree.mock.funcGetTree = f
	mmGetTree.mock.funcGetTreeOrigin = minimock.CallerInfo(1)
	return mmGetTree.mock
}

// When sets expectation for the Service.GetTree which will trigger the result defined by the following
// Then helper
func (mmGetTree *mServiceMockGetTree) When(ctx context.Context) *ServiceMockGetTreeExpectation {
	if mmGetTree.mock.funcGetTree != nil {
		mmGetTree.mock.t.Fatalf("ServiceMock.GetTree mock is already set by Set")
	}

	expectation := &ServiceMockGetTreeExpectation{
		mock:               mmGetTree.mock,
		params:             &ServiceMockGetTreeParams{ctx},
		expectationOrigins: ServiceMockGetTreeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTree.expectations = append(mmGetTree.expectations, expectation)
	return expectation
}

// Then sets up Service.GetTree return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetTreeExpectation) Then(t1 entity.Tree, err error) *ServiceMock {
	e.results = &ServiceMockGetTreeResults{t1, err}
	return e.mock
}

// Times sets number of times Service.GetTree should be invoked
func (mmGetTree *mServiceMockGetTree) Times(n uint64) *mServiceMockGetTree {
	if n == 0 {
		mmGetTree.mock.t.Fatalf("Times of ServiceMock.GetTree mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTree.expectedInvocations, n)
	mmGetTree.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTree
}

func (mmGetTree *mServiceMockGetTree) invocationsDone() bool {
	if len(mmGetTree.expectations) == 0 && mmGetTree.defaultExpectation == nil && mmGetTree.mock.funcGetTree == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTree.mock.afterGetTreeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTree.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTree implements mm_http.Service
func (mmGetTree *ServiceMock) GetTree(ctx context.Context) (t1 entity.Tree, err error) {
	mm_atomic.AddUint64(&mmGetTree.beforeGetTreeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTree.afterGetTreeCounter, 1)

	mmGetTree.t.Helper()

	if mmGetTree.inspectFuncGetTree != nil {
		mmGetTree.inspectFuncGetTree(ctx)
	}

	mm_params := ServiceMockGetTreeParams{ctx}

	// Record call args
	mmGetTree.GetTreeMock.mutex.Lock()
	mmGetTree.GetTreeMock.callArgs = append(mmGetTree.GetTreeMock.callArgs, &mm_params)
	mmGetTree.GetTreeMock.mutex.Unlock()

	for _, e := range mmGetTree.GetTreeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmGetTree.GetTreeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTree.GetTreeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTree.GetTreeMock.defaultExpectation.params
		mm_want_ptrs := mmGetTree.GetTreeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetTreeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTree.t.Errorf("ServiceMock.GetTree got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTree.GetTreeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTree.t.Errorf("ServiceMock.GetTree got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTree.GetTreeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTree.GetTreeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTree.t.Fatal("No results are set for the ServiceMock.GetTree")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmGetTree.funcGetTree != nil {
		return mmGetTree.funcGetTree(ctx)
	}
	mmGetTree.t.Fatalf("Unexpected call to ServiceMock.GetTree. %v", ctx)
	return
}

// GetTreeAfterCounter returns a count of finished ServiceMock.GetTree invocations
func (mmGetTree *ServiceMock) GetTreeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTree.afterGetTreeCounter)
}

// GetTreeBeforeCounter returns a count of ServiceMock.GetTree invocations
func (mmGetTree *ServiceMock) GetTreeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTree.beforeGetTreeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetTree.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTree *mServiceMockGetTree) Calls() []*ServiceMockGetTreeParams {
	mmGetTree.mutex.RLock()

	argCopy := make([]*ServiceMockGetTreeParams, len(mmGetTree.callArgs))
	copy(argCopy, mmGetTree.callArgs)

	mmGetTree.mutex.RUnlock()

	return argCopy
}

// MinimockGetTreeDone returns true if the count of the GetTree invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetTreeDone() bool {
	if m.GetTreeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTreeMock.invocationsDone()
}

// MinimockGetTreeInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetTreeInspect() {
	for _, e := range m.GetTreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetTree at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTreeCounter := mm_atomic.LoadUint64(&m.afterGetTreeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTreeMock.defaultExpectation != nil && afterGetTreeCounter < 1 {
		if m.GetTreeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetTree at\n%s", m.GetTreeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetTree at\n%s with params: %#v", m.GetTreeMock.defaultExpectation.expectationOrigins.origin, *m.GetTreeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTree != nil && afterGetTreeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetTree at\n%s", m.funcGetTreeOrigin)
	}

	if !m.GetTreeMock.invocationsDone() && afterGetTreeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetTree at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTreeMock.expectedInvocations), m.GetTreeMock.expectedInvocationsOrigin, afterGetTreeCounter)
	}
}

type mServiceMockGetVersion struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetVersionExpectation
	expectations       []*ServiceMockGetVersionExpectation

	callArgs []*ServiceMockGetVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetVersionExpectation specifies expectation struct of the Service.GetVersion
type ServiceMockGetVersionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetVersionParams
	paramPtrs          *ServiceMockGetVersionParamPtrs
	expectationOrigins ServiceMockGetVersionExpectationOrigins
	results            *ServiceMockGetVersionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetVersionParams contains parameters of the Service.GetVersion
type ServiceMockGetVersionParams struct {
	ctx     context.Context
	id      uuid.UUID
	version int
}

// ServiceMockGetVersionParamPtrs contains pointers to parameters of the Service.GetVersion
type ServiceMockGetVersionParamPtrs struct {
	ctx     *context.Context
	id      *uuid.UUID
	version *int
}

// ServiceMockGetVersionResults contains results of the Service.GetVersion
type ServiceMockGetVersionResults struct {
	e1  entity.Entity
	err error
}

// ServiceMockGetVersionOrigins contains origins of expectations of the Service.GetVersion
type ServiceMockGetVersionExpectationOrigins struct {
	origin        string
	originCtx     string
	originId      string
	originVersion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVersion *mServiceMockGetVersion) Optional() *mServiceMockGetVersion {
	mmGetVersion.optional = true
	return mmGetVersion
}

// Expect sets up expected params for Service.GetVersion
func (mmGetVersion *mServiceMockGetVersion) Expect(ctx context.Context, id uuid.UUID, version int) *mServiceMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &ServiceMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.paramPtrs != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by ExpectParams functions")
	}

	mmGetVersion.defaultExpectation.params = &ServiceMockGetVersionParams{ctx, id, version}
	mmGetVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetVersion.expectations {
		if minimock.Equal(e.params, mmGetVersion.defaultExpectation.params) {
			mmGetVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVersion.defaultExpectation.params)
		}
	}

	return mmGetVersion
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetVersion
func (mmGetVersion *mServiceMockGetVersion) ExpectCtxParam1(ctx context.Context) *mServiceMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &ServiceMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &ServiceMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetVersion
}

// ExpectIdParam2 sets up expected param id for Service.GetVersion
func (mmGetVersion *mServiceMockGetVersion) ExpectIdParam2(id uuid.UUID) *mServiceMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &ServiceMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &ServiceMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.id = &id
	mmGetVersion.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetVersion
}

// ExpectVersionParam3 sets up expected param version for Service.GetVersion
func (mmGetVersion *mServiceMockGetVersion) ExpectVersionParam3(version int) *mServiceMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &ServiceMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &ServiceMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.version = &version
	mmGetVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmGetVersion
}

// Inspect accepts an inspector function that has same arguments as the Service.GetVersion
func (mmGetVersion *mServiceMockGetVersion) Inspect(f func(ctx context.Context, id uuid.UUID, version int)) *mServiceMockGetVersion {
	if mmGetVersion.mock.inspectFuncGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetVersion")
	}

	mmGetVersion.mock.inspectFuncGetVersion = f

	return mmGetVersion
}

// Return sets up results that will be returned by Service.GetVersion
func (mmGetVersion *mServiceMockGetVersion) Return(e1 entity.Entity, err error) *ServiceMock {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &ServiceMockGetVersionExpectation{mock: mmGetVersion.mock}
	}
	mmGetVersion.defaultExpectation.results = &ServiceMockGetVersionResults{e1, err}
	mmGetVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetVersion.mock
}

// Set uses given function f to mock the Service.GetVersion method
func (mmGetVersion *mServiceMockGetVersion) Set(f func(ctx context.Context, id uuid.UUID, version int) (e1 entity.Entity, err error)) *ServiceMock {
	if mmGetVersion.defaultExpectation != nil {
		mmGetVersion.mock.t.Fatalf("Default expectation is already set for the Service.GetVersion method")
	}

	if len(mmGetVersion.expectations) > 0 {
		mmGetVersion.mock.t.Fatalf("Some expectations are already set for the Service.GetVersion method")
	}

	mmGetVersion.mock.funcGetVersion = f
	mmGetVersion.mock.funcGetVersionOrigin = minimock.CallerInfo(1)
	return mmGetVersion.mock
}

// When sets expectation for the Service.GetVersion which will trigger the result defined by the following
// Then helper
func (mmGetVersion *mServiceMockGetVersion) When(ctx context.Context, id uuid.UUID, version int) *ServiceMockGetVersionExpectation {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("ServiceMock.GetVersion mock is already set by Set")
	}

	expectation := &ServiceMockGetVersionExpectation{
		mock:               mmGetVersion.mock,
		params:             &ServiceMockGetVersionParams{ctx, id, version},
		expectationOrigins: ServiceMockGetVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetVersion.expectations = append(mmGetVersion.expectations, expectation)
	return expectation
}

// Then sets up Service.GetVersion return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetVersionExpectation) Then(e1 entity.Entity, err error) *ServiceMock {
	e.results = &ServiceMockGetVersionResults{e1, err}
	return e.mock
}

// Times sets number of times Service.GetVersion should be invoked
func (mmGetVersion *mServiceMockGetVersion) Times(n uint64) *mServiceMockGetVersion {
	if n == 0 {
		mmGetVersion.mock.t.Fatalf("Times of ServiceMock.GetVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVersion.expectedInvocations, n)
	mmGetVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetVersion
}

func (mmGetVersion *mServiceMockGetVersion) invocationsDone() bool {
	if len(mmGetVersion.expectations) == 0 && mmGetVersion.defaultExpectation == nil && mmGetVersion.mock.funcGetVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVersion.mock.afterGetVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVersion implements mm_http.Service
func (mmGetVersion *ServiceMock) GetVersion(ctx context.Context, id uuid.UUID, version int) (e1 entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGetVersion.beforeGetVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersion.afterGetVersionCounter, 1)

	mmGetVersion.t.Helper()

	if mmGetVersion.inspectFuncGetVersion != nil {
		mmGetVersion.inspectFuncGetVersion(ctx, id, version)
	}

	mm_params := ServiceMockGetVersionParams{ctx, id, version}

	// Record call args
	mmGetVersion.GetVersionMock.mutex.Lock()
	mmGetVersion.GetVersionMock.callArgs = append(mmGetVersion.GetVersionMock.callArgs, &mm_params)
	mmGetVersion.GetVersionMock.mutex.Unlock()

	for _, e := range mmGetVersion.GetVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGetVersion.GetVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersion.GetVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVersion.GetVersionMock.defaultExpectation.params
		mm_want_ptrs := mmGetVersion.GetVersionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetVersionParams{ctx, id, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetVersion.t.Errorf("ServiceMock.GetVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetVersion.t.Errorf("ServiceMock.GetVersion got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmGetVersion.t.Errorf("ServiceMock.GetVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVersion.t.Errorf("ServiceMock.GetVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVersion.GetVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVersion.t.Fatal("No results are set for the ServiceMock.GetVersion")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGetVersion.funcGetVersion != nil {
		return mmGetVersion.funcGetVersion(ctx, id, version)
	}
	mmGetVersion.t.Fatalf("Unexpected call to ServiceMock.GetVersion. %v %v %v", ctx, id, version)
	return
}

// GetVersionAfterCounter returns a count of finished ServiceMock.GetVersion invocations
func (mmGetVersion *ServiceMock) GetVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersion.afterGetVersionCounter)
}

// GetVersionBeforeCounter returns a count of ServiceMock.GetVersion invocations
func (mmGetVersion *ServiceMock) GetVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersion.beforeGetVersionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVersion *mServiceMockGetVersion) Calls() []*ServiceMockGetVersionParams {
	mmGetVersion.mutex.RLock()

	argCopy := make([]*ServiceMockGetVersionParams, len(mmGetVersion.callArgs))
	copy(argCopy, mmGetVersion.callArgs)

	mmGetVersion.mutex.RUnlock()

	return argCopy
}

// MinimockGetVersionDone returns true if the count of the GetVersion invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetVersionDone() bool {
	if m.GetVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetVersionMock.invocationsDone()
}

// MinimockGetVersionInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetVersionInspect() {
	for _, e := range m.GetVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetVersionCounter := mm_atomic.LoadUint64(&m.afterGetVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionMock.defaultExpectation != nil && afterGetVersionCounter < 1 {
		if m.GetVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetVersion at\n%s", m.GetVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetVersion at\n%s with params: %#v", m.GetVersionMock.defaultExpectation.expectationOrigins.origin, *m.GetVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersion != nil && afterGetVersionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetVersion at\n%s", m.funcGetVersionOrigin)
	}

	if !m.GetVersionMock.invocationsDone() && afterGetVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetVersionMock.expectedInvocations), m.GetVersionMock.expectedInvocationsOrigin, afterGetVersionCounter)
	}
}

type mServiceMockGetVersionsList struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetVersionsListExpectation
	expectations       []*ServiceMockGetVersionsListExpectation

	callArgs []*ServiceMockGetVersionsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetVersionsListExpectation specifies expectation struct of the Service.GetVersionsList
type ServiceMockGetVersionsListExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetVersionsListParams
	paramPtrs          *ServiceMockGetVersionsListParamPtrs
	expectationOrigins ServiceMockGetVersionsListExpectationOrigins
	results            *ServiceMockGetVersionsListResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetVersionsListParams contains parameters of the Service.GetVersionsList
type ServiceMockGetVersionsListParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockGetVersionsListParamPtrs contains pointers to parameters of the Service.GetVersionsList
type ServiceMockGetVersionsListParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// ServiceMockGetVersionsListResults contains results of the Service.GetVersionsList
type ServiceMockGetVersionsListResults struct {
	ea1 []entity.Entity
	err error
}

// ServiceMockGetVersionsListOrigins contains origins of expectations of the Service.GetVersionsList
type ServiceMockGetVersionsListExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVersionsList *mServiceMockGetVersionsList) Optional() *mServiceMockGetVersionsList {
	mmGetVersionsList.optional = true
	return mmGetVersionsList
}

// Expect sets up expected params for Service.GetVersionsList
func (mmGetVersionsList *mServiceMockGetVersionsList) Expect(ctx context.Context, id uuid.UUID) *mServiceMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &ServiceMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by ExpectParams functions")
	}

	mmGetVersionsList.defaultExpectation.params = &ServiceMockGetVersionsListParams{ctx, id}
	mmGetVersionsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetVersionsList.expectations {
		if minimock.Equal(e.params, mmGetVersionsList.defaultExpectation.params) {
			mmGetVersionsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVersionsList.defaultExpectation.params)
		}
	}

	return mmGetVersionsList
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetVersionsList
func (mmGetVersionsList *mServiceMockGetVersionsList) ExpectCtxParam1(ctx context.Context) *mServiceMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &ServiceMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.params != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Expect")
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs == nil {
		mmGetVersionsList.defaultExpectation.paramPtrs = &ServiceMockGetVersionsListParamPtrs{}
	}
	mmGetVersionsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetVersionsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetVersionsList
}

// ExpectIdParam2 sets up expected param id for Service.GetVersionsList
func (mmGetVersionsList *mServiceMockGetVersionsList) ExpectIdParam2(id uuid.UUID) *mServiceMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &ServiceMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.params != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Expect")
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs == nil {
		mmGetVersionsList.defaultExpectation.paramPtrs = &ServiceMockGetVersionsListParamPtrs{}
	}
	mmGetVersionsList.defaultExpectation.paramPtrs.id = &id
	mmGetVersionsList.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetVersionsList
}

// Inspect accepts an inspector function that has same arguments as the Service.GetVersionsList
func (mmGetVersionsList *mServiceMockGetVersionsList) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockGetVersionsList {
	if mmGetVersionsList.mock.inspectFuncGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetVersionsList")
	}

	mmGetVersionsList.mock.inspectFuncGetVersionsList = f

	return mmGetVersionsList
}

// Return sets up results that will be returned by Service.GetVersionsList
func (mmGetVersionsList *mServiceMockGetVersionsList) Return(ea1 []entity.Entity, err error) *ServiceMock {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &ServiceMockGetVersionsListExpectation{mock: mmGetVersionsList.mock}
	}
	mmGetVersionsList.defaultExpectation.results = &ServiceMockGetVersionsListResults{ea1, err}
	mmGetVersionsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList.mock
}

// Set uses given function f to mock the Service.GetVersionsList method
func (mmGetVersionsList *mServiceMockGetVersionsList) Set(f func(ctx context.Context, id uuid.UUID) (ea1 []entity.Entity, err error)) *ServiceMock {
	if mmGetVersionsList.defaultExpectation != nil {
		mmGetVersionsList.mock.t.Fatalf("Default expectation is already set for the Service.GetVersionsList method")
	}

	if len(mmGetVersionsList.expectations) > 0 {
		mmGetVersionsList.mock.t.Fatalf("Some expectations are already set for the Service.GetVersionsList method")
	}

	mmGetVersionsList.mock.funcGetVersionsList = f
	mmGetVersionsList.mock.funcGetVersionsListOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList.mock
}

// When sets expectation for the Service.GetVersionsList which will trigger the result defined by the following
// Then helper
func (mmGetVersionsList *mServiceMockGetVersionsList) When(ctx context.Context, id uuid.UUID) *ServiceMockGetVersionsListExpectation {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("ServiceMock.GetVersionsList mock is already set by Set")
	}

	expectation := &ServiceMockGetVersionsListExpectation{
		mock:               mmGetVersionsList.mock,
		params:             &ServiceMockGetVersionsListParams{ctx, id},
		expectationOrigins: ServiceMockGetVersionsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetVersionsList.expectations = append(mmGetVersionsList.expectations, expectation)
	return expectation
}

// Then sets up Service.GetVersionsList return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetVersionsListExpectation) Then(ea1 []entity.Entity, err error) *ServiceMock {
	e.results = &ServiceMockGetVersionsListResults{ea1, err}
	return e.mock
}

// Times sets number of times Service.GetVersionsList should be invoked
func (mmGetVersionsList *mServiceMockGetVersionsList) Times(n uint64) *mServiceMockGetVersionsList {
	if n == 0 {
		mmGetVersionsList.mock.t.Fatalf("Times of ServiceMock.GetVersionsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVersionsList.expectedInvocations, n)
	mmGetVersionsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList
}

func (mmGetVersionsList *mServiceMockGetVersionsList) invocationsDone() bool {
	if len(mmGetVersionsList.expectations) == 0 && mmGetVersionsList.defaultExpectation == nil && mmGetVersionsList.mock.funcGetVersionsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVersionsList.mock.afterGetVersionsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVersionsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVersionsList implements mm_http.Service
func (mmGetVersionsList *ServiceMock) GetVersionsList(ctx context.Context, id uuid.UUID) (ea1 []entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGetVersionsList.beforeGetVersionsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersionsList.afterGetVersionsListCounter, 1)

	mmGetVersionsList.t.Helper()

	if mmGetVersionsList.inspectFuncGetVersionsList != nil {
		mmGetVersionsList.inspectFuncGetVersionsList(ctx, id)
	}

	mm_params := ServiceMockGetVersionsListParams{ctx, id}

	// Record call args
	mmGetVersionsList.GetVersionsListMock.mutex.Lock()
	mmGetVersionsList.GetVersionsListMock.callArgs = append(mmGetVersionsList.GetVersionsListMock.callArgs, &mm_params)
	mmGetVersionsList.GetVersionsListMock.mutex.Unlock()

	for _, e := range mmGetVersionsList.GetVersionsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetVersionsList.GetVersionsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersionsList.GetVersionsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVersionsList.GetVersionsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetVersionsList.GetVersionsListMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetVersionsListParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetVersionsList.t.Errorf("ServiceMock.GetVersionsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetVersionsList.t.Errorf("ServiceMock.GetVersionsList got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVersionsList.t.Errorf("ServiceMock.GetVersionsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVersionsList.GetVersionsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVersionsList.t.Fatal("No results are set for the ServiceMock.GetVersionsList")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetVersionsList.funcGetVersionsList != nil {
		return mmGetVersionsList.funcGetVersionsList(ctx, id)
	}
	mmGetVersionsList.t.Fatalf("Unexpected call to ServiceMock.GetVersionsList. %v %v", ctx, id)
	return
}

// GetVersionsListAfterCounter returns a count of finished ServiceMock.GetVersionsList invocations
func (mmGetVersionsList *ServiceMock) GetVersionsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionsList.afterGetVersionsListCounter)
}

// GetVersionsListBeforeCounter returns a count of ServiceMock.GetVersionsList invocations
func (mmGetVersionsList *ServiceMock) GetVersionsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionsList.beforeGetVersionsListCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetVersionsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVersionsList *mServiceMockGetVersionsList) Calls() []*ServiceMockGetVersionsListParams {
	mmGetVersionsList.mutex.RLock()

	argCopy := make([]*ServiceMockGetVersionsListParams, len(mmGetVersionsList.callArgs))
	copy(argCopy, mmGetVersionsList.callArgs)

	mmGetVersionsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetVersionsListDone returns true if the count of the GetVersionsList invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetVersionsListDone() bool {
	if m.GetVersionsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetVersionsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetVersionsListMock.invocationsDone()
}

// MinimockGetVersionsListInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetVersionsListInspect() {
	for _, e := range m.GetVersionsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetVersionsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetVersionsListCounter := mm_atomic.LoadUint64(&m.afterGetVersionsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionsListMock.defaultExpectation != nil && afterGetVersionsListCounter < 1 {
		if m.GetVersionsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetVersionsList at\n%s", m.GetVersionsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetVersionsList at\n%s with params: %#v", m.GetVersionsListMock.defaultExpectation.expectationOrigins.origin, *m.GetVersionsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersionsList != nil && afterGetVersionsListCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetVersionsList at\n%s", m.funcGetVersionsListOrigin)
	}

	if !m.GetVersionsListMock.invocationsDone() && afterGetVersionsListCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetVersionsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetVersionsListMock.expectedInvocations), m.GetVersionsListMock.expectedInvocationsOrigin, afterGetVersionsListCounter)
	}
}

type mServiceMockUpdate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateExpectation
	expectations       []*ServiceMockUpdateExpectation

	callArgs []*ServiceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUpdateExpectation specifies expectation struct of the Service.Update
type ServiceMockUpdateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUpdateParams
	paramPtrs          *ServiceMockUpdateParamPtrs
	expectationOrigins ServiceMockUpdateExpectationOrigins
	results            *ServiceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUpdateParams contains parameters of the Service.Update
type ServiceMockUpdateParams struct {
	ctx context.Context
	req usecase.UpdateEntityCmd
}

// ServiceMockUpdateParamPtrs contains pointers to parameters of the Service.Update
type ServiceMockUpdateParamPtrs struct {
	ctx *context.Context
	req *usecase.UpdateEntityCmd
}

// ServiceMockUpdateResults contains results of the Service.Update
type ServiceMockUpdateResults struct {
	err error
}

// ServiceMockUpdateOrigins contains origins of expectations of the Service.Update
type ServiceMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mServiceMockUpdate) Optional() *mServiceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for Service.Update
func (mmUpdate *mServiceMockUpdate) Expect(ctx context.Context, req usecase.UpdateEntityCmd) *mServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &ServiceMockUpdateParams{ctx, req}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Service.Update
func (mmUpdate *mServiceMockUpdate) ExpectCtxParam1(ctx context.Context) *mServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &ServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectReqParam2 sets up expected param req for Service.Update
func (mmUpdate *mServiceMockUpdate) ExpectReqParam2(req usecase.UpdateEntityCmd) *mServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &ServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.req = &req
	mmUpdate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Service.Update
func (mmUpdate *mServiceMockUpdate) Inspect(f func(ctx context.Context, req usecase.UpdateEntityCmd)) *mServiceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for ServiceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Service.Update
func (mmUpdate *mServiceMockUpdate) Return(err error) *ServiceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &ServiceMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the Service.Update method
func (mmUpdate *mServiceMockUpdate) Set(f func(ctx context.Context, req usecase.UpdateEntityCmd) (err error)) *ServiceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Service.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Service.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the Service.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mServiceMockUpdate) When(ctx context.Context, req usecase.UpdateEntityCmd) *ServiceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	expectation := &ServiceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &ServiceMockUpdateParams{ctx, req},
		expectationOrigins: ServiceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Service.Update return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times Service.Update should be invoked
func (mmUpdate *mServiceMockUpdate) Times(n uint64) *mServiceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of ServiceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mServiceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_http.Service
func (mmUpdate *ServiceMock) Update(ctx context.Context, req usecase.UpdateEntityCmd) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, req)
	}

	mm_params := ServiceMockUpdateParams{ctx, req}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUpdateParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("ServiceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdate.t.Errorf("ServiceMock.Update got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("ServiceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the ServiceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, req)
	}
	mmUpdate.t.Fatalf("Unexpected call to ServiceMock.Update. %v %v", ctx, req)
	return
}

// UpdateAfterCounter returns a count of finished ServiceMock.Update invocations
func (mmUpdate *ServiceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of ServiceMock.Update invocations
func (mmUpdate *ServiceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mServiceMockUpdate) Calls() []*ServiceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetTreeInspect()

			m.MinimockGetVersionInspect()

			m.MinimockGetVersionsListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetTreeDone() &&
		m.MinimockGetVersionDone() &&
		m.MinimockGetVersionsListDone() &&
		m.MinimockUpdateDone()
}
