// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/entity.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	mm_entity "github.com/66gu1/easygodocs/internal/app/entity"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// RepositoryMock implements mm_entity.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time) (err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mRepositoryMockCreate

	funcCreateDraft          func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID) (err error)
	funcCreateDraftOrigin    string
	inspectFuncCreateDraft   func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID)
	afterCreateDraftCounter  uint64
	beforeCreateDraftCounter uint64
	CreateDraftMock          mRepositoryMockCreateDraft

	funcDelete          func(ctx context.Context, ids []uuid.UUID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, ids []uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mRepositoryMockDelete

	funcGet          func(ctx context.Context, id uuid.UUID) (e1 mm_entity.Entity, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mRepositoryMockGet

	funcGetAll          func(ctx context.Context) (la1 []mm_entity.ListItem, err error)
	funcGetAllOrigin    string
	inspectFuncGetAll   func(ctx context.Context)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mRepositoryMockGetAll

	funcGetHierarchy          func(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType) (la1 []mm_entity.ListItem, err error)
	funcGetHierarchyOrigin    string
	inspectFuncGetHierarchy   func(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType)
	afterGetHierarchyCounter  uint64
	beforeGetHierarchyCounter uint64
	GetHierarchyMock          mRepositoryMockGetHierarchy

	funcGetListItem          func(ctx context.Context, id uuid.UUID) (l1 mm_entity.ListItem, err error)
	funcGetListItemOrigin    string
	inspectFuncGetListItem   func(ctx context.Context, id uuid.UUID)
	afterGetListItemCounter  uint64
	beforeGetListItemCounter uint64
	GetListItemMock          mRepositoryMockGetListItem

	funcGetVersion          func(ctx context.Context, id uuid.UUID, version int) (e1 mm_entity.Entity, err error)
	funcGetVersionOrigin    string
	inspectFuncGetVersion   func(ctx context.Context, id uuid.UUID, version int)
	afterGetVersionCounter  uint64
	beforeGetVersionCounter uint64
	GetVersionMock          mRepositoryMockGetVersion

	funcGetVersionsList          func(ctx context.Context, id uuid.UUID) (ea1 []mm_entity.Entity, err error)
	funcGetVersionsListOrigin    string
	inspectFuncGetVersionsList   func(ctx context.Context, id uuid.UUID)
	afterGetVersionsListCounter  uint64
	beforeGetVersionsListCounter uint64
	GetVersionsListMock          mRepositoryMockGetVersionsList

	funcUpdate          func(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mRepositoryMockUpdate

	funcUpdateDraft          func(ctx context.Context, req mm_entity.UpdateEntityReq) (err error)
	funcUpdateDraftOrigin    string
	inspectFuncUpdateDraft   func(ctx context.Context, req mm_entity.UpdateEntityReq)
	afterUpdateDraftCounter  uint64
	beforeUpdateDraftCounter uint64
	UpdateDraftMock          mRepositoryMockUpdateDraft
}

// NewRepositoryMock returns a mock for mm_entity.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*RepositoryMockCreateParams{}

	m.CreateDraftMock = mRepositoryMockCreateDraft{mock: m}
	m.CreateDraftMock.callArgs = []*RepositoryMockCreateDraftParams{}

	m.DeleteMock = mRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*RepositoryMockDeleteParams{}

	m.GetMock = mRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*RepositoryMockGetParams{}

	m.GetAllMock = mRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*RepositoryMockGetAllParams{}

	m.GetHierarchyMock = mRepositoryMockGetHierarchy{mock: m}
	m.GetHierarchyMock.callArgs = []*RepositoryMockGetHierarchyParams{}

	m.GetListItemMock = mRepositoryMockGetListItem{mock: m}
	m.GetListItemMock.callArgs = []*RepositoryMockGetListItemParams{}

	m.GetVersionMock = mRepositoryMockGetVersion{mock: m}
	m.GetVersionMock.callArgs = []*RepositoryMockGetVersionParams{}

	m.GetVersionsListMock = mRepositoryMockGetVersionsList{mock: m}
	m.GetVersionsListMock.callArgs = []*RepositoryMockGetVersionsListParams{}

	m.UpdateMock = mRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*RepositoryMockUpdateParams{}

	m.UpdateDraftMock = mRepositoryMockUpdateDraft{mock: m}
	m.UpdateDraftMock.callArgs = []*RepositoryMockUpdateDraftParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCreate struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateExpectation
	expectations       []*RepositoryMockCreateExpectation

	callArgs []*RepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateExpectation specifies expectation struct of the Repository.Create
type RepositoryMockCreateExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateParams
	paramPtrs          *RepositoryMockCreateParamPtrs
	expectationOrigins RepositoryMockCreateExpectationOrigins
	results            *RepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateParams contains parameters of the Repository.Create
type RepositoryMockCreateParams struct {
	ctx       context.Context
	req       mm_entity.CreateEntityReq
	id        uuid.UUID
	createdAt time.Time
}

// RepositoryMockCreateParamPtrs contains pointers to parameters of the Repository.Create
type RepositoryMockCreateParamPtrs struct {
	ctx       *context.Context
	req       *mm_entity.CreateEntityReq
	id        *uuid.UUID
	createdAt *time.Time
}

// RepositoryMockCreateResults contains results of the Repository.Create
type RepositoryMockCreateResults struct {
	err error
}

// RepositoryMockCreateOrigins contains origins of expectations of the Repository.Create
type RepositoryMockCreateExpectationOrigins struct {
	origin          string
	originCtx       string
	originReq       string
	originId        string
	originCreatedAt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mRepositoryMockCreate) Optional() *mRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Repository.Create
func (mmCreate *mRepositoryMockCreate) Expect(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &RepositoryMockCreateParams{ctx, req, id, createdAt}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Create
func (mmCreate *mRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &RepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectReqParam2 sets up expected param req for Repository.Create
func (mmCreate *mRepositoryMockCreate) ExpectReqParam2(req mm_entity.CreateEntityReq) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &RepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.req = &req
	mmCreate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectIdParam3 sets up expected param id for Repository.Create
func (mmCreate *mRepositoryMockCreate) ExpectIdParam3(id uuid.UUID) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &RepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.id = &id
	mmCreate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectCreatedAtParam4 sets up expected param createdAt for Repository.Create
func (mmCreate *mRepositoryMockCreate) ExpectCreatedAtParam4(createdAt time.Time) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &RepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.createdAt = &createdAt
	mmCreate.defaultExpectation.expectationOrigins.originCreatedAt = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Repository.Create
func (mmCreate *mRepositoryMockCreate) Inspect(f func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time)) *mRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Repository.Create
func (mmCreate *mRepositoryMockCreate) Return(err error) *RepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &RepositoryMockCreateResults{err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the Repository.Create method
func (mmCreate *mRepositoryMockCreate) Set(f func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time) (err error)) *RepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Repository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Repository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the Repository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mRepositoryMockCreate) When(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time) *RepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	expectation := &RepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &RepositoryMockCreateParams{ctx, req, id, createdAt},
		expectationOrigins: RepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Repository.Create return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateResults{err}
	return e.mock
}

// Times sets number of times Repository.Create should be invoked
func (mmCreate *mRepositoryMockCreate) Times(n uint64) *mRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of RepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_entity.Repository
func (mmCreate *RepositoryMock) Create(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID, createdAt time.Time) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, req, id, createdAt)
	}

	mm_params := RepositoryMockCreateParams{ctx, req, id, createdAt}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateParams{ctx, req, id, createdAt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.createdAt != nil && !minimock.Equal(*mm_want_ptrs.createdAt, mm_got.createdAt) {
				mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameter createdAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCreatedAt, *mm_want_ptrs.createdAt, mm_got.createdAt, minimock.Diff(*mm_want_ptrs.createdAt, mm_got.createdAt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the RepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, req, id, createdAt)
	}
	mmCreate.t.Fatalf("Unexpected call to RepositoryMock.Create. %v %v %v %v", ctx, req, id, createdAt)
	return
}

// CreateAfterCounter returns a count of finished RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mRepositoryMockCreate) Calls() []*RepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mRepositoryMockCreateDraft struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateDraftExpectation
	expectations       []*RepositoryMockCreateDraftExpectation

	callArgs []*RepositoryMockCreateDraftParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateDraftExpectation specifies expectation struct of the Repository.CreateDraft
type RepositoryMockCreateDraftExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateDraftParams
	paramPtrs          *RepositoryMockCreateDraftParamPtrs
	expectationOrigins RepositoryMockCreateDraftExpectationOrigins
	results            *RepositoryMockCreateDraftResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateDraftParams contains parameters of the Repository.CreateDraft
type RepositoryMockCreateDraftParams struct {
	ctx context.Context
	req mm_entity.CreateEntityReq
	id  uuid.UUID
}

// RepositoryMockCreateDraftParamPtrs contains pointers to parameters of the Repository.CreateDraft
type RepositoryMockCreateDraftParamPtrs struct {
	ctx *context.Context
	req *mm_entity.CreateEntityReq
	id  *uuid.UUID
}

// RepositoryMockCreateDraftResults contains results of the Repository.CreateDraft
type RepositoryMockCreateDraftResults struct {
	err error
}

// RepositoryMockCreateDraftOrigins contains origins of expectations of the Repository.CreateDraft
type RepositoryMockCreateDraftExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateDraft *mRepositoryMockCreateDraft) Optional() *mRepositoryMockCreateDraft {
	mmCreateDraft.optional = true
	return mmCreateDraft
}

// Expect sets up expected params for Repository.CreateDraft
func (mmCreateDraft *mRepositoryMockCreateDraft) Expect(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID) *mRepositoryMockCreateDraft {
	if mmCreateDraft.mock.funcCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Set")
	}

	if mmCreateDraft.defaultExpectation == nil {
		mmCreateDraft.defaultExpectation = &RepositoryMockCreateDraftExpectation{}
	}

	if mmCreateDraft.defaultExpectation.paramPtrs != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by ExpectParams functions")
	}

	mmCreateDraft.defaultExpectation.params = &RepositoryMockCreateDraftParams{ctx, req, id}
	mmCreateDraft.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateDraft.expectations {
		if minimock.Equal(e.params, mmCreateDraft.defaultExpectation.params) {
			mmCreateDraft.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateDraft.defaultExpectation.params)
		}
	}

	return mmCreateDraft
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateDraft
func (mmCreateDraft *mRepositoryMockCreateDraft) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateDraft {
	if mmCreateDraft.mock.funcCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Set")
	}

	if mmCreateDraft.defaultExpectation == nil {
		mmCreateDraft.defaultExpectation = &RepositoryMockCreateDraftExpectation{}
	}

	if mmCreateDraft.defaultExpectation.params != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Expect")
	}

	if mmCreateDraft.defaultExpectation.paramPtrs == nil {
		mmCreateDraft.defaultExpectation.paramPtrs = &RepositoryMockCreateDraftParamPtrs{}
	}
	mmCreateDraft.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateDraft.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateDraft
}

// ExpectReqParam2 sets up expected param req for Repository.CreateDraft
func (mmCreateDraft *mRepositoryMockCreateDraft) ExpectReqParam2(req mm_entity.CreateEntityReq) *mRepositoryMockCreateDraft {
	if mmCreateDraft.mock.funcCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Set")
	}

	if mmCreateDraft.defaultExpectation == nil {
		mmCreateDraft.defaultExpectation = &RepositoryMockCreateDraftExpectation{}
	}

	if mmCreateDraft.defaultExpectation.params != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Expect")
	}

	if mmCreateDraft.defaultExpectation.paramPtrs == nil {
		mmCreateDraft.defaultExpectation.paramPtrs = &RepositoryMockCreateDraftParamPtrs{}
	}
	mmCreateDraft.defaultExpectation.paramPtrs.req = &req
	mmCreateDraft.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateDraft
}

// ExpectIdParam3 sets up expected param id for Repository.CreateDraft
func (mmCreateDraft *mRepositoryMockCreateDraft) ExpectIdParam3(id uuid.UUID) *mRepositoryMockCreateDraft {
	if mmCreateDraft.mock.funcCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Set")
	}

	if mmCreateDraft.defaultExpectation == nil {
		mmCreateDraft.defaultExpectation = &RepositoryMockCreateDraftExpectation{}
	}

	if mmCreateDraft.defaultExpectation.params != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Expect")
	}

	if mmCreateDraft.defaultExpectation.paramPtrs == nil {
		mmCreateDraft.defaultExpectation.paramPtrs = &RepositoryMockCreateDraftParamPtrs{}
	}
	mmCreateDraft.defaultExpectation.paramPtrs.id = &id
	mmCreateDraft.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateDraft
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateDraft
func (mmCreateDraft *mRepositoryMockCreateDraft) Inspect(f func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID)) *mRepositoryMockCreateDraft {
	if mmCreateDraft.mock.inspectFuncCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateDraft")
	}

	mmCreateDraft.mock.inspectFuncCreateDraft = f

	return mmCreateDraft
}

// Return sets up results that will be returned by Repository.CreateDraft
func (mmCreateDraft *mRepositoryMockCreateDraft) Return(err error) *RepositoryMock {
	if mmCreateDraft.mock.funcCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Set")
	}

	if mmCreateDraft.defaultExpectation == nil {
		mmCreateDraft.defaultExpectation = &RepositoryMockCreateDraftExpectation{mock: mmCreateDraft.mock}
	}
	mmCreateDraft.defaultExpectation.results = &RepositoryMockCreateDraftResults{err}
	mmCreateDraft.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateDraft.mock
}

// Set uses given function f to mock the Repository.CreateDraft method
func (mmCreateDraft *mRepositoryMockCreateDraft) Set(f func(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID) (err error)) *RepositoryMock {
	if mmCreateDraft.defaultExpectation != nil {
		mmCreateDraft.mock.t.Fatalf("Default expectation is already set for the Repository.CreateDraft method")
	}

	if len(mmCreateDraft.expectations) > 0 {
		mmCreateDraft.mock.t.Fatalf("Some expectations are already set for the Repository.CreateDraft method")
	}

	mmCreateDraft.mock.funcCreateDraft = f
	mmCreateDraft.mock.funcCreateDraftOrigin = minimock.CallerInfo(1)
	return mmCreateDraft.mock
}

// When sets expectation for the Repository.CreateDraft which will trigger the result defined by the following
// Then helper
func (mmCreateDraft *mRepositoryMockCreateDraft) When(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID) *RepositoryMockCreateDraftExpectation {
	if mmCreateDraft.mock.funcCreateDraft != nil {
		mmCreateDraft.mock.t.Fatalf("RepositoryMock.CreateDraft mock is already set by Set")
	}

	expectation := &RepositoryMockCreateDraftExpectation{
		mock:               mmCreateDraft.mock,
		params:             &RepositoryMockCreateDraftParams{ctx, req, id},
		expectationOrigins: RepositoryMockCreateDraftExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateDraft.expectations = append(mmCreateDraft.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateDraft return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateDraftExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateDraftResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateDraft should be invoked
func (mmCreateDraft *mRepositoryMockCreateDraft) Times(n uint64) *mRepositoryMockCreateDraft {
	if n == 0 {
		mmCreateDraft.mock.t.Fatalf("Times of RepositoryMock.CreateDraft mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateDraft.expectedInvocations, n)
	mmCreateDraft.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateDraft
}

func (mmCreateDraft *mRepositoryMockCreateDraft) invocationsDone() bool {
	if len(mmCreateDraft.expectations) == 0 && mmCreateDraft.defaultExpectation == nil && mmCreateDraft.mock.funcCreateDraft == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateDraft.mock.afterCreateDraftCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateDraft.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateDraft implements mm_entity.Repository
func (mmCreateDraft *RepositoryMock) CreateDraft(ctx context.Context, req mm_entity.CreateEntityReq, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCreateDraft.beforeCreateDraftCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateDraft.afterCreateDraftCounter, 1)

	mmCreateDraft.t.Helper()

	if mmCreateDraft.inspectFuncCreateDraft != nil {
		mmCreateDraft.inspectFuncCreateDraft(ctx, req, id)
	}

	mm_params := RepositoryMockCreateDraftParams{ctx, req, id}

	// Record call args
	mmCreateDraft.CreateDraftMock.mutex.Lock()
	mmCreateDraft.CreateDraftMock.callArgs = append(mmCreateDraft.CreateDraftMock.callArgs, &mm_params)
	mmCreateDraft.CreateDraftMock.mutex.Unlock()

	for _, e := range mmCreateDraft.CreateDraftMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateDraft.CreateDraftMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateDraft.CreateDraftMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateDraft.CreateDraftMock.defaultExpectation.params
		mm_want_ptrs := mmCreateDraft.CreateDraftMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateDraftParams{ctx, req, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateDraft.t.Errorf("RepositoryMock.CreateDraft got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateDraft.CreateDraftMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateDraft.t.Errorf("RepositoryMock.CreateDraft got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateDraft.CreateDraftMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateDraft.t.Errorf("RepositoryMock.CreateDraft got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateDraft.CreateDraftMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateDraft.t.Errorf("RepositoryMock.CreateDraft got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateDraft.CreateDraftMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateDraft.CreateDraftMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateDraft.t.Fatal("No results are set for the RepositoryMock.CreateDraft")
		}
		return (*mm_results).err
	}
	if mmCreateDraft.funcCreateDraft != nil {
		return mmCreateDraft.funcCreateDraft(ctx, req, id)
	}
	mmCreateDraft.t.Fatalf("Unexpected call to RepositoryMock.CreateDraft. %v %v %v", ctx, req, id)
	return
}

// CreateDraftAfterCounter returns a count of finished RepositoryMock.CreateDraft invocations
func (mmCreateDraft *RepositoryMock) CreateDraftAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDraft.afterCreateDraftCounter)
}

// CreateDraftBeforeCounter returns a count of RepositoryMock.CreateDraft invocations
func (mmCreateDraft *RepositoryMock) CreateDraftBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDraft.beforeCreateDraftCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateDraft.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateDraft *mRepositoryMockCreateDraft) Calls() []*RepositoryMockCreateDraftParams {
	mmCreateDraft.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateDraftParams, len(mmCreateDraft.callArgs))
	copy(argCopy, mmCreateDraft.callArgs)

	mmCreateDraft.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDraftDone returns true if the count of the CreateDraft invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateDraftDone() bool {
	if m.CreateDraftMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateDraftMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateDraftMock.invocationsDone()
}

// MinimockCreateDraftInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateDraftInspect() {
	for _, e := range m.CreateDraftMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateDraft at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateDraftCounter := mm_atomic.LoadUint64(&m.afterCreateDraftCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDraftMock.defaultExpectation != nil && afterCreateDraftCounter < 1 {
		if m.CreateDraftMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateDraft at\n%s", m.CreateDraftMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateDraft at\n%s with params: %#v", m.CreateDraftMock.defaultExpectation.expectationOrigins.origin, *m.CreateDraftMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDraft != nil && afterCreateDraftCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateDraft at\n%s", m.funcCreateDraftOrigin)
	}

	if !m.CreateDraftMock.invocationsDone() && afterCreateDraftCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateDraft at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateDraftMock.expectedInvocations), m.CreateDraftMock.expectedInvocationsOrigin, afterCreateDraftCounter)
	}
}

type mRepositoryMockDelete struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteExpectation
	expectations       []*RepositoryMockDeleteExpectation

	callArgs []*RepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteExpectation specifies expectation struct of the Repository.Delete
type RepositoryMockDeleteExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteParams
	paramPtrs          *RepositoryMockDeleteParamPtrs
	expectationOrigins RepositoryMockDeleteExpectationOrigins
	results            *RepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteParams contains parameters of the Repository.Delete
type RepositoryMockDeleteParams struct {
	ctx context.Context
	ids []uuid.UUID
}

// RepositoryMockDeleteParamPtrs contains pointers to parameters of the Repository.Delete
type RepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	ids *[]uuid.UUID
}

// RepositoryMockDeleteResults contains results of the Repository.Delete
type RepositoryMockDeleteResults struct {
	err error
}

// RepositoryMockDeleteOrigins contains origins of expectations of the Repository.Delete
type RepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mRepositoryMockDelete) Optional() *mRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Repository.Delete
func (mmDelete *mRepositoryMockDelete) Expect(ctx context.Context, ids []uuid.UUID) *mRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &RepositoryMockDeleteParams{ctx, ids}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Delete
func (mmDelete *mRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &RepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdsParam2 sets up expected param ids for Repository.Delete
func (mmDelete *mRepositoryMockDelete) ExpectIdsParam2(ids []uuid.UUID) *mRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &RepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ids = &ids
	mmDelete.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Repository.Delete
func (mmDelete *mRepositoryMockDelete) Inspect(f func(ctx context.Context, ids []uuid.UUID)) *mRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Repository.Delete
func (mmDelete *mRepositoryMockDelete) Return(err error) *RepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &RepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Repository.Delete method
func (mmDelete *mRepositoryMockDelete) Set(f func(ctx context.Context, ids []uuid.UUID) (err error)) *RepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Repository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Repository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Repository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mRepositoryMockDelete) When(ctx context.Context, ids []uuid.UUID) *RepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepositoryMock.Delete mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &RepositoryMockDeleteParams{ctx, ids},
		expectationOrigins: RepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Repository.Delete return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Repository.Delete should be invoked
func (mmDelete *mRepositoryMockDelete) Times(n uint64) *mRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of RepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_entity.Repository
func (mmDelete *RepositoryMock) Delete(ctx context.Context, ids []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, ids)
	}

	mm_params := RepositoryMockDeleteParams{ctx, ids}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("RepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmDelete.t.Errorf("RepositoryMock.Delete got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("RepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the RepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, ids)
	}
	mmDelete.t.Fatalf("Unexpected call to RepositoryMock.Delete. %v %v", ctx, ids)
	return
}

// DeleteAfterCounter returns a count of finished RepositoryMock.Delete invocations
func (mmDelete *RepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of RepositoryMock.Delete invocations
func (mmDelete *RepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mRepositoryMockDelete) Calls() []*RepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mRepositoryMockGet struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetExpectation
	expectations       []*RepositoryMockGetExpectation

	callArgs []*RepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetExpectation specifies expectation struct of the Repository.Get
type RepositoryMockGetExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetParams
	paramPtrs          *RepositoryMockGetParamPtrs
	expectationOrigins RepositoryMockGetExpectationOrigins
	results            *RepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetParams contains parameters of the Repository.Get
type RepositoryMockGetParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockGetParamPtrs contains pointers to parameters of the Repository.Get
type RepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockGetResults contains results of the Repository.Get
type RepositoryMockGetResults struct {
	e1  mm_entity.Entity
	err error
}

// RepositoryMockGetOrigins contains origins of expectations of the Repository.Get
type RepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mRepositoryMockGet) Optional() *mRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Repository.Get
func (mmGet *mRepositoryMockGet) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &RepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Get
func (mmGet *mRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for Repository.Get
func (mmGet *mRepositoryMockGet) ExpectIdParam2(id uuid.UUID) *mRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Repository.Get
func (mmGet *mRepositoryMockGet) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Repository.Get
func (mmGet *mRepositoryMockGet) Return(e1 mm_entity.Entity, err error) *RepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &RepositoryMockGetResults{e1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Repository.Get method
func (mmGet *mRepositoryMockGet) Set(f func(ctx context.Context, id uuid.UUID) (e1 mm_entity.Entity, err error)) *RepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Repository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Repository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Repository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mRepositoryMockGet) When(ctx context.Context, id uuid.UUID) *RepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	expectation := &RepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &RepositoryMockGetParams{ctx, id},
		expectationOrigins: RepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Repository.Get return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetExpectation) Then(e1 mm_entity.Entity, err error) *RepositoryMock {
	e.results = &RepositoryMockGetResults{e1, err}
	return e.mock
}

// Times sets number of times Repository.Get should be invoked
func (mmGet *mRepositoryMockGet) Times(n uint64) *mRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of RepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_entity.Repository
func (mmGet *RepositoryMock) Get(ctx context.Context, id uuid.UUID) (e1 mm_entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := RepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("RepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("RepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("RepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the RepositoryMock.Get")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to RepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished RepositoryMock.Get invocations
func (mmGet *RepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of RepositoryMock.Get invocations
func (mmGet *RepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mRepositoryMockGet) Calls() []*RepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*RepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mRepositoryMockGetAll struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllExpectation
	expectations       []*RepositoryMockGetAllExpectation

	callArgs []*RepositoryMockGetAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetAllExpectation specifies expectation struct of the Repository.GetAll
type RepositoryMockGetAllExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetAllParams
	paramPtrs          *RepositoryMockGetAllParamPtrs
	expectationOrigins RepositoryMockGetAllExpectationOrigins
	results            *RepositoryMockGetAllResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetAllParams contains parameters of the Repository.GetAll
type RepositoryMockGetAllParams struct {
	ctx context.Context
}

// RepositoryMockGetAllParamPtrs contains pointers to parameters of the Repository.GetAll
type RepositoryMockGetAllParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockGetAllResults contains results of the Repository.GetAll
type RepositoryMockGetAllResults struct {
	la1 []mm_entity.ListItem
	err error
}

// RepositoryMockGetAllOrigins contains origins of expectations of the Repository.GetAll
type RepositoryMockGetAllExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAll *mRepositoryMockGetAll) Optional() *mRepositoryMockGetAll {
	mmGetAll.optional = true
	return mmGetAll
}

// Expect sets up expected params for Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) Expect(ctx context.Context) *mRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.paramPtrs != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by ExpectParams functions")
	}

	mmGetAll.defaultExpectation.params = &RepositoryMockGetAllParams{ctx}
	mmGetAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &RepositoryMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) Inspect(f func(ctx context.Context)) *mRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) Return(la1 []mm_entity.ListItem, err error) *RepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &RepositoryMockGetAllResults{la1, err}
	mmGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// Set uses given function f to mock the Repository.GetAll method
func (mmGetAll *mRepositoryMockGetAll) Set(f func(ctx context.Context) (la1 []mm_entity.ListItem, err error)) *RepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the Repository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the Repository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	mmGetAll.mock.funcGetAllOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// When sets expectation for the Repository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mRepositoryMockGetAll) When(ctx context.Context) *RepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllExpectation{
		mock:               mmGetAll.mock,
		params:             &RepositoryMockGetAllParams{ctx},
		expectationOrigins: RepositoryMockGetAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAll return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllExpectation) Then(la1 []mm_entity.ListItem, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllResults{la1, err}
	return e.mock
}

// Times sets number of times Repository.GetAll should be invoked
func (mmGetAll *mRepositoryMockGetAll) Times(n uint64) *mRepositoryMockGetAll {
	if n == 0 {
		mmGetAll.mock.t.Fatalf("Times of RepositoryMock.GetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAll.expectedInvocations, n)
	mmGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAll
}

func (mmGetAll *mRepositoryMockGetAll) invocationsDone() bool {
	if len(mmGetAll.expectations) == 0 && mmGetAll.defaultExpectation == nil && mmGetAll.mock.funcGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAll.mock.afterGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAll implements mm_entity.Repository
func (mmGetAll *RepositoryMock) GetAll(ctx context.Context) (la1 []mm_entity.ListItem, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	mmGetAll.t.Helper()

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx)
	}

	mm_params := RepositoryMockGetAllParams{ctx}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, &mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_want_ptrs := mmGetAll.GetAllMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetAllParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAll.t.Errorf("RepositoryMock.GetAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("RepositoryMock.GetAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the RepositoryMock.GetAll")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx)
	}
	mmGetAll.t.Fatalf("Unexpected call to RepositoryMock.GetAll. %v", ctx)
	return
}

// GetAllAfterCounter returns a count of finished RepositoryMock.GetAll invocations
func (mmGetAll *RepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of RepositoryMock.GetAll invocations
func (mmGetAll *RepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mRepositoryMockGetAll) Calls() []*RepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllDone() bool {
	if m.GetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllMock.invocationsDone()
}

// MinimockGetAllInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllCounter := mm_atomic.LoadUint64(&m.afterGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && afterGetAllCounter < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s", m.GetAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s with params: %#v", m.GetAllMock.defaultExpectation.expectationOrigins.origin, *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && afterGetAllCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s", m.funcGetAllOrigin)
	}

	if !m.GetAllMock.invocationsDone() && afterGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllMock.expectedInvocations), m.GetAllMock.expectedInvocationsOrigin, afterGetAllCounter)
	}
}

type mRepositoryMockGetHierarchy struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetHierarchyExpectation
	expectations       []*RepositoryMockGetHierarchyExpectation

	callArgs []*RepositoryMockGetHierarchyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetHierarchyExpectation specifies expectation struct of the Repository.GetHierarchy
type RepositoryMockGetHierarchyExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetHierarchyParams
	paramPtrs          *RepositoryMockGetHierarchyParamPtrs
	expectationOrigins RepositoryMockGetHierarchyExpectationOrigins
	results            *RepositoryMockGetHierarchyResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetHierarchyParams contains parameters of the Repository.GetHierarchy
type RepositoryMockGetHierarchyParams struct {
	ctx         context.Context
	permissions []uuid.UUID
	maxDepth    int
	userID      *uuid.UUID
	hType       mm_entity.HierarchyType
}

// RepositoryMockGetHierarchyParamPtrs contains pointers to parameters of the Repository.GetHierarchy
type RepositoryMockGetHierarchyParamPtrs struct {
	ctx         *context.Context
	permissions *[]uuid.UUID
	maxDepth    *int
	userID      **uuid.UUID
	hType       *mm_entity.HierarchyType
}

// RepositoryMockGetHierarchyResults contains results of the Repository.GetHierarchy
type RepositoryMockGetHierarchyResults struct {
	la1 []mm_entity.ListItem
	err error
}

// RepositoryMockGetHierarchyOrigins contains origins of expectations of the Repository.GetHierarchy
type RepositoryMockGetHierarchyExpectationOrigins struct {
	origin            string
	originCtx         string
	originPermissions string
	originMaxDepth    string
	originUserID      string
	originHType       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Optional() *mRepositoryMockGetHierarchy {
	mmGetHierarchy.optional = true
	return mmGetHierarchy
}

// Expect sets up expected params for Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Expect(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{}
	}

	if mmGetHierarchy.defaultExpectation.paramPtrs != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by ExpectParams functions")
	}

	mmGetHierarchy.defaultExpectation.params = &RepositoryMockGetHierarchyParams{ctx, permissions, maxDepth, userID, hType}
	mmGetHierarchy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHierarchy.expectations {
		if minimock.Equal(e.params, mmGetHierarchy.defaultExpectation.params) {
			mmGetHierarchy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHierarchy.defaultExpectation.params)
		}
	}

	return mmGetHierarchy
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{}
	}

	if mmGetHierarchy.defaultExpectation.params != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Expect")
	}

	if mmGetHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetHierarchy.defaultExpectation.paramPtrs = &RepositoryMockGetHierarchyParamPtrs{}
	}
	mmGetHierarchy.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetHierarchy.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetHierarchy
}

// ExpectPermissionsParam2 sets up expected param permissions for Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) ExpectPermissionsParam2(permissions []uuid.UUID) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{}
	}

	if mmGetHierarchy.defaultExpectation.params != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Expect")
	}

	if mmGetHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetHierarchy.defaultExpectation.paramPtrs = &RepositoryMockGetHierarchyParamPtrs{}
	}
	mmGetHierarchy.defaultExpectation.paramPtrs.permissions = &permissions
	mmGetHierarchy.defaultExpectation.expectationOrigins.originPermissions = minimock.CallerInfo(1)

	return mmGetHierarchy
}

// ExpectMaxDepthParam3 sets up expected param maxDepth for Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) ExpectMaxDepthParam3(maxDepth int) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{}
	}

	if mmGetHierarchy.defaultExpectation.params != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Expect")
	}

	if mmGetHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetHierarchy.defaultExpectation.paramPtrs = &RepositoryMockGetHierarchyParamPtrs{}
	}
	mmGetHierarchy.defaultExpectation.paramPtrs.maxDepth = &maxDepth
	mmGetHierarchy.defaultExpectation.expectationOrigins.originMaxDepth = minimock.CallerInfo(1)

	return mmGetHierarchy
}

// ExpectUserIDParam4 sets up expected param userID for Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) ExpectUserIDParam4(userID *uuid.UUID) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{}
	}

	if mmGetHierarchy.defaultExpectation.params != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Expect")
	}

	if mmGetHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetHierarchy.defaultExpectation.paramPtrs = &RepositoryMockGetHierarchyParamPtrs{}
	}
	mmGetHierarchy.defaultExpectation.paramPtrs.userID = &userID
	mmGetHierarchy.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetHierarchy
}

// ExpectHTypeParam5 sets up expected param hType for Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) ExpectHTypeParam5(hType mm_entity.HierarchyType) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{}
	}

	if mmGetHierarchy.defaultExpectation.params != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Expect")
	}

	if mmGetHierarchy.defaultExpectation.paramPtrs == nil {
		mmGetHierarchy.defaultExpectation.paramPtrs = &RepositoryMockGetHierarchyParamPtrs{}
	}
	mmGetHierarchy.defaultExpectation.paramPtrs.hType = &hType
	mmGetHierarchy.defaultExpectation.expectationOrigins.originHType = minimock.CallerInfo(1)

	return mmGetHierarchy
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Inspect(f func(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType)) *mRepositoryMockGetHierarchy {
	if mmGetHierarchy.mock.inspectFuncGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetHierarchy")
	}

	mmGetHierarchy.mock.inspectFuncGetHierarchy = f

	return mmGetHierarchy
}

// Return sets up results that will be returned by Repository.GetHierarchy
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Return(la1 []mm_entity.ListItem, err error) *RepositoryMock {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	if mmGetHierarchy.defaultExpectation == nil {
		mmGetHierarchy.defaultExpectation = &RepositoryMockGetHierarchyExpectation{mock: mmGetHierarchy.mock}
	}
	mmGetHierarchy.defaultExpectation.results = &RepositoryMockGetHierarchyResults{la1, err}
	mmGetHierarchy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHierarchy.mock
}

// Set uses given function f to mock the Repository.GetHierarchy method
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Set(f func(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType) (la1 []mm_entity.ListItem, err error)) *RepositoryMock {
	if mmGetHierarchy.defaultExpectation != nil {
		mmGetHierarchy.mock.t.Fatalf("Default expectation is already set for the Repository.GetHierarchy method")
	}

	if len(mmGetHierarchy.expectations) > 0 {
		mmGetHierarchy.mock.t.Fatalf("Some expectations are already set for the Repository.GetHierarchy method")
	}

	mmGetHierarchy.mock.funcGetHierarchy = f
	mmGetHierarchy.mock.funcGetHierarchyOrigin = minimock.CallerInfo(1)
	return mmGetHierarchy.mock
}

// When sets expectation for the Repository.GetHierarchy which will trigger the result defined by the following
// Then helper
func (mmGetHierarchy *mRepositoryMockGetHierarchy) When(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType) *RepositoryMockGetHierarchyExpectation {
	if mmGetHierarchy.mock.funcGetHierarchy != nil {
		mmGetHierarchy.mock.t.Fatalf("RepositoryMock.GetHierarchy mock is already set by Set")
	}

	expectation := &RepositoryMockGetHierarchyExpectation{
		mock:               mmGetHierarchy.mock,
		params:             &RepositoryMockGetHierarchyParams{ctx, permissions, maxDepth, userID, hType},
		expectationOrigins: RepositoryMockGetHierarchyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHierarchy.expectations = append(mmGetHierarchy.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetHierarchy return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetHierarchyExpectation) Then(la1 []mm_entity.ListItem, err error) *RepositoryMock {
	e.results = &RepositoryMockGetHierarchyResults{la1, err}
	return e.mock
}

// Times sets number of times Repository.GetHierarchy should be invoked
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Times(n uint64) *mRepositoryMockGetHierarchy {
	if n == 0 {
		mmGetHierarchy.mock.t.Fatalf("Times of RepositoryMock.GetHierarchy mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHierarchy.expectedInvocations, n)
	mmGetHierarchy.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHierarchy
}

func (mmGetHierarchy *mRepositoryMockGetHierarchy) invocationsDone() bool {
	if len(mmGetHierarchy.expectations) == 0 && mmGetHierarchy.defaultExpectation == nil && mmGetHierarchy.mock.funcGetHierarchy == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHierarchy.mock.afterGetHierarchyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHierarchy.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHierarchy implements mm_entity.Repository
func (mmGetHierarchy *RepositoryMock) GetHierarchy(ctx context.Context, permissions []uuid.UUID, maxDepth int, userID *uuid.UUID, hType mm_entity.HierarchyType) (la1 []mm_entity.ListItem, err error) {
	mm_atomic.AddUint64(&mmGetHierarchy.beforeGetHierarchyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHierarchy.afterGetHierarchyCounter, 1)

	mmGetHierarchy.t.Helper()

	if mmGetHierarchy.inspectFuncGetHierarchy != nil {
		mmGetHierarchy.inspectFuncGetHierarchy(ctx, permissions, maxDepth, userID, hType)
	}

	mm_params := RepositoryMockGetHierarchyParams{ctx, permissions, maxDepth, userID, hType}

	// Record call args
	mmGetHierarchy.GetHierarchyMock.mutex.Lock()
	mmGetHierarchy.GetHierarchyMock.callArgs = append(mmGetHierarchy.GetHierarchyMock.callArgs, &mm_params)
	mmGetHierarchy.GetHierarchyMock.mutex.Unlock()

	for _, e := range mmGetHierarchy.GetHierarchyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetHierarchy.GetHierarchyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHierarchy.GetHierarchyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHierarchy.GetHierarchyMock.defaultExpectation.params
		mm_want_ptrs := mmGetHierarchy.GetHierarchyMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetHierarchyParams{ctx, permissions, maxDepth, userID, hType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetHierarchy.t.Errorf("RepositoryMock.GetHierarchy got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHierarchy.GetHierarchyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.permissions != nil && !minimock.Equal(*mm_want_ptrs.permissions, mm_got.permissions) {
				mmGetHierarchy.t.Errorf("RepositoryMock.GetHierarchy got unexpected parameter permissions, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHierarchy.GetHierarchyMock.defaultExpectation.expectationOrigins.originPermissions, *mm_want_ptrs.permissions, mm_got.permissions, minimock.Diff(*mm_want_ptrs.permissions, mm_got.permissions))
			}

			if mm_want_ptrs.maxDepth != nil && !minimock.Equal(*mm_want_ptrs.maxDepth, mm_got.maxDepth) {
				mmGetHierarchy.t.Errorf("RepositoryMock.GetHierarchy got unexpected parameter maxDepth, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHierarchy.GetHierarchyMock.defaultExpectation.expectationOrigins.originMaxDepth, *mm_want_ptrs.maxDepth, mm_got.maxDepth, minimock.Diff(*mm_want_ptrs.maxDepth, mm_got.maxDepth))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetHierarchy.t.Errorf("RepositoryMock.GetHierarchy got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHierarchy.GetHierarchyMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.hType != nil && !minimock.Equal(*mm_want_ptrs.hType, mm_got.hType) {
				mmGetHierarchy.t.Errorf("RepositoryMock.GetHierarchy got unexpected parameter hType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHierarchy.GetHierarchyMock.defaultExpectation.expectationOrigins.originHType, *mm_want_ptrs.hType, mm_got.hType, minimock.Diff(*mm_want_ptrs.hType, mm_got.hType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHierarchy.t.Errorf("RepositoryMock.GetHierarchy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHierarchy.GetHierarchyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHierarchy.GetHierarchyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHierarchy.t.Fatal("No results are set for the RepositoryMock.GetHierarchy")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetHierarchy.funcGetHierarchy != nil {
		return mmGetHierarchy.funcGetHierarchy(ctx, permissions, maxDepth, userID, hType)
	}
	mmGetHierarchy.t.Fatalf("Unexpected call to RepositoryMock.GetHierarchy. %v %v %v %v %v", ctx, permissions, maxDepth, userID, hType)
	return
}

// GetHierarchyAfterCounter returns a count of finished RepositoryMock.GetHierarchy invocations
func (mmGetHierarchy *RepositoryMock) GetHierarchyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHierarchy.afterGetHierarchyCounter)
}

// GetHierarchyBeforeCounter returns a count of RepositoryMock.GetHierarchy invocations
func (mmGetHierarchy *RepositoryMock) GetHierarchyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHierarchy.beforeGetHierarchyCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetHierarchy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHierarchy *mRepositoryMockGetHierarchy) Calls() []*RepositoryMockGetHierarchyParams {
	mmGetHierarchy.mutex.RLock()

	argCopy := make([]*RepositoryMockGetHierarchyParams, len(mmGetHierarchy.callArgs))
	copy(argCopy, mmGetHierarchy.callArgs)

	mmGetHierarchy.mutex.RUnlock()

	return argCopy
}

// MinimockGetHierarchyDone returns true if the count of the GetHierarchy invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetHierarchyDone() bool {
	if m.GetHierarchyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHierarchyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHierarchyMock.invocationsDone()
}

// MinimockGetHierarchyInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetHierarchyInspect() {
	for _, e := range m.GetHierarchyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetHierarchy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHierarchyCounter := mm_atomic.LoadUint64(&m.afterGetHierarchyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHierarchyMock.defaultExpectation != nil && afterGetHierarchyCounter < 1 {
		if m.GetHierarchyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetHierarchy at\n%s", m.GetHierarchyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetHierarchy at\n%s with params: %#v", m.GetHierarchyMock.defaultExpectation.expectationOrigins.origin, *m.GetHierarchyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHierarchy != nil && afterGetHierarchyCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetHierarchy at\n%s", m.funcGetHierarchyOrigin)
	}

	if !m.GetHierarchyMock.invocationsDone() && afterGetHierarchyCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetHierarchy at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHierarchyMock.expectedInvocations), m.GetHierarchyMock.expectedInvocationsOrigin, afterGetHierarchyCounter)
	}
}

type mRepositoryMockGetListItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetListItemExpectation
	expectations       []*RepositoryMockGetListItemExpectation

	callArgs []*RepositoryMockGetListItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetListItemExpectation specifies expectation struct of the Repository.GetListItem
type RepositoryMockGetListItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetListItemParams
	paramPtrs          *RepositoryMockGetListItemParamPtrs
	expectationOrigins RepositoryMockGetListItemExpectationOrigins
	results            *RepositoryMockGetListItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetListItemParams contains parameters of the Repository.GetListItem
type RepositoryMockGetListItemParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockGetListItemParamPtrs contains pointers to parameters of the Repository.GetListItem
type RepositoryMockGetListItemParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockGetListItemResults contains results of the Repository.GetListItem
type RepositoryMockGetListItemResults struct {
	l1  mm_entity.ListItem
	err error
}

// RepositoryMockGetListItemOrigins contains origins of expectations of the Repository.GetListItem
type RepositoryMockGetListItemExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListItem *mRepositoryMockGetListItem) Optional() *mRepositoryMockGetListItem {
	mmGetListItem.optional = true
	return mmGetListItem
}

// Expect sets up expected params for Repository.GetListItem
func (mmGetListItem *mRepositoryMockGetListItem) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockGetListItem {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &RepositoryMockGetListItemExpectation{}
	}

	if mmGetListItem.defaultExpectation.paramPtrs != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by ExpectParams functions")
	}

	mmGetListItem.defaultExpectation.params = &RepositoryMockGetListItemParams{ctx, id}
	mmGetListItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListItem.expectations {
		if minimock.Equal(e.params, mmGetListItem.defaultExpectation.params) {
			mmGetListItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListItem.defaultExpectation.params)
		}
	}

	return mmGetListItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetListItem
func (mmGetListItem *mRepositoryMockGetListItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetListItem {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &RepositoryMockGetListItemExpectation{}
	}

	if mmGetListItem.defaultExpectation.params != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Expect")
	}

	if mmGetListItem.defaultExpectation.paramPtrs == nil {
		mmGetListItem.defaultExpectation.paramPtrs = &RepositoryMockGetListItemParamPtrs{}
	}
	mmGetListItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListItem
}

// ExpectIdParam2 sets up expected param id for Repository.GetListItem
func (mmGetListItem *mRepositoryMockGetListItem) ExpectIdParam2(id uuid.UUID) *mRepositoryMockGetListItem {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &RepositoryMockGetListItemExpectation{}
	}

	if mmGetListItem.defaultExpectation.params != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Expect")
	}

	if mmGetListItem.defaultExpectation.paramPtrs == nil {
		mmGetListItem.defaultExpectation.paramPtrs = &RepositoryMockGetListItemParamPtrs{}
	}
	mmGetListItem.defaultExpectation.paramPtrs.id = &id
	mmGetListItem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetListItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetListItem
func (mmGetListItem *mRepositoryMockGetListItem) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockGetListItem {
	if mmGetListItem.mock.inspectFuncGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetListItem")
	}

	mmGetListItem.mock.inspectFuncGetListItem = f

	return mmGetListItem
}

// Return sets up results that will be returned by Repository.GetListItem
func (mmGetListItem *mRepositoryMockGetListItem) Return(l1 mm_entity.ListItem, err error) *RepositoryMock {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Set")
	}

	if mmGetListItem.defaultExpectation == nil {
		mmGetListItem.defaultExpectation = &RepositoryMockGetListItemExpectation{mock: mmGetListItem.mock}
	}
	mmGetListItem.defaultExpectation.results = &RepositoryMockGetListItemResults{l1, err}
	mmGetListItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListItem.mock
}

// Set uses given function f to mock the Repository.GetListItem method
func (mmGetListItem *mRepositoryMockGetListItem) Set(f func(ctx context.Context, id uuid.UUID) (l1 mm_entity.ListItem, err error)) *RepositoryMock {
	if mmGetListItem.defaultExpectation != nil {
		mmGetListItem.mock.t.Fatalf("Default expectation is already set for the Repository.GetListItem method")
	}

	if len(mmGetListItem.expectations) > 0 {
		mmGetListItem.mock.t.Fatalf("Some expectations are already set for the Repository.GetListItem method")
	}

	mmGetListItem.mock.funcGetListItem = f
	mmGetListItem.mock.funcGetListItemOrigin = minimock.CallerInfo(1)
	return mmGetListItem.mock
}

// When sets expectation for the Repository.GetListItem which will trigger the result defined by the following
// Then helper
func (mmGetListItem *mRepositoryMockGetListItem) When(ctx context.Context, id uuid.UUID) *RepositoryMockGetListItemExpectation {
	if mmGetListItem.mock.funcGetListItem != nil {
		mmGetListItem.mock.t.Fatalf("RepositoryMock.GetListItem mock is already set by Set")
	}

	expectation := &RepositoryMockGetListItemExpectation{
		mock:               mmGetListItem.mock,
		params:             &RepositoryMockGetListItemParams{ctx, id},
		expectationOrigins: RepositoryMockGetListItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListItem.expectations = append(mmGetListItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetListItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetListItemExpectation) Then(l1 mm_entity.ListItem, err error) *RepositoryMock {
	e.results = &RepositoryMockGetListItemResults{l1, err}
	return e.mock
}

// Times sets number of times Repository.GetListItem should be invoked
func (mmGetListItem *mRepositoryMockGetListItem) Times(n uint64) *mRepositoryMockGetListItem {
	if n == 0 {
		mmGetListItem.mock.t.Fatalf("Times of RepositoryMock.GetListItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListItem.expectedInvocations, n)
	mmGetListItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListItem
}

func (mmGetListItem *mRepositoryMockGetListItem) invocationsDone() bool {
	if len(mmGetListItem.expectations) == 0 && mmGetListItem.defaultExpectation == nil && mmGetListItem.mock.funcGetListItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListItem.mock.afterGetListItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListItem implements mm_entity.Repository
func (mmGetListItem *RepositoryMock) GetListItem(ctx context.Context, id uuid.UUID) (l1 mm_entity.ListItem, err error) {
	mm_atomic.AddUint64(&mmGetListItem.beforeGetListItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListItem.afterGetListItemCounter, 1)

	mmGetListItem.t.Helper()

	if mmGetListItem.inspectFuncGetListItem != nil {
		mmGetListItem.inspectFuncGetListItem(ctx, id)
	}

	mm_params := RepositoryMockGetListItemParams{ctx, id}

	// Record call args
	mmGetListItem.GetListItemMock.mutex.Lock()
	mmGetListItem.GetListItemMock.callArgs = append(mmGetListItem.GetListItemMock.callArgs, &mm_params)
	mmGetListItem.GetListItemMock.mutex.Unlock()

	for _, e := range mmGetListItem.GetListItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmGetListItem.GetListItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListItem.GetListItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListItem.GetListItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetListItem.GetListItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetListItemParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListItem.t.Errorf("RepositoryMock.GetListItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListItem.GetListItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetListItem.t.Errorf("RepositoryMock.GetListItem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListItem.GetListItemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListItem.t.Errorf("RepositoryMock.GetListItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListItem.GetListItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListItem.GetListItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListItem.t.Fatal("No results are set for the RepositoryMock.GetListItem")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmGetListItem.funcGetListItem != nil {
		return mmGetListItem.funcGetListItem(ctx, id)
	}
	mmGetListItem.t.Fatalf("Unexpected call to RepositoryMock.GetListItem. %v %v", ctx, id)
	return
}

// GetListItemAfterCounter returns a count of finished RepositoryMock.GetListItem invocations
func (mmGetListItem *RepositoryMock) GetListItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListItem.afterGetListItemCounter)
}

// GetListItemBeforeCounter returns a count of RepositoryMock.GetListItem invocations
func (mmGetListItem *RepositoryMock) GetListItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListItem.beforeGetListItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetListItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListItem *mRepositoryMockGetListItem) Calls() []*RepositoryMockGetListItemParams {
	mmGetListItem.mutex.RLock()

	argCopy := make([]*RepositoryMockGetListItemParams, len(mmGetListItem.callArgs))
	copy(argCopy, mmGetListItem.callArgs)

	mmGetListItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetListItemDone returns true if the count of the GetListItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetListItemDone() bool {
	if m.GetListItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListItemMock.invocationsDone()
}

// MinimockGetListItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetListItemInspect() {
	for _, e := range m.GetListItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetListItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListItemCounter := mm_atomic.LoadUint64(&m.afterGetListItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListItemMock.defaultExpectation != nil && afterGetListItemCounter < 1 {
		if m.GetListItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetListItem at\n%s", m.GetListItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetListItem at\n%s with params: %#v", m.GetListItemMock.defaultExpectation.expectationOrigins.origin, *m.GetListItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListItem != nil && afterGetListItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetListItem at\n%s", m.funcGetListItemOrigin)
	}

	if !m.GetListItemMock.invocationsDone() && afterGetListItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetListItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListItemMock.expectedInvocations), m.GetListItemMock.expectedInvocationsOrigin, afterGetListItemCounter)
	}
}

type mRepositoryMockGetVersion struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetVersionExpectation
	expectations       []*RepositoryMockGetVersionExpectation

	callArgs []*RepositoryMockGetVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetVersionExpectation specifies expectation struct of the Repository.GetVersion
type RepositoryMockGetVersionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetVersionParams
	paramPtrs          *RepositoryMockGetVersionParamPtrs
	expectationOrigins RepositoryMockGetVersionExpectationOrigins
	results            *RepositoryMockGetVersionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetVersionParams contains parameters of the Repository.GetVersion
type RepositoryMockGetVersionParams struct {
	ctx     context.Context
	id      uuid.UUID
	version int
}

// RepositoryMockGetVersionParamPtrs contains pointers to parameters of the Repository.GetVersion
type RepositoryMockGetVersionParamPtrs struct {
	ctx     *context.Context
	id      *uuid.UUID
	version *int
}

// RepositoryMockGetVersionResults contains results of the Repository.GetVersion
type RepositoryMockGetVersionResults struct {
	e1  mm_entity.Entity
	err error
}

// RepositoryMockGetVersionOrigins contains origins of expectations of the Repository.GetVersion
type RepositoryMockGetVersionExpectationOrigins struct {
	origin        string
	originCtx     string
	originId      string
	originVersion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVersion *mRepositoryMockGetVersion) Optional() *mRepositoryMockGetVersion {
	mmGetVersion.optional = true
	return mmGetVersion
}

// Expect sets up expected params for Repository.GetVersion
func (mmGetVersion *mRepositoryMockGetVersion) Expect(ctx context.Context, id uuid.UUID, version int) *mRepositoryMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &RepositoryMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.paramPtrs != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by ExpectParams functions")
	}

	mmGetVersion.defaultExpectation.params = &RepositoryMockGetVersionParams{ctx, id, version}
	mmGetVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetVersion.expectations {
		if minimock.Equal(e.params, mmGetVersion.defaultExpectation.params) {
			mmGetVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVersion.defaultExpectation.params)
		}
	}

	return mmGetVersion
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetVersion
func (mmGetVersion *mRepositoryMockGetVersion) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &RepositoryMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &RepositoryMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetVersion
}

// ExpectIdParam2 sets up expected param id for Repository.GetVersion
func (mmGetVersion *mRepositoryMockGetVersion) ExpectIdParam2(id uuid.UUID) *mRepositoryMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &RepositoryMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &RepositoryMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.id = &id
	mmGetVersion.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetVersion
}

// ExpectVersionParam3 sets up expected param version for Repository.GetVersion
func (mmGetVersion *mRepositoryMockGetVersion) ExpectVersionParam3(version int) *mRepositoryMockGetVersion {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &RepositoryMockGetVersionExpectation{}
	}

	if mmGetVersion.defaultExpectation.params != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Expect")
	}

	if mmGetVersion.defaultExpectation.paramPtrs == nil {
		mmGetVersion.defaultExpectation.paramPtrs = &RepositoryMockGetVersionParamPtrs{}
	}
	mmGetVersion.defaultExpectation.paramPtrs.version = &version
	mmGetVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmGetVersion
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetVersion
func (mmGetVersion *mRepositoryMockGetVersion) Inspect(f func(ctx context.Context, id uuid.UUID, version int)) *mRepositoryMockGetVersion {
	if mmGetVersion.mock.inspectFuncGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetVersion")
	}

	mmGetVersion.mock.inspectFuncGetVersion = f

	return mmGetVersion
}

// Return sets up results that will be returned by Repository.GetVersion
func (mmGetVersion *mRepositoryMockGetVersion) Return(e1 mm_entity.Entity, err error) *RepositoryMock {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Set")
	}

	if mmGetVersion.defaultExpectation == nil {
		mmGetVersion.defaultExpectation = &RepositoryMockGetVersionExpectation{mock: mmGetVersion.mock}
	}
	mmGetVersion.defaultExpectation.results = &RepositoryMockGetVersionResults{e1, err}
	mmGetVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetVersion.mock
}

// Set uses given function f to mock the Repository.GetVersion method
func (mmGetVersion *mRepositoryMockGetVersion) Set(f func(ctx context.Context, id uuid.UUID, version int) (e1 mm_entity.Entity, err error)) *RepositoryMock {
	if mmGetVersion.defaultExpectation != nil {
		mmGetVersion.mock.t.Fatalf("Default expectation is already set for the Repository.GetVersion method")
	}

	if len(mmGetVersion.expectations) > 0 {
		mmGetVersion.mock.t.Fatalf("Some expectations are already set for the Repository.GetVersion method")
	}

	mmGetVersion.mock.funcGetVersion = f
	mmGetVersion.mock.funcGetVersionOrigin = minimock.CallerInfo(1)
	return mmGetVersion.mock
}

// When sets expectation for the Repository.GetVersion which will trigger the result defined by the following
// Then helper
func (mmGetVersion *mRepositoryMockGetVersion) When(ctx context.Context, id uuid.UUID, version int) *RepositoryMockGetVersionExpectation {
	if mmGetVersion.mock.funcGetVersion != nil {
		mmGetVersion.mock.t.Fatalf("RepositoryMock.GetVersion mock is already set by Set")
	}

	expectation := &RepositoryMockGetVersionExpectation{
		mock:               mmGetVersion.mock,
		params:             &RepositoryMockGetVersionParams{ctx, id, version},
		expectationOrigins: RepositoryMockGetVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetVersion.expectations = append(mmGetVersion.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetVersion return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetVersionExpectation) Then(e1 mm_entity.Entity, err error) *RepositoryMock {
	e.results = &RepositoryMockGetVersionResults{e1, err}
	return e.mock
}

// Times sets number of times Repository.GetVersion should be invoked
func (mmGetVersion *mRepositoryMockGetVersion) Times(n uint64) *mRepositoryMockGetVersion {
	if n == 0 {
		mmGetVersion.mock.t.Fatalf("Times of RepositoryMock.GetVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVersion.expectedInvocations, n)
	mmGetVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetVersion
}

func (mmGetVersion *mRepositoryMockGetVersion) invocationsDone() bool {
	if len(mmGetVersion.expectations) == 0 && mmGetVersion.defaultExpectation == nil && mmGetVersion.mock.funcGetVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVersion.mock.afterGetVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVersion implements mm_entity.Repository
func (mmGetVersion *RepositoryMock) GetVersion(ctx context.Context, id uuid.UUID, version int) (e1 mm_entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGetVersion.beforeGetVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersion.afterGetVersionCounter, 1)

	mmGetVersion.t.Helper()

	if mmGetVersion.inspectFuncGetVersion != nil {
		mmGetVersion.inspectFuncGetVersion(ctx, id, version)
	}

	mm_params := RepositoryMockGetVersionParams{ctx, id, version}

	// Record call args
	mmGetVersion.GetVersionMock.mutex.Lock()
	mmGetVersion.GetVersionMock.callArgs = append(mmGetVersion.GetVersionMock.callArgs, &mm_params)
	mmGetVersion.GetVersionMock.mutex.Unlock()

	for _, e := range mmGetVersion.GetVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmGetVersion.GetVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersion.GetVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVersion.GetVersionMock.defaultExpectation.params
		mm_want_ptrs := mmGetVersion.GetVersionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetVersionParams{ctx, id, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetVersion.t.Errorf("RepositoryMock.GetVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetVersion.t.Errorf("RepositoryMock.GetVersion got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmGetVersion.t.Errorf("RepositoryMock.GetVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVersion.t.Errorf("RepositoryMock.GetVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetVersion.GetVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVersion.GetVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVersion.t.Fatal("No results are set for the RepositoryMock.GetVersion")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmGetVersion.funcGetVersion != nil {
		return mmGetVersion.funcGetVersion(ctx, id, version)
	}
	mmGetVersion.t.Fatalf("Unexpected call to RepositoryMock.GetVersion. %v %v %v", ctx, id, version)
	return
}

// GetVersionAfterCounter returns a count of finished RepositoryMock.GetVersion invocations
func (mmGetVersion *RepositoryMock) GetVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersion.afterGetVersionCounter)
}

// GetVersionBeforeCounter returns a count of RepositoryMock.GetVersion invocations
func (mmGetVersion *RepositoryMock) GetVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersion.beforeGetVersionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVersion *mRepositoryMockGetVersion) Calls() []*RepositoryMockGetVersionParams {
	mmGetVersion.mutex.RLock()

	argCopy := make([]*RepositoryMockGetVersionParams, len(mmGetVersion.callArgs))
	copy(argCopy, mmGetVersion.callArgs)

	mmGetVersion.mutex.RUnlock()

	return argCopy
}

// MinimockGetVersionDone returns true if the count of the GetVersion invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetVersionDone() bool {
	if m.GetVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetVersionMock.invocationsDone()
}

// MinimockGetVersionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetVersionInspect() {
	for _, e := range m.GetVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetVersionCounter := mm_atomic.LoadUint64(&m.afterGetVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionMock.defaultExpectation != nil && afterGetVersionCounter < 1 {
		if m.GetVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetVersion at\n%s", m.GetVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetVersion at\n%s with params: %#v", m.GetVersionMock.defaultExpectation.expectationOrigins.origin, *m.GetVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersion != nil && afterGetVersionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetVersion at\n%s", m.funcGetVersionOrigin)
	}

	if !m.GetVersionMock.invocationsDone() && afterGetVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetVersionMock.expectedInvocations), m.GetVersionMock.expectedInvocationsOrigin, afterGetVersionCounter)
	}
}

type mRepositoryMockGetVersionsList struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetVersionsListExpectation
	expectations       []*RepositoryMockGetVersionsListExpectation

	callArgs []*RepositoryMockGetVersionsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetVersionsListExpectation specifies expectation struct of the Repository.GetVersionsList
type RepositoryMockGetVersionsListExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetVersionsListParams
	paramPtrs          *RepositoryMockGetVersionsListParamPtrs
	expectationOrigins RepositoryMockGetVersionsListExpectationOrigins
	results            *RepositoryMockGetVersionsListResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetVersionsListParams contains parameters of the Repository.GetVersionsList
type RepositoryMockGetVersionsListParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepositoryMockGetVersionsListParamPtrs contains pointers to parameters of the Repository.GetVersionsList
type RepositoryMockGetVersionsListParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// RepositoryMockGetVersionsListResults contains results of the Repository.GetVersionsList
type RepositoryMockGetVersionsListResults struct {
	ea1 []mm_entity.Entity
	err error
}

// RepositoryMockGetVersionsListOrigins contains origins of expectations of the Repository.GetVersionsList
type RepositoryMockGetVersionsListExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Optional() *mRepositoryMockGetVersionsList {
	mmGetVersionsList.optional = true
	return mmGetVersionsList
}

// Expect sets up expected params for Repository.GetVersionsList
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Expect(ctx context.Context, id uuid.UUID) *mRepositoryMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &RepositoryMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by ExpectParams functions")
	}

	mmGetVersionsList.defaultExpectation.params = &RepositoryMockGetVersionsListParams{ctx, id}
	mmGetVersionsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetVersionsList.expectations {
		if minimock.Equal(e.params, mmGetVersionsList.defaultExpectation.params) {
			mmGetVersionsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetVersionsList.defaultExpectation.params)
		}
	}

	return mmGetVersionsList
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetVersionsList
func (mmGetVersionsList *mRepositoryMockGetVersionsList) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &RepositoryMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.params != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Expect")
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs == nil {
		mmGetVersionsList.defaultExpectation.paramPtrs = &RepositoryMockGetVersionsListParamPtrs{}
	}
	mmGetVersionsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetVersionsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetVersionsList
}

// ExpectIdParam2 sets up expected param id for Repository.GetVersionsList
func (mmGetVersionsList *mRepositoryMockGetVersionsList) ExpectIdParam2(id uuid.UUID) *mRepositoryMockGetVersionsList {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &RepositoryMockGetVersionsListExpectation{}
	}

	if mmGetVersionsList.defaultExpectation.params != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Expect")
	}

	if mmGetVersionsList.defaultExpectation.paramPtrs == nil {
		mmGetVersionsList.defaultExpectation.paramPtrs = &RepositoryMockGetVersionsListParamPtrs{}
	}
	mmGetVersionsList.defaultExpectation.paramPtrs.id = &id
	mmGetVersionsList.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetVersionsList
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetVersionsList
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepositoryMockGetVersionsList {
	if mmGetVersionsList.mock.inspectFuncGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetVersionsList")
	}

	mmGetVersionsList.mock.inspectFuncGetVersionsList = f

	return mmGetVersionsList
}

// Return sets up results that will be returned by Repository.GetVersionsList
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Return(ea1 []mm_entity.Entity, err error) *RepositoryMock {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Set")
	}

	if mmGetVersionsList.defaultExpectation == nil {
		mmGetVersionsList.defaultExpectation = &RepositoryMockGetVersionsListExpectation{mock: mmGetVersionsList.mock}
	}
	mmGetVersionsList.defaultExpectation.results = &RepositoryMockGetVersionsListResults{ea1, err}
	mmGetVersionsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList.mock
}

// Set uses given function f to mock the Repository.GetVersionsList method
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Set(f func(ctx context.Context, id uuid.UUID) (ea1 []mm_entity.Entity, err error)) *RepositoryMock {
	if mmGetVersionsList.defaultExpectation != nil {
		mmGetVersionsList.mock.t.Fatalf("Default expectation is already set for the Repository.GetVersionsList method")
	}

	if len(mmGetVersionsList.expectations) > 0 {
		mmGetVersionsList.mock.t.Fatalf("Some expectations are already set for the Repository.GetVersionsList method")
	}

	mmGetVersionsList.mock.funcGetVersionsList = f
	mmGetVersionsList.mock.funcGetVersionsListOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList.mock
}

// When sets expectation for the Repository.GetVersionsList which will trigger the result defined by the following
// Then helper
func (mmGetVersionsList *mRepositoryMockGetVersionsList) When(ctx context.Context, id uuid.UUID) *RepositoryMockGetVersionsListExpectation {
	if mmGetVersionsList.mock.funcGetVersionsList != nil {
		mmGetVersionsList.mock.t.Fatalf("RepositoryMock.GetVersionsList mock is already set by Set")
	}

	expectation := &RepositoryMockGetVersionsListExpectation{
		mock:               mmGetVersionsList.mock,
		params:             &RepositoryMockGetVersionsListParams{ctx, id},
		expectationOrigins: RepositoryMockGetVersionsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetVersionsList.expectations = append(mmGetVersionsList.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetVersionsList return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetVersionsListExpectation) Then(ea1 []mm_entity.Entity, err error) *RepositoryMock {
	e.results = &RepositoryMockGetVersionsListResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.GetVersionsList should be invoked
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Times(n uint64) *mRepositoryMockGetVersionsList {
	if n == 0 {
		mmGetVersionsList.mock.t.Fatalf("Times of RepositoryMock.GetVersionsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetVersionsList.expectedInvocations, n)
	mmGetVersionsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetVersionsList
}

func (mmGetVersionsList *mRepositoryMockGetVersionsList) invocationsDone() bool {
	if len(mmGetVersionsList.expectations) == 0 && mmGetVersionsList.defaultExpectation == nil && mmGetVersionsList.mock.funcGetVersionsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetVersionsList.mock.afterGetVersionsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetVersionsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetVersionsList implements mm_entity.Repository
func (mmGetVersionsList *RepositoryMock) GetVersionsList(ctx context.Context, id uuid.UUID) (ea1 []mm_entity.Entity, err error) {
	mm_atomic.AddUint64(&mmGetVersionsList.beforeGetVersionsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersionsList.afterGetVersionsListCounter, 1)

	mmGetVersionsList.t.Helper()

	if mmGetVersionsList.inspectFuncGetVersionsList != nil {
		mmGetVersionsList.inspectFuncGetVersionsList(ctx, id)
	}

	mm_params := RepositoryMockGetVersionsListParams{ctx, id}

	// Record call args
	mmGetVersionsList.GetVersionsListMock.mutex.Lock()
	mmGetVersionsList.GetVersionsListMock.callArgs = append(mmGetVersionsList.GetVersionsListMock.callArgs, &mm_params)
	mmGetVersionsList.GetVersionsListMock.mutex.Unlock()

	for _, e := range mmGetVersionsList.GetVersionsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetVersionsList.GetVersionsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersionsList.GetVersionsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetVersionsList.GetVersionsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetVersionsList.GetVersionsListMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetVersionsListParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetVersionsList.t.Errorf("RepositoryMock.GetVersionsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetVersionsList.t.Errorf("RepositoryMock.GetVersionsList got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetVersionsList.t.Errorf("RepositoryMock.GetVersionsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetVersionsList.GetVersionsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetVersionsList.GetVersionsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetVersionsList.t.Fatal("No results are set for the RepositoryMock.GetVersionsList")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetVersionsList.funcGetVersionsList != nil {
		return mmGetVersionsList.funcGetVersionsList(ctx, id)
	}
	mmGetVersionsList.t.Fatalf("Unexpected call to RepositoryMock.GetVersionsList. %v %v", ctx, id)
	return
}

// GetVersionsListAfterCounter returns a count of finished RepositoryMock.GetVersionsList invocations
func (mmGetVersionsList *RepositoryMock) GetVersionsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionsList.afterGetVersionsListCounter)
}

// GetVersionsListBeforeCounter returns a count of RepositoryMock.GetVersionsList invocations
func (mmGetVersionsList *RepositoryMock) GetVersionsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionsList.beforeGetVersionsListCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetVersionsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetVersionsList *mRepositoryMockGetVersionsList) Calls() []*RepositoryMockGetVersionsListParams {
	mmGetVersionsList.mutex.RLock()

	argCopy := make([]*RepositoryMockGetVersionsListParams, len(mmGetVersionsList.callArgs))
	copy(argCopy, mmGetVersionsList.callArgs)

	mmGetVersionsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetVersionsListDone returns true if the count of the GetVersionsList invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetVersionsListDone() bool {
	if m.GetVersionsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetVersionsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetVersionsListMock.invocationsDone()
}

// MinimockGetVersionsListInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetVersionsListInspect() {
	for _, e := range m.GetVersionsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetVersionsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetVersionsListCounter := mm_atomic.LoadUint64(&m.afterGetVersionsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionsListMock.defaultExpectation != nil && afterGetVersionsListCounter < 1 {
		if m.GetVersionsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetVersionsList at\n%s", m.GetVersionsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetVersionsList at\n%s with params: %#v", m.GetVersionsListMock.defaultExpectation.expectationOrigins.origin, *m.GetVersionsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersionsList != nil && afterGetVersionsListCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetVersionsList at\n%s", m.funcGetVersionsListOrigin)
	}

	if !m.GetVersionsListMock.invocationsDone() && afterGetVersionsListCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetVersionsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetVersionsListMock.expectedInvocations), m.GetVersionsListMock.expectedInvocationsOrigin, afterGetVersionsListCounter)
	}
}

type mRepositoryMockUpdate struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateExpectation
	expectations       []*RepositoryMockUpdateExpectation

	callArgs []*RepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateExpectation specifies expectation struct of the Repository.Update
type RepositoryMockUpdateExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateParams
	paramPtrs          *RepositoryMockUpdateParamPtrs
	expectationOrigins RepositoryMockUpdateExpectationOrigins
	results            *RepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateParams contains parameters of the Repository.Update
type RepositoryMockUpdateParams struct {
	ctx       context.Context
	req       mm_entity.UpdateEntityReq
	updatedAt time.Time
}

// RepositoryMockUpdateParamPtrs contains pointers to parameters of the Repository.Update
type RepositoryMockUpdateParamPtrs struct {
	ctx       *context.Context
	req       *mm_entity.UpdateEntityReq
	updatedAt *time.Time
}

// RepositoryMockUpdateResults contains results of the Repository.Update
type RepositoryMockUpdateResults struct {
	err error
}

// RepositoryMockUpdateOrigins contains origins of expectations of the Repository.Update
type RepositoryMockUpdateExpectationOrigins struct {
	origin          string
	originCtx       string
	originReq       string
	originUpdatedAt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mRepositoryMockUpdate) Optional() *mRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Expect(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &RepositoryMockUpdateParams{ctx, req, updatedAt}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &RepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectReqParam2 sets up expected param req for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) ExpectReqParam2(req mm_entity.UpdateEntityReq) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &RepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.req = &req
	mmUpdate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdatedAtParam3 sets up expected param updatedAt for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) ExpectUpdatedAtParam3(updatedAt time.Time) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &RepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updatedAt = &updatedAt
	mmUpdate.defaultExpectation.expectationOrigins.originUpdatedAt = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Inspect(f func(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time)) *mRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Return(err error) *RepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &RepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the Repository.Update method
func (mmUpdate *mRepositoryMockUpdate) Set(f func(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time) (err error)) *RepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Repository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Repository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the Repository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mRepositoryMockUpdate) When(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time) *RepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &RepositoryMockUpdateParams{ctx, req, updatedAt},
		expectationOrigins: RepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Repository.Update return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times Repository.Update should be invoked
func (mmUpdate *mRepositoryMockUpdate) Times(n uint64) *mRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of RepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_entity.Repository
func (mmUpdate *RepositoryMock) Update(ctx context.Context, req mm_entity.UpdateEntityReq, updatedAt time.Time) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, req, updatedAt)
	}

	mm_params := RepositoryMockUpdateParams{ctx, req, updatedAt}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateParams{ctx, req, updatedAt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.updatedAt != nil && !minimock.Equal(*mm_want_ptrs.updatedAt, mm_got.updatedAt) {
				mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameter updatedAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdatedAt, *mm_want_ptrs.updatedAt, mm_got.updatedAt, minimock.Diff(*mm_want_ptrs.updatedAt, mm_got.updatedAt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the RepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, req, updatedAt)
	}
	mmUpdate.t.Fatalf("Unexpected call to RepositoryMock.Update. %v %v %v", ctx, req, updatedAt)
	return
}

// UpdateAfterCounter returns a count of finished RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mRepositoryMockUpdate) Calls() []*RepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

type mRepositoryMockUpdateDraft struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateDraftExpectation
	expectations       []*RepositoryMockUpdateDraftExpectation

	callArgs []*RepositoryMockUpdateDraftParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateDraftExpectation specifies expectation struct of the Repository.UpdateDraft
type RepositoryMockUpdateDraftExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateDraftParams
	paramPtrs          *RepositoryMockUpdateDraftParamPtrs
	expectationOrigins RepositoryMockUpdateDraftExpectationOrigins
	results            *RepositoryMockUpdateDraftResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateDraftParams contains parameters of the Repository.UpdateDraft
type RepositoryMockUpdateDraftParams struct {
	ctx context.Context
	req mm_entity.UpdateEntityReq
}

// RepositoryMockUpdateDraftParamPtrs contains pointers to parameters of the Repository.UpdateDraft
type RepositoryMockUpdateDraftParamPtrs struct {
	ctx *context.Context
	req *mm_entity.UpdateEntityReq
}

// RepositoryMockUpdateDraftResults contains results of the Repository.UpdateDraft
type RepositoryMockUpdateDraftResults struct {
	err error
}

// RepositoryMockUpdateDraftOrigins contains origins of expectations of the Repository.UpdateDraft
type RepositoryMockUpdateDraftExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Optional() *mRepositoryMockUpdateDraft {
	mmUpdateDraft.optional = true
	return mmUpdateDraft
}

// Expect sets up expected params for Repository.UpdateDraft
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Expect(ctx context.Context, req mm_entity.UpdateEntityReq) *mRepositoryMockUpdateDraft {
	if mmUpdateDraft.mock.funcUpdateDraft != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Set")
	}

	if mmUpdateDraft.defaultExpectation == nil {
		mmUpdateDraft.defaultExpectation = &RepositoryMockUpdateDraftExpectation{}
	}

	if mmUpdateDraft.defaultExpectation.paramPtrs != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by ExpectParams functions")
	}

	mmUpdateDraft.defaultExpectation.params = &RepositoryMockUpdateDraftParams{ctx, req}
	mmUpdateDraft.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateDraft.expectations {
		if minimock.Equal(e.params, mmUpdateDraft.defaultExpectation.params) {
			mmUpdateDraft.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateDraft.defaultExpectation.params)
		}
	}

	return mmUpdateDraft
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateDraft
func (mmUpdateDraft *mRepositoryMockUpdateDraft) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateDraft {
	if mmUpdateDraft.mock.funcUpdateDraft != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Set")
	}

	if mmUpdateDraft.defaultExpectation == nil {
		mmUpdateDraft.defaultExpectation = &RepositoryMockUpdateDraftExpectation{}
	}

	if mmUpdateDraft.defaultExpectation.params != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Expect")
	}

	if mmUpdateDraft.defaultExpectation.paramPtrs == nil {
		mmUpdateDraft.defaultExpectation.paramPtrs = &RepositoryMockUpdateDraftParamPtrs{}
	}
	mmUpdateDraft.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateDraft.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateDraft
}

// ExpectReqParam2 sets up expected param req for Repository.UpdateDraft
func (mmUpdateDraft *mRepositoryMockUpdateDraft) ExpectReqParam2(req mm_entity.UpdateEntityReq) *mRepositoryMockUpdateDraft {
	if mmUpdateDraft.mock.funcUpdateDraft != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Set")
	}

	if mmUpdateDraft.defaultExpectation == nil {
		mmUpdateDraft.defaultExpectation = &RepositoryMockUpdateDraftExpectation{}
	}

	if mmUpdateDraft.defaultExpectation.params != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Expect")
	}

	if mmUpdateDraft.defaultExpectation.paramPtrs == nil {
		mmUpdateDraft.defaultExpectation.paramPtrs = &RepositoryMockUpdateDraftParamPtrs{}
	}
	mmUpdateDraft.defaultExpectation.paramPtrs.req = &req
	mmUpdateDraft.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdateDraft
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateDraft
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Inspect(f func(ctx context.Context, req mm_entity.UpdateEntityReq)) *mRepositoryMockUpdateDraft {
	if mmUpdateDraft.mock.inspectFuncUpdateDraft != nil {
		mmUpdateDraft.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateDraft")
	}

	mmUpdateDraft.mock.inspectFuncUpdateDraft = f

	return mmUpdateDraft
}

// Return sets up results that will be returned by Repository.UpdateDraft
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Return(err error) *RepositoryMock {
	if mmUpdateDraft.mock.funcUpdateDraft != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Set")
	}

	if mmUpdateDraft.defaultExpectation == nil {
		mmUpdateDraft.defaultExpectation = &RepositoryMockUpdateDraftExpectation{mock: mmUpdateDraft.mock}
	}
	mmUpdateDraft.defaultExpectation.results = &RepositoryMockUpdateDraftResults{err}
	mmUpdateDraft.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateDraft.mock
}

// Set uses given function f to mock the Repository.UpdateDraft method
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Set(f func(ctx context.Context, req mm_entity.UpdateEntityReq) (err error)) *RepositoryMock {
	if mmUpdateDraft.defaultExpectation != nil {
		mmUpdateDraft.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateDraft method")
	}

	if len(mmUpdateDraft.expectations) > 0 {
		mmUpdateDraft.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateDraft method")
	}

	mmUpdateDraft.mock.funcUpdateDraft = f
	mmUpdateDraft.mock.funcUpdateDraftOrigin = minimock.CallerInfo(1)
	return mmUpdateDraft.mock
}

// When sets expectation for the Repository.UpdateDraft which will trigger the result defined by the following
// Then helper
func (mmUpdateDraft *mRepositoryMockUpdateDraft) When(ctx context.Context, req mm_entity.UpdateEntityReq) *RepositoryMockUpdateDraftExpectation {
	if mmUpdateDraft.mock.funcUpdateDraft != nil {
		mmUpdateDraft.mock.t.Fatalf("RepositoryMock.UpdateDraft mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateDraftExpectation{
		mock:               mmUpdateDraft.mock,
		params:             &RepositoryMockUpdateDraftParams{ctx, req},
		expectationOrigins: RepositoryMockUpdateDraftExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateDraft.expectations = append(mmUpdateDraft.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateDraft return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateDraftExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateDraftResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateDraft should be invoked
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Times(n uint64) *mRepositoryMockUpdateDraft {
	if n == 0 {
		mmUpdateDraft.mock.t.Fatalf("Times of RepositoryMock.UpdateDraft mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateDraft.expectedInvocations, n)
	mmUpdateDraft.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateDraft
}

func (mmUpdateDraft *mRepositoryMockUpdateDraft) invocationsDone() bool {
	if len(mmUpdateDraft.expectations) == 0 && mmUpdateDraft.defaultExpectation == nil && mmUpdateDraft.mock.funcUpdateDraft == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateDraft.mock.afterUpdateDraftCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateDraft.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateDraft implements mm_entity.Repository
func (mmUpdateDraft *RepositoryMock) UpdateDraft(ctx context.Context, req mm_entity.UpdateEntityReq) (err error) {
	mm_atomic.AddUint64(&mmUpdateDraft.beforeUpdateDraftCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateDraft.afterUpdateDraftCounter, 1)

	mmUpdateDraft.t.Helper()

	if mmUpdateDraft.inspectFuncUpdateDraft != nil {
		mmUpdateDraft.inspectFuncUpdateDraft(ctx, req)
	}

	mm_params := RepositoryMockUpdateDraftParams{ctx, req}

	// Record call args
	mmUpdateDraft.UpdateDraftMock.mutex.Lock()
	mmUpdateDraft.UpdateDraftMock.callArgs = append(mmUpdateDraft.UpdateDraftMock.callArgs, &mm_params)
	mmUpdateDraft.UpdateDraftMock.mutex.Unlock()

	for _, e := range mmUpdateDraft.UpdateDraftMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateDraft.UpdateDraftMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateDraft.UpdateDraftMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateDraft.UpdateDraftMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateDraft.UpdateDraftMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateDraftParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateDraft.t.Errorf("RepositoryMock.UpdateDraft got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateDraft.UpdateDraftMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdateDraft.t.Errorf("RepositoryMock.UpdateDraft got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateDraft.UpdateDraftMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateDraft.t.Errorf("RepositoryMock.UpdateDraft got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateDraft.UpdateDraftMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateDraft.UpdateDraftMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateDraft.t.Fatal("No results are set for the RepositoryMock.UpdateDraft")
		}
		return (*mm_results).err
	}
	if mmUpdateDraft.funcUpdateDraft != nil {
		return mmUpdateDraft.funcUpdateDraft(ctx, req)
	}
	mmUpdateDraft.t.Fatalf("Unexpected call to RepositoryMock.UpdateDraft. %v %v", ctx, req)
	return
}

// UpdateDraftAfterCounter returns a count of finished RepositoryMock.UpdateDraft invocations
func (mmUpdateDraft *RepositoryMock) UpdateDraftAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDraft.afterUpdateDraftCounter)
}

// UpdateDraftBeforeCounter returns a count of RepositoryMock.UpdateDraft invocations
func (mmUpdateDraft *RepositoryMock) UpdateDraftBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateDraft.beforeUpdateDraftCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateDraft.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateDraft *mRepositoryMockUpdateDraft) Calls() []*RepositoryMockUpdateDraftParams {
	mmUpdateDraft.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateDraftParams, len(mmUpdateDraft.callArgs))
	copy(argCopy, mmUpdateDraft.callArgs)

	mmUpdateDraft.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDraftDone returns true if the count of the UpdateDraft invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateDraftDone() bool {
	if m.UpdateDraftMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateDraftMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateDraftMock.invocationsDone()
}

// MinimockUpdateDraftInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateDraftInspect() {
	for _, e := range m.UpdateDraftMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateDraft at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateDraftCounter := mm_atomic.LoadUint64(&m.afterUpdateDraftCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateDraftMock.defaultExpectation != nil && afterUpdateDraftCounter < 1 {
		if m.UpdateDraftMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateDraft at\n%s", m.UpdateDraftMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateDraft at\n%s with params: %#v", m.UpdateDraftMock.defaultExpectation.expectationOrigins.origin, *m.UpdateDraftMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateDraft != nil && afterUpdateDraftCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateDraft at\n%s", m.funcUpdateDraftOrigin)
	}

	if !m.UpdateDraftMock.invocationsDone() && afterUpdateDraftCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateDraft at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateDraftMock.expectedInvocations), m.UpdateDraftMock.expectedInvocationsOrigin, afterUpdateDraftCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockCreateDraftInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetAllInspect()

			m.MinimockGetHierarchyInspect()

			m.MinimockGetListItemInspect()

			m.MinimockGetVersionInspect()

			m.MinimockGetVersionsListInspect()

			m.MinimockUpdateInspect()

			m.MinimockUpdateDraftInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateDraftDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetHierarchyDone() &&
		m.MinimockGetListItemDone() &&
		m.MinimockGetVersionDone() &&
		m.MinimockGetVersionsListDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdateDraftDone()
}
