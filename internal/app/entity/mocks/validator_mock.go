// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/entity.Validator -o validator_mock.go -n ValidatorMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ValidatorMock implements mm_entity.Validator
type ValidatorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcNormalizeName          func(name string) (s1 string)
	funcNormalizeNameOrigin    string
	inspectFuncNormalizeName   func(name string)
	afterNormalizeNameCounter  uint64
	beforeNormalizeNameCounter uint64
	NormalizeNameMock          mValidatorMockNormalizeName

	funcValidateName          func(name string) (err error)
	funcValidateNameOrigin    string
	inspectFuncValidateName   func(name string)
	afterValidateNameCounter  uint64
	beforeValidateNameCounter uint64
	ValidateNameMock          mValidatorMockValidateName
}

// NewValidatorMock returns a mock for mm_entity.Validator
func NewValidatorMock(t minimock.Tester) *ValidatorMock {
	m := &ValidatorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.NormalizeNameMock = mValidatorMockNormalizeName{mock: m}
	m.NormalizeNameMock.callArgs = []*ValidatorMockNormalizeNameParams{}

	m.ValidateNameMock = mValidatorMockValidateName{mock: m}
	m.ValidateNameMock.callArgs = []*ValidatorMockValidateNameParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mValidatorMockNormalizeName struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockNormalizeNameExpectation
	expectations       []*ValidatorMockNormalizeNameExpectation

	callArgs []*ValidatorMockNormalizeNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockNormalizeNameExpectation specifies expectation struct of the Validator.NormalizeName
type ValidatorMockNormalizeNameExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockNormalizeNameParams
	paramPtrs          *ValidatorMockNormalizeNameParamPtrs
	expectationOrigins ValidatorMockNormalizeNameExpectationOrigins
	results            *ValidatorMockNormalizeNameResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockNormalizeNameParams contains parameters of the Validator.NormalizeName
type ValidatorMockNormalizeNameParams struct {
	name string
}

// ValidatorMockNormalizeNameParamPtrs contains pointers to parameters of the Validator.NormalizeName
type ValidatorMockNormalizeNameParamPtrs struct {
	name *string
}

// ValidatorMockNormalizeNameResults contains results of the Validator.NormalizeName
type ValidatorMockNormalizeNameResults struct {
	s1 string
}

// ValidatorMockNormalizeNameOrigins contains origins of expectations of the Validator.NormalizeName
type ValidatorMockNormalizeNameExpectationOrigins struct {
	origin     string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNormalizeName *mValidatorMockNormalizeName) Optional() *mValidatorMockNormalizeName {
	mmNormalizeName.optional = true
	return mmNormalizeName
}

// Expect sets up expected params for Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) Expect(name string) *mValidatorMockNormalizeName {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	if mmNormalizeName.defaultExpectation == nil {
		mmNormalizeName.defaultExpectation = &ValidatorMockNormalizeNameExpectation{}
	}

	if mmNormalizeName.defaultExpectation.paramPtrs != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by ExpectParams functions")
	}

	mmNormalizeName.defaultExpectation.params = &ValidatorMockNormalizeNameParams{name}
	mmNormalizeName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNormalizeName.expectations {
		if minimock.Equal(e.params, mmNormalizeName.defaultExpectation.params) {
			mmNormalizeName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNormalizeName.defaultExpectation.params)
		}
	}

	return mmNormalizeName
}

// ExpectNameParam1 sets up expected param name for Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) ExpectNameParam1(name string) *mValidatorMockNormalizeName {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	if mmNormalizeName.defaultExpectation == nil {
		mmNormalizeName.defaultExpectation = &ValidatorMockNormalizeNameExpectation{}
	}

	if mmNormalizeName.defaultExpectation.params != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Expect")
	}

	if mmNormalizeName.defaultExpectation.paramPtrs == nil {
		mmNormalizeName.defaultExpectation.paramPtrs = &ValidatorMockNormalizeNameParamPtrs{}
	}
	mmNormalizeName.defaultExpectation.paramPtrs.name = &name
	mmNormalizeName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmNormalizeName
}

// Inspect accepts an inspector function that has same arguments as the Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) Inspect(f func(name string)) *mValidatorMockNormalizeName {
	if mmNormalizeName.mock.inspectFuncNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("Inspect function is already set for ValidatorMock.NormalizeName")
	}

	mmNormalizeName.mock.inspectFuncNormalizeName = f

	return mmNormalizeName
}

// Return sets up results that will be returned by Validator.NormalizeName
func (mmNormalizeName *mValidatorMockNormalizeName) Return(s1 string) *ValidatorMock {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	if mmNormalizeName.defaultExpectation == nil {
		mmNormalizeName.defaultExpectation = &ValidatorMockNormalizeNameExpectation{mock: mmNormalizeName.mock}
	}
	mmNormalizeName.defaultExpectation.results = &ValidatorMockNormalizeNameResults{s1}
	mmNormalizeName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNormalizeName.mock
}

// Set uses given function f to mock the Validator.NormalizeName method
func (mmNormalizeName *mValidatorMockNormalizeName) Set(f func(name string) (s1 string)) *ValidatorMock {
	if mmNormalizeName.defaultExpectation != nil {
		mmNormalizeName.mock.t.Fatalf("Default expectation is already set for the Validator.NormalizeName method")
	}

	if len(mmNormalizeName.expectations) > 0 {
		mmNormalizeName.mock.t.Fatalf("Some expectations are already set for the Validator.NormalizeName method")
	}

	mmNormalizeName.mock.funcNormalizeName = f
	mmNormalizeName.mock.funcNormalizeNameOrigin = minimock.CallerInfo(1)
	return mmNormalizeName.mock
}

// When sets expectation for the Validator.NormalizeName which will trigger the result defined by the following
// Then helper
func (mmNormalizeName *mValidatorMockNormalizeName) When(name string) *ValidatorMockNormalizeNameExpectation {
	if mmNormalizeName.mock.funcNormalizeName != nil {
		mmNormalizeName.mock.t.Fatalf("ValidatorMock.NormalizeName mock is already set by Set")
	}

	expectation := &ValidatorMockNormalizeNameExpectation{
		mock:               mmNormalizeName.mock,
		params:             &ValidatorMockNormalizeNameParams{name},
		expectationOrigins: ValidatorMockNormalizeNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNormalizeName.expectations = append(mmNormalizeName.expectations, expectation)
	return expectation
}

// Then sets up Validator.NormalizeName return parameters for the expectation previously defined by the When method
func (e *ValidatorMockNormalizeNameExpectation) Then(s1 string) *ValidatorMock {
	e.results = &ValidatorMockNormalizeNameResults{s1}
	return e.mock
}

// Times sets number of times Validator.NormalizeName should be invoked
func (mmNormalizeName *mValidatorMockNormalizeName) Times(n uint64) *mValidatorMockNormalizeName {
	if n == 0 {
		mmNormalizeName.mock.t.Fatalf("Times of ValidatorMock.NormalizeName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNormalizeName.expectedInvocations, n)
	mmNormalizeName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNormalizeName
}

func (mmNormalizeName *mValidatorMockNormalizeName) invocationsDone() bool {
	if len(mmNormalizeName.expectations) == 0 && mmNormalizeName.defaultExpectation == nil && mmNormalizeName.mock.funcNormalizeName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNormalizeName.mock.afterNormalizeNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNormalizeName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NormalizeName implements mm_entity.Validator
func (mmNormalizeName *ValidatorMock) NormalizeName(name string) (s1 string) {
	mm_atomic.AddUint64(&mmNormalizeName.beforeNormalizeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmNormalizeName.afterNormalizeNameCounter, 1)

	mmNormalizeName.t.Helper()

	if mmNormalizeName.inspectFuncNormalizeName != nil {
		mmNormalizeName.inspectFuncNormalizeName(name)
	}

	mm_params := ValidatorMockNormalizeNameParams{name}

	// Record call args
	mmNormalizeName.NormalizeNameMock.mutex.Lock()
	mmNormalizeName.NormalizeNameMock.callArgs = append(mmNormalizeName.NormalizeNameMock.callArgs, &mm_params)
	mmNormalizeName.NormalizeNameMock.mutex.Unlock()

	for _, e := range mmNormalizeName.NormalizeNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmNormalizeName.NormalizeNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNormalizeName.NormalizeNameMock.defaultExpectation.Counter, 1)
		mm_want := mmNormalizeName.NormalizeNameMock.defaultExpectation.params
		mm_want_ptrs := mmNormalizeName.NormalizeNameMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockNormalizeNameParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmNormalizeName.t.Errorf("ValidatorMock.NormalizeName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNormalizeName.NormalizeNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNormalizeName.t.Errorf("ValidatorMock.NormalizeName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNormalizeName.NormalizeNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNormalizeName.NormalizeNameMock.defaultExpectation.results
		if mm_results == nil {
			mmNormalizeName.t.Fatal("No results are set for the ValidatorMock.NormalizeName")
		}
		return (*mm_results).s1
	}
	if mmNormalizeName.funcNormalizeName != nil {
		return mmNormalizeName.funcNormalizeName(name)
	}
	mmNormalizeName.t.Fatalf("Unexpected call to ValidatorMock.NormalizeName. %v", name)
	return
}

// NormalizeNameAfterCounter returns a count of finished ValidatorMock.NormalizeName invocations
func (mmNormalizeName *ValidatorMock) NormalizeNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNormalizeName.afterNormalizeNameCounter)
}

// NormalizeNameBeforeCounter returns a count of ValidatorMock.NormalizeName invocations
func (mmNormalizeName *ValidatorMock) NormalizeNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNormalizeName.beforeNormalizeNameCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.NormalizeName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNormalizeName *mValidatorMockNormalizeName) Calls() []*ValidatorMockNormalizeNameParams {
	mmNormalizeName.mutex.RLock()

	argCopy := make([]*ValidatorMockNormalizeNameParams, len(mmNormalizeName.callArgs))
	copy(argCopy, mmNormalizeName.callArgs)

	mmNormalizeName.mutex.RUnlock()

	return argCopy
}

// MinimockNormalizeNameDone returns true if the count of the NormalizeName invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockNormalizeNameDone() bool {
	if m.NormalizeNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NormalizeNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NormalizeNameMock.invocationsDone()
}

// MinimockNormalizeNameInspect logs each unmet expectation
func (m *ValidatorMock) MinimockNormalizeNameInspect() {
	for _, e := range m.NormalizeNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNormalizeNameCounter := mm_atomic.LoadUint64(&m.afterNormalizeNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NormalizeNameMock.defaultExpectation != nil && afterNormalizeNameCounter < 1 {
		if m.NormalizeNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s", m.NormalizeNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s with params: %#v", m.NormalizeNameMock.defaultExpectation.expectationOrigins.origin, *m.NormalizeNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNormalizeName != nil && afterNormalizeNameCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.NormalizeName at\n%s", m.funcNormalizeNameOrigin)
	}

	if !m.NormalizeNameMock.invocationsDone() && afterNormalizeNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.NormalizeName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NormalizeNameMock.expectedInvocations), m.NormalizeNameMock.expectedInvocationsOrigin, afterNormalizeNameCounter)
	}
}

type mValidatorMockValidateName struct {
	optional           bool
	mock               *ValidatorMock
	defaultExpectation *ValidatorMockValidateNameExpectation
	expectations       []*ValidatorMockValidateNameExpectation

	callArgs []*ValidatorMockValidateNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ValidatorMockValidateNameExpectation specifies expectation struct of the Validator.ValidateName
type ValidatorMockValidateNameExpectation struct {
	mock               *ValidatorMock
	params             *ValidatorMockValidateNameParams
	paramPtrs          *ValidatorMockValidateNameParamPtrs
	expectationOrigins ValidatorMockValidateNameExpectationOrigins
	results            *ValidatorMockValidateNameResults
	returnOrigin       string
	Counter            uint64
}

// ValidatorMockValidateNameParams contains parameters of the Validator.ValidateName
type ValidatorMockValidateNameParams struct {
	name string
}

// ValidatorMockValidateNameParamPtrs contains pointers to parameters of the Validator.ValidateName
type ValidatorMockValidateNameParamPtrs struct {
	name *string
}

// ValidatorMockValidateNameResults contains results of the Validator.ValidateName
type ValidatorMockValidateNameResults struct {
	err error
}

// ValidatorMockValidateNameOrigins contains origins of expectations of the Validator.ValidateName
type ValidatorMockValidateNameExpectationOrigins struct {
	origin     string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateName *mValidatorMockValidateName) Optional() *mValidatorMockValidateName {
	mmValidateName.optional = true
	return mmValidateName
}

// Expect sets up expected params for Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) Expect(name string) *mValidatorMockValidateName {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	if mmValidateName.defaultExpectation == nil {
		mmValidateName.defaultExpectation = &ValidatorMockValidateNameExpectation{}
	}

	if mmValidateName.defaultExpectation.paramPtrs != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by ExpectParams functions")
	}

	mmValidateName.defaultExpectation.params = &ValidatorMockValidateNameParams{name}
	mmValidateName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateName.expectations {
		if minimock.Equal(e.params, mmValidateName.defaultExpectation.params) {
			mmValidateName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateName.defaultExpectation.params)
		}
	}

	return mmValidateName
}

// ExpectNameParam1 sets up expected param name for Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) ExpectNameParam1(name string) *mValidatorMockValidateName {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	if mmValidateName.defaultExpectation == nil {
		mmValidateName.defaultExpectation = &ValidatorMockValidateNameExpectation{}
	}

	if mmValidateName.defaultExpectation.params != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Expect")
	}

	if mmValidateName.defaultExpectation.paramPtrs == nil {
		mmValidateName.defaultExpectation.paramPtrs = &ValidatorMockValidateNameParamPtrs{}
	}
	mmValidateName.defaultExpectation.paramPtrs.name = &name
	mmValidateName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmValidateName
}

// Inspect accepts an inspector function that has same arguments as the Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) Inspect(f func(name string)) *mValidatorMockValidateName {
	if mmValidateName.mock.inspectFuncValidateName != nil {
		mmValidateName.mock.t.Fatalf("Inspect function is already set for ValidatorMock.ValidateName")
	}

	mmValidateName.mock.inspectFuncValidateName = f

	return mmValidateName
}

// Return sets up results that will be returned by Validator.ValidateName
func (mmValidateName *mValidatorMockValidateName) Return(err error) *ValidatorMock {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	if mmValidateName.defaultExpectation == nil {
		mmValidateName.defaultExpectation = &ValidatorMockValidateNameExpectation{mock: mmValidateName.mock}
	}
	mmValidateName.defaultExpectation.results = &ValidatorMockValidateNameResults{err}
	mmValidateName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateName.mock
}

// Set uses given function f to mock the Validator.ValidateName method
func (mmValidateName *mValidatorMockValidateName) Set(f func(name string) (err error)) *ValidatorMock {
	if mmValidateName.defaultExpectation != nil {
		mmValidateName.mock.t.Fatalf("Default expectation is already set for the Validator.ValidateName method")
	}

	if len(mmValidateName.expectations) > 0 {
		mmValidateName.mock.t.Fatalf("Some expectations are already set for the Validator.ValidateName method")
	}

	mmValidateName.mock.funcValidateName = f
	mmValidateName.mock.funcValidateNameOrigin = minimock.CallerInfo(1)
	return mmValidateName.mock
}

// When sets expectation for the Validator.ValidateName which will trigger the result defined by the following
// Then helper
func (mmValidateName *mValidatorMockValidateName) When(name string) *ValidatorMockValidateNameExpectation {
	if mmValidateName.mock.funcValidateName != nil {
		mmValidateName.mock.t.Fatalf("ValidatorMock.ValidateName mock is already set by Set")
	}

	expectation := &ValidatorMockValidateNameExpectation{
		mock:               mmValidateName.mock,
		params:             &ValidatorMockValidateNameParams{name},
		expectationOrigins: ValidatorMockValidateNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateName.expectations = append(mmValidateName.expectations, expectation)
	return expectation
}

// Then sets up Validator.ValidateName return parameters for the expectation previously defined by the When method
func (e *ValidatorMockValidateNameExpectation) Then(err error) *ValidatorMock {
	e.results = &ValidatorMockValidateNameResults{err}
	return e.mock
}

// Times sets number of times Validator.ValidateName should be invoked
func (mmValidateName *mValidatorMockValidateName) Times(n uint64) *mValidatorMockValidateName {
	if n == 0 {
		mmValidateName.mock.t.Fatalf("Times of ValidatorMock.ValidateName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateName.expectedInvocations, n)
	mmValidateName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateName
}

func (mmValidateName *mValidatorMockValidateName) invocationsDone() bool {
	if len(mmValidateName.expectations) == 0 && mmValidateName.defaultExpectation == nil && mmValidateName.mock.funcValidateName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateName.mock.afterValidateNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateName implements mm_entity.Validator
func (mmValidateName *ValidatorMock) ValidateName(name string) (err error) {
	mm_atomic.AddUint64(&mmValidateName.beforeValidateNameCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateName.afterValidateNameCounter, 1)

	mmValidateName.t.Helper()

	if mmValidateName.inspectFuncValidateName != nil {
		mmValidateName.inspectFuncValidateName(name)
	}

	mm_params := ValidatorMockValidateNameParams{name}

	// Record call args
	mmValidateName.ValidateNameMock.mutex.Lock()
	mmValidateName.ValidateNameMock.callArgs = append(mmValidateName.ValidateNameMock.callArgs, &mm_params)
	mmValidateName.ValidateNameMock.mutex.Unlock()

	for _, e := range mmValidateName.ValidateNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateName.ValidateNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateName.ValidateNameMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateName.ValidateNameMock.defaultExpectation.params
		mm_want_ptrs := mmValidateName.ValidateNameMock.defaultExpectation.paramPtrs

		mm_got := ValidatorMockValidateNameParams{name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmValidateName.t.Errorf("ValidatorMock.ValidateName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateName.ValidateNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateName.t.Errorf("ValidatorMock.ValidateName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateName.ValidateNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateName.ValidateNameMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateName.t.Fatal("No results are set for the ValidatorMock.ValidateName")
		}
		return (*mm_results).err
	}
	if mmValidateName.funcValidateName != nil {
		return mmValidateName.funcValidateName(name)
	}
	mmValidateName.t.Fatalf("Unexpected call to ValidatorMock.ValidateName. %v", name)
	return
}

// ValidateNameAfterCounter returns a count of finished ValidatorMock.ValidateName invocations
func (mmValidateName *ValidatorMock) ValidateNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateName.afterValidateNameCounter)
}

// ValidateNameBeforeCounter returns a count of ValidatorMock.ValidateName invocations
func (mmValidateName *ValidatorMock) ValidateNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateName.beforeValidateNameCounter)
}

// Calls returns a list of arguments used in each call to ValidatorMock.ValidateName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateName *mValidatorMockValidateName) Calls() []*ValidatorMockValidateNameParams {
	mmValidateName.mutex.RLock()

	argCopy := make([]*ValidatorMockValidateNameParams, len(mmValidateName.callArgs))
	copy(argCopy, mmValidateName.callArgs)

	mmValidateName.mutex.RUnlock()

	return argCopy
}

// MinimockValidateNameDone returns true if the count of the ValidateName invocations corresponds
// the number of defined expectations
func (m *ValidatorMock) MinimockValidateNameDone() bool {
	if m.ValidateNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateNameMock.invocationsDone()
}

// MinimockValidateNameInspect logs each unmet expectation
func (m *ValidatorMock) MinimockValidateNameInspect() {
	for _, e := range m.ValidateNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateNameCounter := mm_atomic.LoadUint64(&m.afterValidateNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateNameMock.defaultExpectation != nil && afterValidateNameCounter < 1 {
		if m.ValidateNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s", m.ValidateNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s with params: %#v", m.ValidateNameMock.defaultExpectation.expectationOrigins.origin, *m.ValidateNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateName != nil && afterValidateNameCounter < 1 {
		m.t.Errorf("Expected call to ValidatorMock.ValidateName at\n%s", m.funcValidateNameOrigin)
	}

	if !m.ValidateNameMock.invocationsDone() && afterValidateNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ValidatorMock.ValidateName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateNameMock.expectedInvocations), m.ValidateNameMock.expectedInvocationsOrigin, afterValidateNameCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ValidatorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockNormalizeNameInspect()

			m.MinimockValidateNameInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ValidatorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ValidatorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockNormalizeNameDone() &&
		m.MinimockValidateNameDone()
}
