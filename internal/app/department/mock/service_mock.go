// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/66gu1/easygodocs/internal/app/department.Service -o service_mock.go -n ServiceMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_department "github.com/66gu1/easygodocs/internal/app/department"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ServiceMock implements mm_department.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, req mm_department.CreateDepartmentReq) (u1 uuid.UUID, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, req mm_department.CreateDepartmentReq)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mServiceMockCreate

	funcDelete          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mServiceMockDelete

	funcGetDepartmentTree          func(ctx context.Context) (t1 mm_department.Tree, err error)
	funcGetDepartmentTreeOrigin    string
	inspectFuncGetDepartmentTree   func(ctx context.Context)
	afterGetDepartmentTreeCounter  uint64
	beforeGetDepartmentTreeCounter uint64
	GetDepartmentTreeMock          mServiceMockGetDepartmentTree

	funcUpdate          func(ctx context.Context, req mm_department.UpdateDepartmentReq) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, req mm_department.UpdateDepartmentReq)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mServiceMockUpdate
}

// NewServiceMock returns a mock for mm_department.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ServiceMockCreateParams{}

	m.DeleteMock = mServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ServiceMockDeleteParams{}

	m.GetDepartmentTreeMock = mServiceMockGetDepartmentTree{mock: m}
	m.GetDepartmentTreeMock.callArgs = []*ServiceMockGetDepartmentTreeParams{}

	m.UpdateMock = mServiceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*ServiceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockCreate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateExpectation
	expectations       []*ServiceMockCreateExpectation

	callArgs []*ServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateExpectation specifies expectation struct of the Service.Create
type ServiceMockCreateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateParams
	paramPtrs          *ServiceMockCreateParamPtrs
	expectationOrigins ServiceMockCreateExpectationOrigins
	results            *ServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateParams contains parameters of the Service.Create
type ServiceMockCreateParams struct {
	ctx context.Context
	req mm_department.CreateDepartmentReq
}

// ServiceMockCreateParamPtrs contains pointers to parameters of the Service.Create
type ServiceMockCreateParamPtrs struct {
	ctx *context.Context
	req *mm_department.CreateDepartmentReq
}

// ServiceMockCreateResults contains results of the Service.Create
type ServiceMockCreateResults struct {
	u1  uuid.UUID
	err error
}

// ServiceMockCreateOrigins contains origins of expectations of the Service.Create
type ServiceMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mServiceMockCreate) Optional() *mServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Service.Create
func (mmCreate *mServiceMockCreate) Expect(ctx context.Context, req mm_department.CreateDepartmentReq) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ServiceMockCreateParams{ctx, req}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Service.Create
func (mmCreate *mServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectReqParam2 sets up expected param req for Service.Create
func (mmCreate *mServiceMockCreate) ExpectReqParam2(req mm_department.CreateDepartmentReq) *mServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.req = &req
	mmCreate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Service.Create
func (mmCreate *mServiceMockCreate) Inspect(f func(ctx context.Context, req mm_department.CreateDepartmentReq)) *mServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Service.Create
func (mmCreate *mServiceMockCreate) Return(u1 uuid.UUID, err error) *ServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ServiceMockCreateResults{u1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the Service.Create method
func (mmCreate *mServiceMockCreate) Set(f func(ctx context.Context, req mm_department.CreateDepartmentReq) (u1 uuid.UUID, err error)) *ServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Service.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Service.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the Service.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mServiceMockCreate) When(ctx context.Context, req mm_department.CreateDepartmentReq) *ServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ServiceMock.Create mock is already set by Set")
	}

	expectation := &ServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ServiceMockCreateParams{ctx, req},
		expectationOrigins: ServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Service.Create return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateExpectation) Then(u1 uuid.UUID, err error) *ServiceMock {
	e.results = &ServiceMockCreateResults{u1, err}
	return e.mock
}

// Times sets number of times Service.Create should be invoked
func (mmCreate *mServiceMockCreate) Times(n uint64) *mServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_department.Service
func (mmCreate *ServiceMock) Create(ctx context.Context, req mm_department.CreateDepartmentReq) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, req)
	}

	mm_params := ServiceMockCreateParams{ctx, req}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreate.t.Errorf("ServiceMock.Create got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ServiceMock.Create")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, req)
	}
	mmCreate.t.Fatalf("Unexpected call to ServiceMock.Create. %v %v", ctx, req)
	return
}

// CreateAfterCounter returns a count of finished ServiceMock.Create invocations
func (mmCreate *ServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ServiceMock.Create invocations
func (mmCreate *ServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mServiceMockCreate) Calls() []*ServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mServiceMockDelete struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteExpectation
	expectations       []*ServiceMockDeleteExpectation

	callArgs []*ServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteExpectation specifies expectation struct of the Service.Delete
type ServiceMockDeleteExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteParams
	paramPtrs          *ServiceMockDeleteParamPtrs
	expectationOrigins ServiceMockDeleteExpectationOrigins
	results            *ServiceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteParams contains parameters of the Service.Delete
type ServiceMockDeleteParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockDeleteParamPtrs contains pointers to parameters of the Service.Delete
type ServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// ServiceMockDeleteResults contains results of the Service.Delete
type ServiceMockDeleteResults struct {
	err error
}

// ServiceMockDeleteOrigins contains origins of expectations of the Service.Delete
type ServiceMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mServiceMockDelete) Optional() *mServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Service.Delete
func (mmDelete *mServiceMockDelete) Expect(ctx context.Context, id uuid.UUID) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ServiceMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Service.Delete
func (mmDelete *mServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for Service.Delete
func (mmDelete *mServiceMockDelete) ExpectIdParam2(id uuid.UUID) *mServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Service.Delete
func (mmDelete *mServiceMockDelete) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Service.Delete
func (mmDelete *mServiceMockDelete) Return(err error) *ServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ServiceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Service.Delete method
func (mmDelete *mServiceMockDelete) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *ServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Service.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Service.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Service.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mServiceMockDelete) When(ctx context.Context, id uuid.UUID) *ServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ServiceMock.Delete mock is already set by Set")
	}

	expectation := &ServiceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &ServiceMockDeleteParams{ctx, id},
		expectationOrigins: ServiceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Service.Delete return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Service.Delete should be invoked
func (mmDelete *mServiceMockDelete) Times(n uint64) *mServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_department.Service
func (mmDelete *ServiceMock) Delete(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := ServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ServiceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to ServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished ServiceMock.Delete invocations
func (mmDelete *ServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ServiceMock.Delete invocations
func (mmDelete *ServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mServiceMockDelete) Calls() []*ServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mServiceMockGetDepartmentTree struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetDepartmentTreeExpectation
	expectations       []*ServiceMockGetDepartmentTreeExpectation

	callArgs []*ServiceMockGetDepartmentTreeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetDepartmentTreeExpectation specifies expectation struct of the Service.GetDepartmentTree
type ServiceMockGetDepartmentTreeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetDepartmentTreeParams
	paramPtrs          *ServiceMockGetDepartmentTreeParamPtrs
	expectationOrigins ServiceMockGetDepartmentTreeExpectationOrigins
	results            *ServiceMockGetDepartmentTreeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetDepartmentTreeParams contains parameters of the Service.GetDepartmentTree
type ServiceMockGetDepartmentTreeParams struct {
	ctx context.Context
}

// ServiceMockGetDepartmentTreeParamPtrs contains pointers to parameters of the Service.GetDepartmentTree
type ServiceMockGetDepartmentTreeParamPtrs struct {
	ctx *context.Context
}

// ServiceMockGetDepartmentTreeResults contains results of the Service.GetDepartmentTree
type ServiceMockGetDepartmentTreeResults struct {
	t1  mm_department.Tree
	err error
}

// ServiceMockGetDepartmentTreeOrigins contains origins of expectations of the Service.GetDepartmentTree
type ServiceMockGetDepartmentTreeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Optional() *mServiceMockGetDepartmentTree {
	mmGetDepartmentTree.optional = true
	return mmGetDepartmentTree
}

// Expect sets up expected params for Service.GetDepartmentTree
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Expect(ctx context.Context) *mServiceMockGetDepartmentTree {
	if mmGetDepartmentTree.mock.funcGetDepartmentTree != nil {
		mmGetDepartmentTree.mock.t.Fatalf("ServiceMock.GetDepartmentTree mock is already set by Set")
	}

	if mmGetDepartmentTree.defaultExpectation == nil {
		mmGetDepartmentTree.defaultExpectation = &ServiceMockGetDepartmentTreeExpectation{}
	}

	if mmGetDepartmentTree.defaultExpectation.paramPtrs != nil {
		mmGetDepartmentTree.mock.t.Fatalf("ServiceMock.GetDepartmentTree mock is already set by ExpectParams functions")
	}

	mmGetDepartmentTree.defaultExpectation.params = &ServiceMockGetDepartmentTreeParams{ctx}
	mmGetDepartmentTree.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDepartmentTree.expectations {
		if minimock.Equal(e.params, mmGetDepartmentTree.defaultExpectation.params) {
			mmGetDepartmentTree.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDepartmentTree.defaultExpectation.params)
		}
	}

	return mmGetDepartmentTree
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetDepartmentTree
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) ExpectCtxParam1(ctx context.Context) *mServiceMockGetDepartmentTree {
	if mmGetDepartmentTree.mock.funcGetDepartmentTree != nil {
		mmGetDepartmentTree.mock.t.Fatalf("ServiceMock.GetDepartmentTree mock is already set by Set")
	}

	if mmGetDepartmentTree.defaultExpectation == nil {
		mmGetDepartmentTree.defaultExpectation = &ServiceMockGetDepartmentTreeExpectation{}
	}

	if mmGetDepartmentTree.defaultExpectation.params != nil {
		mmGetDepartmentTree.mock.t.Fatalf("ServiceMock.GetDepartmentTree mock is already set by Expect")
	}

	if mmGetDepartmentTree.defaultExpectation.paramPtrs == nil {
		mmGetDepartmentTree.defaultExpectation.paramPtrs = &ServiceMockGetDepartmentTreeParamPtrs{}
	}
	mmGetDepartmentTree.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDepartmentTree.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDepartmentTree
}

// Inspect accepts an inspector function that has same arguments as the Service.GetDepartmentTree
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Inspect(f func(ctx context.Context)) *mServiceMockGetDepartmentTree {
	if mmGetDepartmentTree.mock.inspectFuncGetDepartmentTree != nil {
		mmGetDepartmentTree.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetDepartmentTree")
	}

	mmGetDepartmentTree.mock.inspectFuncGetDepartmentTree = f

	return mmGetDepartmentTree
}

// Return sets up results that will be returned by Service.GetDepartmentTree
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Return(t1 mm_department.Tree, err error) *ServiceMock {
	if mmGetDepartmentTree.mock.funcGetDepartmentTree != nil {
		mmGetDepartmentTree.mock.t.Fatalf("ServiceMock.GetDepartmentTree mock is already set by Set")
	}

	if mmGetDepartmentTree.defaultExpectation == nil {
		mmGetDepartmentTree.defaultExpectation = &ServiceMockGetDepartmentTreeExpectation{mock: mmGetDepartmentTree.mock}
	}
	mmGetDepartmentTree.defaultExpectation.results = &ServiceMockGetDepartmentTreeResults{t1, err}
	mmGetDepartmentTree.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDepartmentTree.mock
}

// Set uses given function f to mock the Service.GetDepartmentTree method
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Set(f func(ctx context.Context) (t1 mm_department.Tree, err error)) *ServiceMock {
	if mmGetDepartmentTree.defaultExpectation != nil {
		mmGetDepartmentTree.mock.t.Fatalf("Default expectation is already set for the Service.GetDepartmentTree method")
	}

	if len(mmGetDepartmentTree.expectations) > 0 {
		mmGetDepartmentTree.mock.t.Fatalf("Some expectations are already set for the Service.GetDepartmentTree method")
	}

	mmGetDepartmentTree.mock.funcGetDepartmentTree = f
	mmGetDepartmentTree.mock.funcGetDepartmentTreeOrigin = minimock.CallerInfo(1)
	return mmGetDepartmentTree.mock
}

// When sets expectation for the Service.GetDepartmentTree which will trigger the result defined by the following
// Then helper
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) When(ctx context.Context) *ServiceMockGetDepartmentTreeExpectation {
	if mmGetDepartmentTree.mock.funcGetDepartmentTree != nil {
		mmGetDepartmentTree.mock.t.Fatalf("ServiceMock.GetDepartmentTree mock is already set by Set")
	}

	expectation := &ServiceMockGetDepartmentTreeExpectation{
		mock:               mmGetDepartmentTree.mock,
		params:             &ServiceMockGetDepartmentTreeParams{ctx},
		expectationOrigins: ServiceMockGetDepartmentTreeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDepartmentTree.expectations = append(mmGetDepartmentTree.expectations, expectation)
	return expectation
}

// Then sets up Service.GetDepartmentTree return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetDepartmentTreeExpectation) Then(t1 mm_department.Tree, err error) *ServiceMock {
	e.results = &ServiceMockGetDepartmentTreeResults{t1, err}
	return e.mock
}

// Times sets number of times Service.GetDepartmentTree should be invoked
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Times(n uint64) *mServiceMockGetDepartmentTree {
	if n == 0 {
		mmGetDepartmentTree.mock.t.Fatalf("Times of ServiceMock.GetDepartmentTree mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDepartmentTree.expectedInvocations, n)
	mmGetDepartmentTree.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDepartmentTree
}

func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) invocationsDone() bool {
	if len(mmGetDepartmentTree.expectations) == 0 && mmGetDepartmentTree.defaultExpectation == nil && mmGetDepartmentTree.mock.funcGetDepartmentTree == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDepartmentTree.mock.afterGetDepartmentTreeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDepartmentTree.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDepartmentTree implements mm_department.Service
func (mmGetDepartmentTree *ServiceMock) GetDepartmentTree(ctx context.Context) (t1 mm_department.Tree, err error) {
	mm_atomic.AddUint64(&mmGetDepartmentTree.beforeGetDepartmentTreeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDepartmentTree.afterGetDepartmentTreeCounter, 1)

	mmGetDepartmentTree.t.Helper()

	if mmGetDepartmentTree.inspectFuncGetDepartmentTree != nil {
		mmGetDepartmentTree.inspectFuncGetDepartmentTree(ctx)
	}

	mm_params := ServiceMockGetDepartmentTreeParams{ctx}

	// Record call args
	mmGetDepartmentTree.GetDepartmentTreeMock.mutex.Lock()
	mmGetDepartmentTree.GetDepartmentTreeMock.callArgs = append(mmGetDepartmentTree.GetDepartmentTreeMock.callArgs, &mm_params)
	mmGetDepartmentTree.GetDepartmentTreeMock.mutex.Unlock()

	for _, e := range mmGetDepartmentTree.GetDepartmentTreeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation.params
		mm_want_ptrs := mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetDepartmentTreeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDepartmentTree.t.Errorf("ServiceMock.GetDepartmentTree got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDepartmentTree.t.Errorf("ServiceMock.GetDepartmentTree got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDepartmentTree.GetDepartmentTreeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDepartmentTree.t.Fatal("No results are set for the ServiceMock.GetDepartmentTree")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmGetDepartmentTree.funcGetDepartmentTree != nil {
		return mmGetDepartmentTree.funcGetDepartmentTree(ctx)
	}
	mmGetDepartmentTree.t.Fatalf("Unexpected call to ServiceMock.GetDepartmentTree. %v", ctx)
	return
}

// GetDepartmentTreeAfterCounter returns a count of finished ServiceMock.GetDepartmentTree invocations
func (mmGetDepartmentTree *ServiceMock) GetDepartmentTreeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDepartmentTree.afterGetDepartmentTreeCounter)
}

// GetDepartmentTreeBeforeCounter returns a count of ServiceMock.GetDepartmentTree invocations
func (mmGetDepartmentTree *ServiceMock) GetDepartmentTreeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDepartmentTree.beforeGetDepartmentTreeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetDepartmentTree.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDepartmentTree *mServiceMockGetDepartmentTree) Calls() []*ServiceMockGetDepartmentTreeParams {
	mmGetDepartmentTree.mutex.RLock()

	argCopy := make([]*ServiceMockGetDepartmentTreeParams, len(mmGetDepartmentTree.callArgs))
	copy(argCopy, mmGetDepartmentTree.callArgs)

	mmGetDepartmentTree.mutex.RUnlock()

	return argCopy
}

// MinimockGetDepartmentTreeDone returns true if the count of the GetDepartmentTree invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDepartmentTreeDone() bool {
	if m.GetDepartmentTreeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDepartmentTreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDepartmentTreeMock.invocationsDone()
}

// MinimockGetDepartmentTreeInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetDepartmentTreeInspect() {
	for _, e := range m.GetDepartmentTreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetDepartmentTree at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDepartmentTreeCounter := mm_atomic.LoadUint64(&m.afterGetDepartmentTreeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDepartmentTreeMock.defaultExpectation != nil && afterGetDepartmentTreeCounter < 1 {
		if m.GetDepartmentTreeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetDepartmentTree at\n%s", m.GetDepartmentTreeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetDepartmentTree at\n%s with params: %#v", m.GetDepartmentTreeMock.defaultExpectation.expectationOrigins.origin, *m.GetDepartmentTreeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDepartmentTree != nil && afterGetDepartmentTreeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetDepartmentTree at\n%s", m.funcGetDepartmentTreeOrigin)
	}

	if !m.GetDepartmentTreeMock.invocationsDone() && afterGetDepartmentTreeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetDepartmentTree at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDepartmentTreeMock.expectedInvocations), m.GetDepartmentTreeMock.expectedInvocationsOrigin, afterGetDepartmentTreeCounter)
	}
}

type mServiceMockUpdate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateExpectation
	expectations       []*ServiceMockUpdateExpectation

	callArgs []*ServiceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUpdateExpectation specifies expectation struct of the Service.Update
type ServiceMockUpdateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUpdateParams
	paramPtrs          *ServiceMockUpdateParamPtrs
	expectationOrigins ServiceMockUpdateExpectationOrigins
	results            *ServiceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUpdateParams contains parameters of the Service.Update
type ServiceMockUpdateParams struct {
	ctx context.Context
	req mm_department.UpdateDepartmentReq
}

// ServiceMockUpdateParamPtrs contains pointers to parameters of the Service.Update
type ServiceMockUpdateParamPtrs struct {
	ctx *context.Context
	req *mm_department.UpdateDepartmentReq
}

// ServiceMockUpdateResults contains results of the Service.Update
type ServiceMockUpdateResults struct {
	err error
}

// ServiceMockUpdateOrigins contains origins of expectations of the Service.Update
type ServiceMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mServiceMockUpdate) Optional() *mServiceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for Service.Update
func (mmUpdate *mServiceMockUpdate) Expect(ctx context.Context, req mm_department.UpdateDepartmentReq) *mServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &ServiceMockUpdateParams{ctx, req}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Service.Update
func (mmUpdate *mServiceMockUpdate) ExpectCtxParam1(ctx context.Context) *mServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &ServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectReqParam2 sets up expected param req for Service.Update
func (mmUpdate *mServiceMockUpdate) ExpectReqParam2(req mm_department.UpdateDepartmentReq) *mServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &ServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.req = &req
	mmUpdate.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Service.Update
func (mmUpdate *mServiceMockUpdate) Inspect(f func(ctx context.Context, req mm_department.UpdateDepartmentReq)) *mServiceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for ServiceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Service.Update
func (mmUpdate *mServiceMockUpdate) Return(err error) *ServiceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ServiceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &ServiceMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the Service.Update method
func (mmUpdate *mServiceMockUpdate) Set(f func(ctx context.Context, req mm_department.UpdateDepartmentReq) (err error)) *ServiceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Service.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Service.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the Service.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mServiceMockUpdate) When(ctx context.Context, req mm_department.UpdateDepartmentReq) *ServiceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ServiceMock.Update mock is already set by Set")
	}

	expectation := &ServiceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &ServiceMockUpdateParams{ctx, req},
		expectationOrigins: ServiceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Service.Update return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times Service.Update should be invoked
func (mmUpdate *mServiceMockUpdate) Times(n uint64) *mServiceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of ServiceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mServiceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_department.Service
func (mmUpdate *ServiceMock) Update(ctx context.Context, req mm_department.UpdateDepartmentReq) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, req)
	}

	mm_params := ServiceMockUpdateParams{ctx, req}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUpdateParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("ServiceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmUpdate.t.Errorf("ServiceMock.Update got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("ServiceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the ServiceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, req)
	}
	mmUpdate.t.Fatalf("Unexpected call to ServiceMock.Update. %v %v", ctx, req)
	return
}

// UpdateAfterCounter returns a count of finished ServiceMock.Update invocations
func (mmUpdate *ServiceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of ServiceMock.Update invocations
func (mmUpdate *ServiceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mServiceMockUpdate) Calls() []*ServiceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetDepartmentTreeInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDepartmentTreeDone() &&
		m.MinimockUpdateDone()
}
